<html>
<!-- Generated by lit2html -->
<head>
<title>The Glorious Glasgow Haskell Compilation System Version 0.26 User's Guide</title>
</head>
<body>
<h1>The Glorious Glasgow Haskell Compilation System Version 0.26 User's Guide</h1>
<address>The AQUA Team  Department of Computing Science  University of Glasgow  Glasgow, Scotland  G12 8QQ    Email: glasgow-haskell-{bugs,users}-request@dcs.glasgow.ac.uk<br>
</address>
<hr><p>
<p>

<p>

<a name="introduction-GHC"><h2>Introduction to GHC</h2></a>

This is a guide to using the Glasgow Haskell compilation (GHC) system.
It is a batch compiler for the Haskell 1.2 language, with support for
various extensions, including the DRAFT 1.3 I/O proposal.
<p>
Many people will use GHC very simply: compile some
modules -- <tt>ghc -c -O Foo.hs Bar.hs</tt>; and link them -- 
<tt>ghc -o wiggle -O Foo.o Bar.o</tt>.
<p>
But if you need to do something more complicated, GHC can do that,
too:

<pre>
ghc -c -O -fno-foldr-build -dcore-lint -fvia-C -ddump-simpl Foo.lhs
</pre><p>
Stay tuned -- all will be revealed!
<p>
In this document, we assume that GHC has been installed at your
site as <tt>ghc</tt>.
If you are unfamiliar with the conventions of UNIX compilers, the
material in part <a href="#compiler-tutorial">compiler-tutorial</a> may help.
<p>

<a name="mailing-lists-GHC"><h2>Knowing us, knowing you: Web sites, mailing lists, etc.</h2></a>
<a name="mailing lists, Glasgow Haskell"></a>
<p>
<a name="Glasgow Haskell mailing lists"></a>
<p>
On the World-Wide Web, there are several URLs of likely interest:
<p><pre>
GHC home page -- http://www.dcs.glasgow.ac.uk/fp/software/ghc/
Glasgow FP group page -- http://www.dcs.glasgow.ac.uk/fp/
comp.lang.functional FAQ -- http://www.cs.nott.ac.uk/Department/Staff/mpj/faq.html
programming language research page --
   http://www.cs.cmu.edu/afs/cs.cmu.edu/user/mleone/web/language-research.html

<a name="mailing lists, Glasgow Haskell"></a>
<a name="Glasgow Haskell mailing lists"></a>
</pre><p>
We run two mailing lists about Glasgow Haskell.  We encourage you to
join, as you feel is appropriate.
<dl>
<dt>glasgow-haskell-users:
<dd>This list is for GHC users to chat among themselves.  Subscribe by
sending mail to <tt>majordomo@dcs.gla.ac.uk</tt>, with
a message body (not header) like this:

<pre>
subscribe glasgow-haskell-users My Name &lt;m.y.self@bigbucks.com&gt;
</pre><p>
(The last bit is your all-important e-mail address, of course.)
<p>
To communicate with your fellow users, send mail to <tt>glasgow-haskell-users</tt>.
<p>
To contact the list administrator, send mail to
<tt>glasgow-haskell-users-request</tt>.
<p>
<dt>glasgow-haskell-bugs:
<dd>Send bug reports for GHC to this address!  The sad and lonely people
who subscribe to this list will muse upon what's wrong and what you
might do about it.
<p>
Subscribe via <tt>majordomo@dcs.gla.ac.uk</tt> with:

<pre>
subscribe glasgow-haskell-bugs My Name &lt;m.y.self@hackers.r.us&gt;
</pre><p>

Again, you may contact the list administrator at
<tt>glasgow-haskell-bugs-request</tt>.
</dl>
<p>
There is also the general Haskell mailing list.  Subscribe by sending
email to <tt>majordomo@dcs.gla.ac.uk</tt>, with the usual message body:

<pre>
subscribe haskell My Name &lt;m.y.self@fp.rules.ok.org&gt;
</pre><p>

Some Haskell-related discussion takes place in the Usenet newsgroup
<tt>comp.lang.functional</tt>.  (But note: news propagation to Glasgow can
be terrible.  That's one reason Glaswegians aren't too active in
c.f.l.)
<p>
The main anonymous-FTP site for Glasgow Haskell is
<tt>ftp.dcs.glasgow.ac.uk</tt>, in <tt>pub/haskell/glasgow/</tt>.
"Important" bits are mirrored at other Haskell archive sites (and we
have their stuff, too).
<p>




<a name="invoking-GHC"><h2>Invoking GHC: Command-line options</h2></a>
<a name="command-line options"></a>
<p>
<a name="options, GHC command-line"></a>
<p>
Command-line arguments are either options or file names.
<p>
Command-line options begin with <tt>-</tt>.  They may <i>not</i> be
grouped: <tt>-vO</tt> is different from <tt>-v -O</tt>.
Options need not precede filenames: e.g., <tt>ghc *.o -o foo</tt>.
All options are processed
and then apply to all files; you cannot, for example,
invoke <tt>ghc -c -O1 Foo.hs -O2 Bar.hs</tt> to apply different
optimisation levels to the files <tt>Foo.hs</tt> and <tt>Bar.hs</tt>.  For
conflicting options, e.g., <tt>-c -S</tt>, we reserve the right to do
anything we want.  (Usually, the last one applies.)
<p>
Options related to profiling, Glasgow extensions to Haskell (e.g.,
unboxed values), Concurrent and Parallel Haskell are
described in part <a href="#profiling}, part \ref{glasgow-exts">profiling}, part \ref{glasgow-exts</a>, and
part <a href="#concurrent-and-parallel">concurrent-and-parallel</a>, respectively.
<p>

<a name="command-line options"></a>
<a name="options, GHC command-line"></a>
<a name="file-suffixes"><h3>Meaningful file suffixes</h3></a>
<a name="suffixes, file"></a>
<p>
<a name="file suffixes for GHC"></a>
<p>
File names with "meaningful" suffixes (e.g., <tt>.lhs</tt> or <tt>.o</tt>)
cause the "right thing" to happen to those files.
<p>
<dl>
<dt><tt>.lhs</tt>:
<dd><a name=".lhs suffix"></a>
<p>
A "literate Haskell" module.
<p>
<dt><tt>.hs</tt>:
<dd>A not-so-literate Haskell module.
<p>
<dt><tt>.hi</tt>:
<dd>A Haskell interface file, probably compiler-generated.
<p>
<dt><tt>.hc</tt>:
<dd>Intermediate C file produced by the Haskell compiler.
<p>
<dt><tt>.c</tt>:
<dd>A C file not produced by the Haskell compiler.
<p>
<dt><tt>.s</tt>:
<dd>An assembly-language source file, usually
produced by the compiler.
<p>
<dt><tt>.o</tt>:
<dd>An object file, produced by an assembler.
</dl>
<p>
Files with other suffixes (or without suffixes) are passed straight
to the linker.
<p>

<a name="suffixes, file"></a>
<a name="file suffixes for GHC"></a>
<a name=".lhs suffix"></a>
<a name="options-help"><h3>Help and verbosity options</h3></a>
<a name="help options (GHC)"></a>
<p>
<a name="verbose option (GHC)"></a>
<p>
A good option to start with is the <tt>-help</tt> (or <tt>-?</tt>) option.
<a name="-help option"></a>
<p>
<a name="-? option"></a>
<p>
GHC spews a long message to standard output and then exits.
<p>
The <tt>-v</tt><a name="-v option"></a>
 option makes GHC <i>verbose</i>: it
reports its version number and shows (on stderr) exactly how it invokes each 
phase of the compilation system.  Moreover, it passes
the <tt>-v</tt> flag to most phases; each reports
its version number (and possibly some other information).
<p>
Please, oh please, use the <tt>-v</tt> option when reporting bugs!
Knowing that you ran the right bits in the right order is always the
first thing we want to verify.
<p>

<a name="help options (GHC)"></a>
<a name="verbose option (GHC)"></a>
<a name="-help option"></a>
<a name="-? option"></a>
<a name="-v option"></a>
<a name="options-order"><h3>Running the right phases in the right order</h3></a>
<a name="order of passes in GHC"></a>
<p>
<a name="pass ordering in GHC"></a>
<p>
The basic task of the <tt>ghc</tt> driver is to run each input file
through the right phases (parsing, linking, etc.).
<p>
The first phase to run is determined by the input-file suffix, and the
last phase is determined by a flag.  If no relevant flag is present,
then go all the way through linking.  This table summarises:
<p>

<a name="order of passes in GHC"></a>
<a name="pass ordering in GHC"></a>
<pre>
phase of the                     suffix saying  flag saying   (suffix of)  
compilation system               "start here"   "stop after"  output file  
\hline<p>literate pre-processor  .lhs           -             -            
C pre-processor (opt.)           -              -             -            
Haskell parser                   .hs            -             -            
Haskell compiler                 -              -C, -S        .hc, .s      
C compiler (opt.)                .hc or .c      -S            .s           
assembler                        .s             -c            .o           
linker                           other          -             a.out        
</pre>

<a name="-C option"></a>
<p>
<a name="-S option"></a>
<p>
<a name="-c option"></a>
<p>
Thus, a common invocation would be: <tt>ghc -c Foo.hs</tt>
<p>
Note: What the Haskell compiler proper produces depends on whether a
native-code generator is used (producing assembly language) or not
(producing C).
<p>
The option <tt>-cpp</tt><a name="-cpp option"></a>
 must be given for the C
pre-processor phase to be run.
<p>
The option <tt>-E</tt><a name="-E option"></a>
 runs just the C-preprocessor part
of the C-compiling phase, sending the result to stdout [I think].  (For
debugging, usually.)
<p>

<a name="-C option"></a>
<a name="-S option"></a>
<a name="-c option"></a>
<a name="-cpp option"></a>
<a name="-E option"></a>
<a name="options-optimise"><h3>Optimisation (code improvement)</h3></a>
<a name="optimisation (GHC)"></a>
<p>
<a name="improvement, code (GHC)"></a>
<p>
The <tt>-O*</tt> options specify convenient "packages" of optimisation
flags; the <tt>-f*</tt> options described later on specify <i>individual</i>
optimisations to be turned on/off; the <tt>-m*</tt> options specify <i>machine-specific</i> optimisations to be turned on/off.
<p>

<a name="optimisation (GHC)"></a>
<a name="improvement, code (GHC)"></a>
<a name="optimise-pkgs"><h4><tt>-O*</tt>: convenient "packages" of optimisation flags.</h4></a>
<a name="-O options (GHC)"></a>
<p>
There are <i>many</i> options that affect the quality of code produced by
GHC.  Most people only have a general goal, something like "Compile
quickly" or "Make my program run like greased lightning."  The
following "packages" of optimisations (or lack thereof) should suffice.
<p>
Once you choose a <tt>-O*</tt> "package," stick with it -- don't chop and
change.  Modules' interfaces <i>will</i> change with a shift to a new
<tt>-O*</tt> option, and you will have to recompile all importing modules
before your program can again be run safely.
<p>
<dl>
<dt>No <tt>-O*</tt>-type option specified:
<dd><a name="-O* not specified"></a>
<p>
This is taken to mean: "Please compile quickly; I'm not over-bothered
about compiled-code quality."  So, for example: <tt>ghc -c Foo.hs</tt>
<p>
<dt><tt>-O</tt> or <tt>-O1</tt>:
<dd><a name="-O option"></a>
<p>
<a name="-O1 option"></a>
<p>
<a name="optimise normally"></a>
<p>
Means: "Generate good-quality code without taking too long about it."
Thus, for example: <tt>ghc -c -O Main.lhs</tt>
<p>
<dt><tt>-O2</tt>:
<dd><a name="-O2 option"></a>
<p>
<a name="optimise aggressively"></a>
<p>
Means: "Apply every non-dangerous optimisation, even if it means
significantly longer compile times."
<p>
The avoided "dangerous" optimisations are those that can make
runtime or space <i>worse</i> if you're unlucky.  They are
normally turned on or off individually.
<p>
As of version 0.26, <tt>-O2</tt> is <i>unlikely</i> to produce
better code than <tt>-O</tt>.
<p>
<dt><tt>-fvia-C</tt>:
<dd><a name="-fvia-C option"></a>
<p>
Compile via C, and don't use the native-code generator.
(There are many cases when GHC does this on its own.)  You might
pick up a little bit of speed by compiling via C.  If you use
<tt>_ccall_</tt>s or <tt>_casm_</tt>s, you probably <i>have to</i> use
<tt>-fvia-C</tt>.
<p>
<dt><tt>-O2-for-C</tt>:
<dd><a name="-O2-for-C option"></a>
<p>
Says to run GCC with <tt>-O2</tt>, which may be worth a few percent in
execution speed.  Don't forget <tt>-fvia-C</tt>, lest you use the
native-code generator and bypass GCC altogether!
<p>
<dt><tt>-Onot</tt>:
<dd><a name="-Onot option"></a>
<p>
<a name="optimising, reset"></a>
<p>
This option will make GHC "forget" any -Oish options it has seen
so far.  Sometimes useful; for example: <tt>make all EXTRA_HC_OPTS=-Onot</tt>.
<p>
<dt><tt>-Ofile &lt;file&gt;</tt>:
<dd><a name="-Ofile <file> option"></a>
<p>
<a name="optimising, customised"></a>
<p>
For those who need <i>absolute</i> control over <i>exactly</i> what
options are used (e.g., compiler writers, sometimes :-), a list of
options can be put in a file and then slurped in with <tt>-Ofile</tt>.
<p>
In that file, comments are of the <tt>#</tt>-to-end-of-line variety; blank
lines and most whitespace is ignored.
<p>
Please ask if you are baffled and would like an example of <tt>-Ofile</tt>!
</dl>
<p>
At Glasgow, we don't use a <tt>-O*</tt> flag for day-to-day work.  We use
<tt>-O</tt> to get respectable speed; e.g., when we want to measure
something.  When we want to go for broke, we tend to use
<tt>-O -fvia-C -O2-for-C</tt> (and we go for lots of coffee breaks).
<p>
The easiest way to see what <tt>-O</tt> (etc) "really mean" is to run
with <tt>-v</tt>, then stand back in amazement.
Alternatively, just look at the
<tt>@HsC_minus&lt;blah&gt;</tt> lists in the <tt>ghc</tt> driver script.
<p>

<a name="-O options (GHC)"></a>
<a name="-O* not specified"></a>
<a name="-O option"></a>
<a name="-O1 option"></a>
<a name="optimise normally"></a>
<a name="-O2 option"></a>
<a name="optimise aggressively"></a>
<a name="-fvia-C option"></a>
<a name="-O2-for-C option"></a>
<a name="-Onot option"></a>
<a name="optimising, reset"></a>
<a name="-Ofile <file> option"></a>
<a name="optimising, customised"></a>
<a name="how_to_run_1.4.2"><h4><tt>-f*</tt>: platform-independent flags</h4></a>
<a name="-f* options (GHC)"></a>
<p>
<a name="-fno-* options (GHC)"></a>
<p>
Flags can be turned <i>off</i> individually.  (NB: I hope
you have a good reason for doing this....) To turn off the <tt>-ffoo</tt>
flag, just use the <tt>-fno-foo</tt> flag.<a name="-fno-<opt> anti-option"></a>
<p>
So, for example, you can say
<tt>-O2 -fno-strictness</tt>, which will then drop out any running of the
strictness analyser.
<p>
The options you are most likely to want to turn off are:
<tt>-fno-update-analysis</tt><a name="-fno-update-analysis option"></a>
 [because
it is sometimes slow],
<tt>-fno-strictness</tt><a name="-fno-strictness option"></a>
 (strictness
analyser [because it is sometimes slow]),
<tt>-fno-specialise</tt><a name="-fno-specialise option"></a>
 (automatic
specialisation of overloaded functions [because it makes your code
bigger]) [US spelling also accepted],
and
<tt>-fno-foldr-build</tt><a name="-fno-foldr-build option"></a>
 [because no-one
knows what Andy Gill made it do].
<p>
Should you wish to turn individual flags <i>on</i>, you are advised to
use the <tt>-Ofile</tt> option, described above.  Because the order in
which optimisation passes are run is sometimes crucial, it's quite
hard to do with command-line options.
<p>
Here are some "dangerous" optimisations you <i>might</i> want to try:
<dl>
<p>
<dt><tt>-funfolding-creation-threshold&lt;n&gt;</tt>:
<dd>(Default: 30) By raising or lowering this number, you can raise or lower the
amount of pragmatic junk that gets spewed into interface files.
(An unfolding has a "size" that reflects the cost in terms of "code
bloat" of expanding that unfolding in another module.  A bigger
Core expression would be assigned a bigger cost.)
<p>
<dt><tt>-funfolding-use-threshold&lt;n&gt;</tt>:
<dd>(Default: 3) By raising or lowering this number, you can make the
compiler more or less keen to expand unfoldings.
<p>
OK, folks, these magic numbers `30' and `3' are mildly arbitrary; they
are of the "seem to be OK" variety.  The `3' is the more critical
one; it's what determines how eager GHC is about expanding unfoldings.
<p>
<dt><tt>-funfolding-override-threshold&lt;n&gt;</tt>:
<dd>(Default: 8) [Pretty obscure]
When deciding what unfoldings from a module should be made available
to the rest of the world (via this module's interface), the compiler
normally likes "small" expressions.
<p>
For example, if it sees <tt>foo = bar</tt>, it will decide that the very
small expression <tt>bar</tt> is a great unfolding for <tt>foo</tt>.  But if
<tt>bar</tt> turns out to be <tt>(True,False,True)</tt>, we would probably
prefer <i>that</i> for the unfolding for <tt>foo</tt>.
<p>
Should we "override" the initial small unfolding from <tt>foo=bar</tt>
with the bigger-but-better one?  Yes, if the bigger one's "size" is
still under the "override threshold."  You can use this flag to
adjust this threshold (why, I'm not sure).
<p>
<dt><tt>-fliberated-case-threshold&lt;n&gt;</tt>:
<dd>(Default: 12) [Vastly obscure: NOT IMPLEMENTED YET]
"Case liberation" lifts evaluation out of recursive functions; it
does this by duplicating code.  Done without constraint, you can get
serious code bloat; so we only do it if the "size" of the duplicated
code is smaller than some "threshold."  This flag can fiddle that
threshold.
<p>
<dt><tt>-fsemi-tagging</tt>:
<dd>This option (which <i>does not work</i> with the native-code generator)
tells the compiler to add extra code to test for already-evaluated
values.  You win if you have lots of such values during a run of your
program, you lose otherwise.  (And you pay in extra code space.)
<p>
We have not played with <tt>-fsemi-tagging</tt> enough to recommend it.
(For all we know, it doesn't even work in 0.26.  Sigh.)
</dl>
<p>

<a name="-f* options (GHC)"></a>
<a name="-fno-* options (GHC)"></a>
<a name="-fno-<opt> anti-option"></a>
<a name="-fno-update-analysis option"></a>
<a name="-fno-strictness option"></a>
<a name="-fno-specialise option"></a>
<a name="-fno-foldr-build option"></a>
<a name="how_to_run_1.4.3"><h4><tt>-m*</tt>: platform-specific flags</h4></a>
<a name="-m* options (GHC)"></a>
<p>
<a name="platform-specific options"></a>
<p>
<a name="machine-specific options"></a>
<p>
Some flags only make sense for particular target platforms.
<p>
<dl>
<dt><tt>-mlong-calls</tt>:
<dd>(HPPA machines)<a name="-mlong-calls option (HPPA only)"></a>
<p>
Means to pass the like-named option to GCC.  Required for Very Big
modules, maybe.  (Probably means you're in trouble...)
<p>
<dt><tt>-monly-[432]-regs</tt>:
<dd>(iX86 machines)<a name="-monly-N-regs option (iX86 only)"></a>
<p>
GHC tries to "steal" five registers from GCC, for performance
reasons; it almost always works.  However, when GCC is compiling some
modules with five stolen registers, it will crash, probably saying:

<a name="-m* options (GHC)"></a>
<a name="platform-specific options"></a>
<a name="machine-specific options"></a>
<a name="-mlong-calls option (HPPA only)"></a>
<a name="-monly-N-regs option (iX86 only)"></a>
<pre>
Foo.hc:533: fixed or forbidden register was spilled.
This may be due to a compiler bug or to impossible asm
statements or clauses.
</pre><p>
Just give some registers back with <tt>-monly-N-regs</tt>.  Try `4' first,
then `3', then `2'.  If `2' doesn't work, please report the bug to us.
</dl>
<p>

<a name="optimise-C-compiler"><h4>Code improvement by the C compiler.</h4></a>
<a name="optimisation by GCC"></a>
<p>
<a name="GCC optimisation"></a>
<p>
The C compiler, normally GCC, is run with <tt>-O</tt> turned on.  (It has
to be, actually.)
<p>
If you want to run GCC with <tt>-O2</tt> -- which may be worth a few
percent in execution speed -- you can give a
<tt>-O2-for-C</tt><a name="-O2-for-C option"></a>
 option.
<p>

<a name="optimisation by GCC"></a>
<a name="GCC optimisation"></a>
<a name="-O2-for-C option"></a>
<a name="options-sanity"><h3>Sanity-checking options</h3></a>
<a name="sanity-checking options"></a>
<p>
If you would like GHC to check that every top-level value has a type
signature, use the <tt>-fsignatures-required</tt>
option.<a name="-fsignatures-required option"></a>
<p>
If you would like to disallow "name shadowing," i.e., an inner-scope
value has the same name as an outer-scope value, then use the
<tt>-fname-shadowing-not-ok</tt>
option.<a name="-fname-shadowing-not-ok option"></a>
<p>
This option catches typographical errors that turn into hard-to-find
bugs, e.g., in the inadvertent cyclic definition <tt>let x = ... x ... in</tt>.
<p>
Consequently, this option does <i>not</i> allow cyclic recursive
definitions.
<p>
If you're feeling really paranoid, the <tt>-dcore-lint</tt>
option<a name="-dcore-lint option"></a>
 is a good choice.  It turns on
heavyweight intra-pass sanity-checking within GHC.  (It checks GHC's
sanity, not yours.)
<p>

<a name="sanity-checking options"></a>
<a name="-fsignatures-required option"></a>
<a name="-fname-shadowing-not-ok option"></a>
<a name="-dcore-lint option"></a>
<a name="options-output"><h3>Re-directing the compilation output(s)</h3></a>
<a name="output-directing options"></a>
<p>
When compiling a Haskell module, GHC may produce several files of
output (usually two).
<p>
One file is usually an <i>interface file</i>.  If compiling
<tt>bar/Foo.hs</tt>, the interface file would normally be <tt>bar/Foo.hi</tt>.
The interface output may be directed to another file
<tt>bar2/Wurble.iface</tt> with the option
<tt>-ohi bar2/Wurble.iface</tt><a name="-ohi <file> option"></a>
.
<p>
To avoid generating an interface file at all, use a <tt>-nohi</tt>
option.<a name="-nohi option"></a>
<p>
The compiler does not overwrite an existing <tt>.hi</tt> interface file if
the new one is byte-for-byte the same as the old one; this is friendly to
<tt>make</tt>.  When an interface does change, it is often enlightening to
be informed.  The <tt>-hi-diffs</tt><a name="-hi-diffs option"></a>
 option will
make <tt>ghc</tt> run <tt>diff</tt> on the old and new <tt>.hi</tt> files.
<p>
GHC's non-interface output normally goes into a <tt>.hc</tt>, <tt>.o</tt>,
etc., file, depending on the last-run compilation phase.  The option
<tt>-o foo</tt><a name="-o option"></a>
 re-directs the output of that last-run
phase to file <tt>foo</tt>.
<p>
Note: this "feature" can be counterintuitive:
<tt>ghc -C -o foo.o foo.hs</tt> will put the intermediate C code in the
file <tt>foo.o</tt>, name notwithstanding!
<p>
EXOTICA: But the <tt>-o</tt> option isn't much use if you have <i>several</i> input files...  Non-interface output files are normally put
in the same directory as their corresponding input file came from.
You may specify that they be put in another directory using the
<tt>-odir &lt;dir&gt;</tt><a name="-odir <dir> option"></a>
 (the "Oh, dear" option).
For example:
<p>

<a name="output-directing options"></a>
<a name="-ohi <file> option"></a>
<a name="-nohi option"></a>
<a name="-hi-diffs option"></a>
<a name="-o option"></a>
<a name="-odir <dir> option"></a>
<pre>
% ghc -c parse/Foo.hs parse/Bar.hs gurgle/Bumble.hs -odir `arch`
</pre><p>

The output files, <tt>Foo.o</tt>, <tt>Bar.o</tt>, and <tt>Bumble.o</tt> would be
put into a subdirectory named after the architecture of the executing
machine (<tt>sun4</tt>, <tt>mips</tt>, etc).  The directory must already
exist; it won't be created.
<p>
Note that the <tt>-odir</tt> option does <i>not</i> affect where the
interface files are put.  In the above example, they would still be
put in <tt>parse/Foo.hi</tt>, <tt>parse/Bar.hi</tt>, and
<tt>gurgle/Bumble.hi</tt>.
<p>
MORE EXOTICA: The <tt>-osuf &lt;suffix&gt;</tt><a name="-osuf <suffix> option"></a>
<p>
will change the <tt>.o</tt> file suffix for object files to whatever
you specify.  (We use this in compiling the prelude.)
<p>
Similarly, the <tt>-hisuf &lt;suffix&gt;</tt><a name="-hisuf <suffix> option"></a>
 will
change the <tt>.hi</tt> file suffix for non-system interface files.  This
can be useful when you are trying to compile a program several ways,
all in the same directory.  The suffix given is used for <i>all</i>
interfaces files written, <i>and</i> for all non-system interface files
that your read.
<p>
The <tt>-hisuf</tt>/<tt>-osuf</tt> game is useful if you want to compile a
program with both GHC and HBC (say) in the same directory.  Let HBC
use the standard <tt>.hi</tt>/<tt>.o</tt> suffixes; add
<tt>-hisuf _g.hi -osuf _g.o</tt> to your <tt>make</tt> rule for GHC compiling...
<p>
FURTHER EXOTICA: If you are doing a normal <tt>.hs</tt>-to-<tt>.o</tt> compilation
but would like to hang onto the intermediate <tt>.hc</tt> C file, just
throw in a <tt>-keep-hc-file-too</tt> option<a name="-keep-hc-file-too option"></a>
.
If you would like to look at the assembler output, toss in a
<tt>-keep-s-file-too</tt>,<a name="-keep-hc-file-too option"></a>
 too.
<p>
SAVING GHC STDERR OUTPUT: Sometimes, you may cause GHC to be rather
chatty on standard error; with <tt>-fshow-import-specs</tt>, for example.
You can instruct GHC to <i>append</i> this output to a particular log
file with a <tt>-odump &lt;blah&gt;</tt><a name="-odump <blah> option"></a>
 option.
<p>
TEMPORARY FILES: If you have trouble because of running out of space
in <tt>/tmp/</tt> (or wherever your installation thinks temporary files
should go), you may use the <tt>-tmpdir &lt;dir&gt;</tt><a name="-tmpdir <dir> option"></a>
<p>
option to specify an alternate directory.  For example, <tt>-tmpdir .</tt>
says to put temporary files in the current working directory.
<p>
BETTER IDEA FOR TEMPORARY FILES: Use your <tt>TMPDIR</tt> environment
variable.<a name="TMPDIR environment variable"></a>
  Set it to the name of
the directory where temporary files should be put.  GCC and other
programs will honour the <tt>TMPDIR</tt> variable as well.
<p>
EVEN BETTER IDEA: Configure GHC with <tt>--with-tmpdir=&lt;mumble&gt;</tt> when
you build it, and never worry about <tt>TMPDIR</tt> again.
<p>

<a name="-osuf <suffix> option"></a>
<a name="-hisuf <suffix> option"></a>
<a name="-keep-hc-file-too option"></a>
<a name="-keep-hc-file-too option"></a>
<a name="-odump <blah> option"></a>
<a name="-tmpdir <dir> option"></a>
<a name="TMPDIR environment variable"></a>
<a name="options-finding-imports-etc"><h3>For finding interface files, etc.</h3></a>
<a name="interface files, finding them"></a>
<p>
<a name="finding interface files"></a>
<p>
In your program, you import a module <tt>Foo</tt> by saying
<tt>import Foo</tt>.  GHC goes looking for an interface file, <tt>Foo.hi</tt>.
It has a builtin list of directories (notably including <tt>.</tt>) where
it looks.
<p>
The <tt>-i&lt;dirs&gt;</tt> option<a name="-i<dirs> option"></a>
 prepends a
colon-separated list of <tt>dirs</tt> to the "import directories" list.
<p>
A plain <tt>-i</tt> resets the "import directories" list back to nothing.
<p>
GHC normally imports <tt>PreludeCore.hi</tt> and <tt>Prelude.hi</tt> files for
you.  If you'd rather it didn't, then give it a
<tt>-fno-implicit-prelude</tt> option<a name="-fno-implicit-prelude option"></a>
.
(Sadly, it still has to <i>find</i> a <tt>PreludeNull_.hi</tt> file; it
just won't feed it into the compiler proper.)  You are unlikely to get
very far without a Prelude, but, hey, it's a free country.
<p>
If you are using a system-supplied non-Prelude library (e.g., the HBC
library), just use a <tt>-syslib hbc</tt><a name="-syslib <lib> option"></a>
<p>
option (for example).  The right interface files should then be
available.
<p>
Once a Haskell module has been compiled to C (<tt>.hc</tt> file), you may
wish to specify where GHC tells the C compiler to look for <tt>.h</tt>
files.  (Or, if you are using the <tt>-cpp</tt> option<a name="-cpp option"></a>
,
where it tells the C pre-processor to look...)  For this purpose, use
a <tt>-I&lt;dir&gt;</tt><a name="-I<dir> option"></a>
 in the usual C-ish way.
<p>
Pragmas: Interface files are normally jammed full of
compiler-produced <i>pragmas</i>, which record arities, strictness
info, etc.  If you think these pragmas are messing you up (or you are
doing some kind of weird experiment), you can tell GHC to ignore them
with the <tt>-fignore-interface-pragmas</tt><a name="-fignore-interface-pragmas option"></a>
<p>
option.
<p>
See also chapter <a href="#options-linker">options-linker</a>, which describes how the linker
finds standard Haskell libraries.
<p>

<a name="interface files, finding them"></a>
<a name="finding interface files"></a>
<a name="-i<dirs> option"></a>
<a name="-fno-implicit-prelude option"></a>
<a name="-syslib <lib> option"></a>
<a name="-cpp option"></a>
<a name="-I<dir> option"></a>
<a name="-fignore-interface-pragmas option"></a>
<a name="options-CPP"><h3>Related to the C pre-processor</h3></a>
<a name="C pre-processor options"></a>
<p>
<a name="pre-processor (cpp) options"></a>
<p>
The C pre-processor <tt>cpp</tt> is run over your Haskell code only if the
<tt>-cpp</tt> option <a name="-cpp option"></a>
 is given.  Unless you are
building a large system with significant doses of conditional
compilation, you really shouldn't need it.
<dl>
<dt><tt>-D&lt;foo&gt;</tt>:
<dd><a name="-D<name> option"></a>
<p>
Define macro <tt>&lt;foo&gt;</tt> in the usual way.  NB: does <i>not</i> affect
<tt>-D</tt> macros passed to the C compiler when compiling via C!  For
those, use the <tt>-optc-Dfoo</tt> hack...
<p>
<dt><tt>-U&lt;foo&gt;</tt>:
<dd><a name="-U<name> option"></a>
<p>
Undefine macro <tt>&lt;foo&gt;</tt> in the usual way.
<p>
<dt><tt>-I&lt;dir&gt;</tt>:
<dd><a name="-I<dir> option"></a>
<p>
Specify a directory in which to look for <tt>#include</tt> files, in
the usual UNIX/C way.
</dl>
<p>
The <tt>ghc</tt> driver pre-defines several macros:
<dl>
<dt><tt>__HASKELL1__</tt>:
<dd><a name="__HASKELL1__ macro"></a>
<p>
If defined to n, that means GHC supports the
Haskell language defined in the Haskell report version 1.n.
Currently 2.
<p>
NB: This macro is set both when pre-processing Haskell source and
when pre-processing generated C (<tt>.hc</tt>) files.
<p>
If you give the <tt>-fhaskell-1.3</tt> flag<a name="-fhaskell-1.3 option"></a>
,
then <tt>__HASKELL1__</tt> is set to 3.  Obviously.
<p>
<dt><tt>__GLASGOW_HASKELL__</tt>:
<dd><a name="__GLASGOW_HASKELL__ macro"></a>
<p>
For version n of the GHC system, this will be <tt>#define</tt>d to
100 \times n.  So, for version 0.26, it is 26.
<p>
This macro is <i>only</i> set when pre-processing Haskell source.
(<i>Not</i> when pre-processing generated C.)
<p>
With any luck, <tt>__GLASGOW_HASKELL__</tt> will be undefined in all other
implementations that support C-style pre-processing.
<p>
(For reference: the comparable symbols for other systems are:
<tt>__YALE_HASKELL__</tt> for Yale Haskell, <tt>__HBC__</tt> for Chalmers
HBC, and <tt>__GOFER__</tt> for Gofer [I think].)
<p>
<dt><tt>__CONCURRENT_HASKELL__</tt>:
<dd><a name="__CONCURRENT_HASKELL__ macro"></a>
<p>
Only defined when <tt>-concurrent</tt> is in use!
This symbol is
defined when pre-processing Haskell (input) and pre-processing C (GHC
output).
<p>
<dt><tt>__PARALLEL_HASKELL__</tt>:
<dd><a name="__PARALLEL_HASKELL__ macro"></a>
<p>
Only defined when <tt>-parallel</tt> is in use!  This symbol is defined when
pre-processing Haskell (input) and pre-processing C (GHC output).
</dl>
<p>
Options other than the above can be forced through to the C
pre-processor with the <tt>-opt</tt> flags (see
section <a href="#forcing-options-through">forcing-options-through</a>).
<p>
A small word of warning: <tt>-cpp</tt> is not friendly to
"string gaps".<a name="-cpp vs string gaps"></a>
<a name="string gaps vs -cpp"></a>
<p>

<a name="C pre-processor options"></a>
<a name="pre-processor (cpp) options"></a>
<a name="-cpp option"></a>
<a name="-D<name> option"></a>
<a name="-U<name> option"></a>
<a name="-I<dir> option"></a>
<a name="__HASKELL1__ macro"></a>
<a name="-fhaskell-1.3 option"></a>
<a name="__GLASGOW_HASKELL__ macro"></a>
<a name="__CONCURRENT_HASKELL__ macro"></a>
<a name="__PARALLEL_HASKELL__ macro"></a>
<a name="-cpp vs string gaps"></a>
<a name="string gaps vs -cpp"></a>
<a name="options-C-compiler"><h3>Options affecting the C compiler (if applicable)</h3></a>
<a name="C compiler options"></a>
<p>
<a name="GCC options"></a>
<p>
At the moment, quite a few common C-compiler options are passed on
quietly to the C compilation of Haskell-compiler-generated C files.
THIS MAY CHANGE.  Meanwhile, options so sent are:
<p>

<a name="C compiler options"></a>
<a name="GCC options"></a>
<pre>
phase of the                     suffix saying  flag saying   (suffix of)  
compilation system               "start here"   "stop after"  output file  
\hline<p>literate pre-processor  .lhs           -             -            
C pre-processor (opt.)           -              -             -            
Haskell parser                   .hs            -             -            
Haskell compiler                 -              -C, -S        .hc, .s      
C compiler (opt.)                .hc or .c      -S            .s           
assembler                        .s             -c            .o           
linker                           other          -             a.out        
<tt>-Wall</tt>       get all warnings from GCC                  
<tt>-ansi</tt>       do ANSI C (not K\&R)                       
<tt>-pedantic</tt>   be so                                      
<tt>-dgcc-lint</tt>  (hack) short for "make GCC very paranoid"  
</pre>

<a name="-Wall option (for GCC)"></a>
<p>
<a name="-ansi option (for GCC)"></a>
<p>
<a name="-pedantic option (for GCC)"></a>
<p>
<a name="-dgcc-lint option (GCC paranoia)"></a>
<p>
If you are compiling with lots of <tt>ccalls</tt>, etc., you may need to
tell the C compiler about some <tt>#include</tt> files.  There is no
pretty way to do this, but you can use this hack from the
command-line:

<a name="-Wall option (for GCC)"></a>
<a name="-ansi option (for GCC)"></a>
<a name="-pedantic option (for GCC)"></a>
<a name="-dgcc-lint option (GCC paranoia)"></a>
<pre>
% ghc -c '-#include &lt;X/Xlib.h&gt;' Xstuff.lhs
</pre><p>
<a name="-#include <file> option"></a>
<p>

<a name="-#include <file> option"></a>
<a name="options-linker"><h3>Linking and consistency-checking</h3></a>
<a name="linker options"></a>
<p>
<a name="ld options"></a>
<p>
GHC has to link your code with various libraries, possibly including:
user-supplied, GHC-supplied, and system-supplied (<tt>-lm</tt> math
library, for example).
<p>
<dl>
<dt><tt>-l&lt;FOO&gt;</tt>:
<dd><a name="-l<lib> option"></a>
<p>
Link in a library named <tt>lib&lt;FOO&gt;.a</tt> which resides somewhere on the
library directories path.
<p>
Because of the sad state of most UNIX linkers, the order of such
options does matter.  Thus: <tt>ghc -lbar *.o</tt> is almost certainly
wrong, because it will search <tt>libbar.a</tt> <i>before</i> it has
collected unresolved symbols from the <tt>*.o</tt> files.
<tt>ghc *.o -lbar</tt> is probably better.
<p>
The linker will of course be informed about some GHC-supplied
libraries automatically; these are:
<p>

<a name="linker options"></a>
<a name="ld options"></a>
<a name="-l<lib> option"></a>
<pre>
phase of the                     suffix saying  flag saying   (suffix of)  
compilation system               "start here"   "stop after"  output file  
\hline<p>literate pre-processor  .lhs           -             -            
C pre-processor (opt.)           -              -             -            
Haskell parser                   .hs            -             -            
Haskell compiler                 -              -C, -S        .hc, .s      
C compiler (opt.)                .hc or .c      -S            .s           
assembler                        .s             -c            .o           
linker                           other          -             a.out        
<tt>-Wall</tt>       get all warnings from GCC                  
<tt>-ansi</tt>       do ANSI C (not K\&R)                       
<tt>-pedantic</tt>   be so                                      
<tt>-dgcc-lint</tt>  (hack) short for "make GCC very paranoid"  
-l equivalent              description                                 
\hline<p>-lHSrts,-lHSclib  basic runtime libraries                     
-lHS                       standard Prelude library                    
-lgmp                      GNU multi-precision library (for Integers)  
</pre>

<a name="-lHS library"></a>
<p>
<a name="-lHSrts library"></a>
<p>
<a name="-lgmp library"></a>
<p>
<dt><tt>-syslib &lt;name&gt;</tt>:
<dd><a name="-syslib <name> option"></a>
<p>
If you are using an optional GHC-supplied library (e.g., the HBC
library), just use the <tt>-syslib hbc</tt> option, and the correct code
should be linked in.
<p>
Please see part <a href="#syslibs">syslibs</a> for information about optional
GHC-supplied libraries.
<p>
<dt><tt>-L&lt;dir&gt;</tt>:
<dd><a name="-L<dir> option"></a>
<p>
Where to find user-supplied libraries...  Prepend the directory
<tt>&lt;dir&gt;</tt> to the library directories path.
<p>
<dt><tt>-static</tt>:
<dd><a name="-static option"></a>
<p>
Tell the linker to avoid shared libraries.
<p>
<dt><tt>-no-link-chk</tt> and <tt>-link-chk</tt>:
<dd><a name="-no-link-chk option"></a>
<p>
<a name="-link-chk option"></a>
<p>
<a name="consistency checking of executables"></a>
<p>
By default, immediately after linking an executable, GHC verifies that
the pieces that went into it were compiled with compatible flags; a
"consistency check".
(This is to avoid mysterious failures caused by non-meshing of
incompatibly-compiled programs; e.g., if one <tt>.o</tt> file was compiled
for a parallel machine and the others weren't.)  You may turn off this
check with <tt>-no-link-chk</tt>.  You can turn it (back) on with
<tt>-link-chk</tt> (the default).
</dl>
<p>

<a name="-lHS library"></a>
<a name="-lHSrts library"></a>
<a name="-lgmp library"></a>
<a name="-syslib <name> option"></a>
<a name="-L<dir> option"></a>
<a name="-static option"></a>
<a name="-no-link-chk option"></a>
<a name="-link-chk option"></a>
<a name="consistency checking of executables"></a>
<a name="options-compiler-RTS"><h3>For the compiler's RTS: heap, stack sizes, etc.</h3></a>
<a name="heap-size options (for GHC)"></a>
<p>
<a name="stack-size options (for GHC)"></a>
<p>
The compiler is itself a Haskell program, so it has a tweakable
runtime-system (RTS), just like any other Haskell program.
<p>
<dl>
<dt><tt>-H&lt;size&gt;</tt> or <tt>-Rmax-heapsize &lt;size&gt;</tt>:
<dd><a name="-H<size> option"></a>
<p>
<a name="-Rmax-heapsize <size> option"></a>
<p>
Don't use more than <tt>&lt;size&gt;</tt> <i>bytes</i> for heap space.  If more
than one of these arguments is given, the largest will be taken.
<p>
A size of zero can be used to reset the heap size downwards.  For
example, to run GHC with a heap of 250KB (the default is 6MB), do
<tt>-H0 -H250k</tt>.
<p>
<dt><tt>-K&lt;size&gt;</tt> or <tt>-Rmax-stksize &lt;size&gt;</tt>:
<dd><a name="-K<size> option"></a>
<p>
<a name="-Rmax-stksize <size> option"></a>
<p>
Set the stack space to <tt>&lt;size&gt;</tt> bytes.  If you have to set it very
high [a megabyte or two, say], the compiler is probably looping, which
is a BUG (please report).
<p>
A size of zero can be used to rest the stack size downwards, as above.
<p>
<dt><tt>-Rscale-sizes&lt;factor&gt;</tt>:
<dd><a name="-Rscale-sizes<factor> option"></a>
<p>
Multiply the given (or default) heap and stack sizes by <tt>&lt;factor&gt;</tt>.
For example, on a DEC Alpha (a 64-bit machine), you might want to
double those space sizes; just use <tt>-Rscale-sizes2</tt>.
<p>
A non-integral factor is OK, too: <tt>-Rscale-sizes1.2</tt>.
<p>
<dt><tt>-Rghc-timing</tt>:
<dd><a name="-Rghc-timing option"></a>
<p>
Reports a one-line useful collection of time- and space- statistics
for a module's compilation.
<p>
<dt><tt>-Rgc-stats</tt>:
<dd><a name="-Rgc-stats option"></a>
<p>
Report garbage-collection statistics.  It will create a
<tt>&lt;foo&gt;.stat</tt> file, in some obvious place (I hope).
<p>
Alternatively, if you'd rather the GC stats went straight to standard
error, you can "cheat" by using, instead: <tt>-optCrts-Sstderr</tt>.
<p>
<dt><tt>-Rhbc</tt>:
<dd><a name="-Rhbc option"></a>
<p>
Tell the compiler it has an HBC-style RTS; i.e., it was compiled with
HBC.  Not used in Real Life.
<p>
<dt><tt>-Rghc</tt>:
<dd><a name="-Rghc option"></a>
<p>
Tell the compiler it has a GHC-style RTS; i.e., it was compiled with
GHC.  Not used in Real Life.
</dl>
<p>
For all <tt>&lt;size&gt;</tt>s: If the last character of <tt>size</tt> is a K,
multiply by 1000; if an M, by 1,000,000; if a G, by 1,000,000,000.
Sizes are always in <i>bytes</i>, not words.  Good luck on the G's (I
think the counter is still only 32-bits [WDP])!
<p>

<a name="heap-size options (for GHC)"></a>
<a name="stack-size options (for GHC)"></a>
<a name="-H<size> option"></a>
<a name="-Rmax-heapsize <size> option"></a>
<a name="-K<size> option"></a>
<a name="-Rmax-stksize <size> option"></a>
<a name="-Rscale-sizes<factor> option"></a>
<a name="-Rghc-timing option"></a>
<a name="-Rgc-stats option"></a>
<a name="-Rhbc option"></a>
<a name="-Rghc option"></a>
<a name="options-parallel"><h3>For Concurrent and Parallel Haskell</h3></a>

<p>
For the full story on using GHC for concurrent \& parallel Haskell
programming, please see Part <a href="#concurrent-and-parallel">concurrent-and-parallel</a>.
<p>

<a name="options-experimental"><h3>For experimental purposes</h3></a>
<a name="experimental options"></a>
<p>
From time to time, we provide GHC options for "experimenting."  Easy
come, easy go.  In version 0.26, the "experimental" options are:
<dl>
<dt><tt>-firrefutable-tuples</tt> option:
<dd><a name="-firrefutable-tuples option (experimental)"></a>
<p>
Pretend that every tuple pattern is irrefutable; i.e., has a
"twiddle" (<tt> </tt>) in front of it.
<p>
Some parts of the GHC system <i>depend</i> on strictness properties which
<tt>-firrefutable-tuples</tt> may undo, notably the low-level state-transformer
stuff, which includes I/O (!).  You're on your own...
<p>
<dt><tt>-fall-strict</tt> option:
<dd><a name="-fall-strict option (experimental)"></a>
<p>
(DOESN'T REALLY WORK, I THINK) Changes the strictness analyser so
that, when it asks the question "Is this function argument certain to
be evaluated?", the answer is always "yes".
<p>
Compilation is changed in no other way.
</dl>
<p>

<a name="experimental options"></a>
<a name="-firrefutable-tuples option (experimental)"></a>
<a name="-fall-strict option (experimental)"></a>
<a name="options-debugging"><h3>For debugging the compiler</h3></a>
<a name="debugging options (for GHC)"></a>
<p>
HACKER TERRITORY. HACKER TERRITORY.
(You were warned.)
<p>

<a name="debugging options (for GHC)"></a>
<a name="replacing-phases"><h4>Replacing the program for one or more phases.</h4></a>
<a name="GHC phases, changing"></a>
<p>
<a name="phases, changing GHC"></a>
<p>
You may specify that a different program
be used for one of the phases of the compilation system, in place of
whatever the driver <tt>ghc</tt> has wired into it.  For example, you
might want to test a replacement parser.  The
<tt>-pgm&lt;phase-code&gt;&lt;program-name&gt;</tt><a name="-pgm<phase><stuff> option"></a>
 option to
<tt>ghc</tt> will cause it to use &lt;program-name&gt; for phase
&lt;phase-code&gt;, where the codes to indicate the phases are:
<p>

<a name="GHC phases, changing"></a>
<a name="phases, changing GHC"></a>
<a name="-pgm<phase><stuff> option"></a>
<pre>
phase of the                     suffix saying  flag saying   (suffix of)  
compilation system               "start here"   "stop after"  output file  
\hline<p>literate pre-processor  .lhs           -             -            
C pre-processor (opt.)           -              -             -            
Haskell parser                   .hs            -             -            
Haskell compiler                 -              -C, -S        .hc, .s      
C compiler (opt.)                .hc or .c      -S            .s           
assembler                        .s             -c            .o           
linker                           other          -             a.out        
<tt>-Wall</tt>       get all warnings from GCC                  
<tt>-ansi</tt>       do ANSI C (not K\&R)                       
<tt>-pedantic</tt>   be so                                      
<tt>-dgcc-lint</tt>  (hack) short for "make GCC very paranoid"  
-l equivalent              description                                 
\hline<p>-lHSrts,-lHSclib  basic runtime libraries                     
-lHS                       standard Prelude library                    
-lgmp                      GNU multi-precision library (for Integers)  
code     phase                                          
\hlineL  literate pre-processor                         
P        C pre-processor (if -cpp only)                 
p        parser                                         
C        Haskell compiler                               
cO       C compiler for `optimised' (normal) compiling  
c        C compiler for `unregisterised' compiling      
a        assembler                                      
l        linker                                         
</pre>


If you use the ambiguous <tt>-pgmcOle</tt>, it will take it to mean
"use program <tt>le</tt> for optimised C compiling."
<p>

<a name="forcing-options-through"><h4>Forcing options to a particular phase.</h4></a>
<a name="forcing GHC-phase options"></a>
<p>
The preceding sections describe driver options that are mostly
applicable to one particular phase.  You may also <i>force</i> a
specific option <tt>&lt;option&gt;</tt> to be passed to a particular phase
<tt>&lt;phase-code&gt;</tt> by feeding the driver the option
<tt>-opt&lt;phase-code&gt;&lt;option&gt;</tt>.<a name="-opt<phase><stuff> option"></a>
 The
codes to indicate the phases are the same as in the previous section.
<p>
So, for example, to force an <tt>-Ewurble</tt> option to the assembler, you
would tell the driver <tt>-opta-Ewurble</tt> (the dash before the E is
required).
<p>
Besides getting options to the Haskell compiler with <tt>-optC&lt;blah&gt;</tt>,
you can get options through to its runtime system with
<tt>-optCrts&lt;blah&gt;</tt><a name="-optCrts<blah> option"></a>
.
<p>
So, for example: when I want to use my normal driver but with my
profiled compiler binary, I use this script:

<a name="forcing GHC-phase options"></a>
<a name="-opt<phase><stuff> option"></a>
<a name="-optCrts<blah> option"></a>
<pre>
#! /bin/sh
exec /local/grasp_tmp3/partain/ghc-BUILDS/working-alpha/ghc/driver/ghc \
     -pgmC/local/grasp_tmp3/partain/ghc-BUILDS/working-hsc-prof/hsc \
     -optCrts-i0.5 \
     -optCrts-PT \
     "$@"
</pre><p>

<p>

<a name="dumping-output"><h4>Dumping out compiler intermediate structures</h4></a>
<a name="dumping GHC intermediates"></a>
<p>
<a name="intermediate passes, output"></a>
<p>
<dl>
<dt><tt>-noC</tt>:
<dd><a name="-noC option"></a>
<p>
Don't bother generating C output <i>or</i> an interface file.  Usually
used in conjunction with one or more of the <tt>-ddump-*</tt> options; for
example: <tt>ghc -noC -ddump-simpl Foo.hs</tt>
<p>
<dt><tt>-hi</tt>:
<dd><a name="-hi option"></a>
<p>
<i>Do</i> generate an interface file.  This would normally be used in
conjunction with <tt>-noC</tt>, which turns off interface generation;
thus: <tt>-noC -hi</tt>.
<p>
<dt><tt>-ddump-parser</tt>:
<dd><a name="-ddump-parser option"></a>
<p>
This debugging option shows the exact prefix-form Haskell that is fed
into the Haskell compiler proper.
<p>
<dt><tt>-ddump-&lt;pass&gt;</tt>:
<dd><a name="-ddump-<pass> options"></a>
<p>
Make a debugging dump after pass <tt>&lt;pass&gt;</tt> (may be common enough to
need a short form...).  Some of the most useful ones are:
<p>

<a name="dumping GHC intermediates"></a>
<a name="intermediate passes, output"></a>
<a name="-noC option"></a>
<a name="-hi option"></a>
<a name="-ddump-parser option"></a>
<a name="-ddump-<pass> options"></a>
<pre>
phase of the                     suffix saying  flag saying   (suffix of)  
compilation system               "start here"   "stop after"  output file  
\hline<p>literate pre-processor  .lhs           -             -            
C pre-processor (opt.)           -              -             -            
Haskell parser                   .hs            -             -            
Haskell compiler                 -              -C, -S        .hc, .s      
C compiler (opt.)                .hc or .c      -S            .s           
assembler                        .s             -c            .o           
linker                           other          -             a.out        
<tt>-Wall</tt>       get all warnings from GCC                  
<tt>-ansi</tt>       do ANSI C (not K\&R)                       
<tt>-pedantic</tt>   be so                                      
<tt>-dgcc-lint</tt>  (hack) short for "make GCC very paranoid"  
-l equivalent              description                                 
\hline<p>-lHSrts,-lHSclib  basic runtime libraries                     
-lHS                       standard Prelude library                    
-lgmp                      GNU multi-precision library (for Integers)  
code     phase                                          
\hlineL  literate pre-processor                         
P        C pre-processor (if -cpp only)                 
p        parser                                         
C        Haskell compiler                               
cO       C compiler for `optimised' (normal) compiling  
c        C compiler for `unregisterised' compiling      
a        assembler                                      
l        linker                                         
<tt>-ddump-rif2hs</tt>      reader output (earliest stuff in the compiler)    
<tt>-ddump-rn4</tt>         renamer output                                    
<tt>-ddump-tc</tt>          typechecker output                                
<tt>-ddump-deriv</tt>       derived instances                                 
<tt>-ddump-ds</tt>          desugarer output                                  
<tt>-ddump-simpl</tt>       simplifer output (Core-to-Core passes)            
                            (and don't forget <tt>-O</tt>, too!)              
<tt>-ddump-stranal</tt>     strictness analyser output                        
                            (only works in conjunction with -ddump-simpl)     
<tt>-ddump-occur-anal</tt>  `occurrence analysis' output                      
                            (only works in conjunction with -ddump-simpl)     
<tt>-ddump-spec</tt>        dump specialisation info                          
<tt>-ddump-stg</tt>         output of STG-to-STG passes                       
<tt>-ddump-absC</tt>        <i>un</i>flattened Abstract C                     
<tt>-ddump-flatC</tt>       <i>flattened</i> Abstract C                       
<tt>-ddump-realC</tt>       same as what goes to the C compiler               
<tt>-ddump-asm</tt>         assembly language from the native-code generator  
</pre>

<a name="-ddump-rif2hs option"></a>
<p>
<a name="-ddump-rn4 option"></a>
<p>
<a name="-ddump-tc option"></a>
<p>
<a name="-ddump-deriv option"></a>
<p>
<a name="-ddump-ds option"></a>
<p>
<a name="-ddump-simpl option"></a>
<p>
<a name="-ddump-stranal option"></a>
<p>
<a name="-ddump-occur-anal option"></a>
<p>
<a name="-ddump-spec option"></a>
<p>
<a name="-ddump-stg option"></a>
<p>
<a name="-ddump-absC option"></a>
<p>
<a name="-ddump-flatC option"></a>
<p>
<a name="-ddump-realC option"></a>
<p>
<a name="-ddump-asm option"></a>
<p>
<dt><tt>-dverbose-simpl</tt> and <tt>-dverbose-stg</tt>:
<dd><a name="-dverbose-simpl option"></a>
<p>
<a name="-dverbose-stg option"></a>
<p>
Show the output of the intermediate Core-to-Core and STG-to-STG
passes, respectively.  (<i>Lots</i> of output!) So: when we're 
really desperate:

<a name="-ddump-rif2hs option"></a>
<a name="-ddump-rn4 option"></a>
<a name="-ddump-tc option"></a>
<a name="-ddump-deriv option"></a>
<a name="-ddump-ds option"></a>
<a name="-ddump-simpl option"></a>
<a name="-ddump-stranal option"></a>
<a name="-ddump-occur-anal option"></a>
<a name="-ddump-spec option"></a>
<a name="-ddump-stg option"></a>
<a name="-ddump-absC option"></a>
<a name="-ddump-flatC option"></a>
<a name="-ddump-realC option"></a>
<a name="-ddump-asm option"></a>
<a name="-dverbose-simpl option"></a>
<a name="-dverbose-stg option"></a>
<pre>
% ghc -noC -O -ddump-simpl -dverbose-simpl -dcore-lint Foo.hs
</pre><p>

<dt><tt>-dppr-\{user,debug,all\}</tt>:
<dd><a name="-dppr-user option"></a>
<p>
<a name="-dppr-debug option"></a>
<p>
<a name="-dppr-all option"></a>
<p>
Debugging output is in one of several "styles."  Take the printing
of types, for example.  In the "user" style, the compiler's internal
ideas about types are presented in Haskell source-level syntax,
insofar as possible.  In the "debug" style (which is the default for
debugging output), the types are printed in the most-often-desired
form, with explicit foralls, etc.  In the "show all" style, very
verbose information about the types (e.g., the Uniques on the
individual type variables) is displayed.
<p>
<dt><tt>-ddump-raw-asm</tt>:
<dd><a name="-ddump-raw-asm option"></a>
<p>
Dump out the assembly-language stuff, before the "mangler" gets it.
<p>
<dt><tt>-dgc-debug</tt>:
<dd><a name="-dgc-debug option"></a>
<p>
Enables some debugging code related to the garbage-collector.
</dl>
<p>

<a name="-dppr-user option"></a>
<a name="-dppr-debug option"></a>
<a name="-dppr-all option"></a>
<a name="-ddump-raw-asm option"></a>
<a name="-dgc-debug option"></a>
<a name="how_to_run_1.14.4"><h4>How to read Core syntax (from some <tt>-ddump-*</tt> flags)</h4></a>
<a name="reading Core syntax"></a>
<p>
<a name="Core syntax, how to read"></a>
<p>
Let's do this by commenting an example.  It's from doing
<tt>-ddump-ds</tt> on this code:

<a name="reading Core syntax"></a>
<a name="Core syntax, how to read"></a>
<pre>
skip2 m = m : skip2 (m+2)
</pre><p>

Before we jump in, a word about names of things.  Within GHC,
variables, type constructors, etc., are identified by their
"Uniques."  These are of the form `letter' plus `number' (both
loosely interpreted).  The `letter' gives some idea of where the
Unique came from; e.g., <tt>_</tt> means "built-in type variable";
<tt>t</tt> means "from the typechecker"; <tt>s</tt> means "from the
simplifier"; and so on.  The `number' is printed fairly compactly in
a `base-62' format, which everyone hates except me (WDP).
<p>
Remember, everything has a "Unique" and it is usually printed out
when debugging, in some form or another.  So here we go...
<p>

<pre>
Desugared:
Main.skip2{-r1L6-} :: _forall_ a$_4 =&gt;{{Num a$_4}} -&gt; a$_4 -&gt; [a$_4]

--# `r1L6' is the Unique for Main.skip2;
--# `_4' is the Unique for the type-variable (template) `a'
--# `{{Num a$_4}}' is a dictionary argument

_NI_

--# `_NI_' means "no (pragmatic) information" yet; it will later
--# evolve into the GHC_PRAGMA info that goes into interface files.

Main.skip2{-r1L6-} =
    /\ _4 -&gt; \ d.Num.t4Gt -&gt;
        let {
          {- CoRec -}
          +.t4Hg :: _4 -&gt; _4 -&gt; _4
          _NI_
          +.t4Hg = (+{-r3JH-} _4) d.Num.t4Gt

          fromInt.t4GS :: Int{-2i-} -&gt; _4
          _NI_
          fromInt.t4GS = (fromInt{-r3JX-} _4) d.Num.t4Gt

--# The `+' class method (Unique: r3JH) selects the addition code
--# from a `Num' dictionary (now an explicit lamba'd argument).
--# Because Core is 2nd-order lambda-calculus, type applications
--# and lambdas (/\) are explicit.  So `+' is first applied to a
--# type (`_4'), then to a dictionary, yielding the actual addition
--# function that we will use subsequently...

--# We play the exact same game with the (non-standard) class method
--# `fromInt'.  Unsurprisingly, the type `Int' is wired into the
--# compiler.

          lit.t4Hb :: _4
          _NI_
          lit.t4Hb =
              let {
                ds.d4Qz :: Int{-2i-}
                _NI_
                ds.d4Qz = I#! 2#
              } in  fromInt.t4GS ds.d4Qz

--# `I# 2#' is just the literal Int `2'; it reflects the fact that
--# GHC defines `data Int = I# Int#', where Int# is the primitive
--# unboxed type.  (see relevant info about unboxed types elsewhere...)

--# The `!' after `I#' indicates that this is a *saturated*
--# application of the `I#' data constructor (i.e., not partially
--# applied).

          skip2.t3Ja :: _4 -&gt; [_4]
          _NI_
          skip2.t3Ja =
              \ m.r1H4 -&gt;
                  let { ds.d4QQ :: [_4]
                        _NI_
                        ds.d4QQ =
                    let {
                      ds.d4QY :: _4
                      _NI_
                      ds.d4QY = +.t4Hg m.r1H4 lit.t4Hb
                    } in  skip2.t3Ja ds.d4QY
                  } in
                  :! _4 m.r1H4 ds.d4QQ

          {- end CoRec -}
        } in  skip2.t3Ja
</pre><p>

("It's just a simple functional language" is an unregisterised
trademark of Peyton Jones Enterprises, plc.)
<p>

<a name="arity-checking"><h4>Options to insert arity-checking code</h4></a>
<a name="arity checking"></a>
<p>
The <tt>-darity-checks</tt><a name="-darity-checks option"></a>
 option inserts
code to check for arity violations.  Unfortunately, it's not that
simple: you have to link with a prelude that was also built with arity
checks.  If you have one, then great; otherwise...
<p>
The <tt>-darity-checks-C-only</tt><a name="-darity-checks-C-only option"></a>
<p>
option inserts the self-same arity checking code into <tt>.hc</tt> files,
but doesn't compile it into the <tt>.o</tt> files.  We use this flag with
the <tt>-keep-hc-file-too</tt><a name="-keep-hc-file-too option"></a>
, where we
are keeping <tt>.hc</tt> files around for debugging purposes.
<p>

<a name="arity checking"></a>
<a name="-darity-checks option"></a>
<a name="-darity-checks-C-only option"></a>
<a name="-keep-hc-file-too option"></a>
<a name="omit-checking"><h4>Options to omit checking code</h4></a>
<a name="omitting runtime checks"></a>
<p>
By default, the GHC system emits all possible not-too-expensive
runtime checking code.  If you are brave or experimenting, you might
want to turn off some of this (not recommended):
<p>

<a name="omitting runtime checks"></a>
<pre>
phase of the                     suffix saying  flag saying   (suffix of)  
compilation system               "start here"   "stop after"  output file  
\hline<p>literate pre-processor  .lhs           -             -            
C pre-processor (opt.)           -              -             -            
Haskell parser                   .hs            -             -            
Haskell compiler                 -              -C, -S        .hc, .s      
C compiler (opt.)                .hc or .c      -S            .s           
assembler                        .s             -c            .o           
linker                           other          -             a.out        
<tt>-Wall</tt>       get all warnings from GCC                  
<tt>-ansi</tt>       do ANSI C (not K\&R)                       
<tt>-pedantic</tt>   be so                                      
<tt>-dgcc-lint</tt>  (hack) short for "make GCC very paranoid"  
-l equivalent              description                                 
\hline<p>-lHSrts,-lHSclib  basic runtime libraries                     
-lHS                       standard Prelude library                    
-lgmp                      GNU multi-precision library (for Integers)  
code     phase                                          
\hlineL  literate pre-processor                         
P        C pre-processor (if -cpp only)                 
p        parser                                         
C        Haskell compiler                               
cO       C compiler for `optimised' (normal) compiling  
c        C compiler for `unregisterised' compiling      
a        assembler                                      
l        linker                                         
<tt>-ddump-rif2hs</tt>      reader output (earliest stuff in the compiler)    
<tt>-ddump-rn4</tt>         renamer output                                    
<tt>-ddump-tc</tt>          typechecker output                                
<tt>-ddump-deriv</tt>       derived instances                                 
<tt>-ddump-ds</tt>          desugarer output                                  
<tt>-ddump-simpl</tt>       simplifer output (Core-to-Core passes)            
                            (and don't forget <tt>-O</tt>, too!)              
<tt>-ddump-stranal</tt>     strictness analyser output                        
                            (only works in conjunction with -ddump-simpl)     
<tt>-ddump-occur-anal</tt>  `occurrence analysis' output                      
                            (only works in conjunction with -ddump-simpl)     
<tt>-ddump-spec</tt>        dump specialisation info                          
<tt>-ddump-stg</tt>         output of STG-to-STG passes                       
<tt>-ddump-absC</tt>        <i>un</i>flattened Abstract C                     
<tt>-ddump-flatC</tt>       <i>flattened</i> Abstract C                       
<tt>-ddump-realC</tt>       same as what goes to the C compiler               
<tt>-ddump-asm</tt>         assembly language from the native-code generator  
-dno-black-holing  won't buy you much (even if it works)  
-dno-updates       you're crazy if you do this            
-dno-stk-stubbing  omit stack stubbing (NOT DONE YET)     
</pre>

<a name="-dno-black-holing option"></a>
<p>
<a name="-dno-updates option"></a>
<p>
<a name="-dno-stk-stubbing option"></a>
<p>
Warning: all very lightly tested, if at all...
<p>

<a name="-dno-black-holing option"></a>
<a name="-dno-updates option"></a>
<a name="-dno-stk-stubbing option"></a>




<p>

<a name="runtime-control"><h2>Controlling the run-time behaviour of your programs</h2></a>
<a name="runtime control of Haskell programs"></a>
<p>
<a name="RTS options"></a>
<p>
To make an executable program, the GHC system compiles your code and
then links it with a non-trivial runtime system (RTS), which handles
storage management, profiling, etc.
<p>
You have some control over the behaviour of the RTS, by giving special
command-line arguments to your program.
<p>
When your Haskell program starts up, its RTS extracts
command-line arguments bracketed between <tt>+RTS</tt><a name="+RTS option"></a>
<p>
and <tt>-RTS</tt><a name="-RTS option"></a>
 as its own.  For example:

<a name="runtime control of Haskell programs"></a>
<a name="RTS options"></a>
<a name="+RTS option"></a>
<a name="-RTS option"></a>
<pre>
% ./a.out -f +RTS -p -S -RTS -h foo bar
</pre><p>
The RTS will snaffle <tt>-p -S</tt> for itself,
and the remaining arguments <tt>-f -h foo bar</tt> will be handed
to your program when it does a <a href="#GetArgs"><tt>GetArgs</tt></a> I/O request.
<p>
No <tt>-RTS</tt> option is required if the runtime-system options extend
to the end of the command line, as in this example:

<pre>
% hls -ltr /usr/etc +RTS -H5m
</pre><p>
If you absolutely positively want all the rest of the options in a
command line to go to the program (and not the RTS), use a
<tt>--RTS</tt><a name="--RTS option"></a>
.
<p>
As always, for RTS options that take <tt>&lt;size&gt;</tt>s: If the last
character of <tt>size</tt> is a K or k, multiply by 1000; if an M or m, by
1,000,000; if a G or G, by 1,000,000,000.  (And any wraparound in the
counters is <i>your</i> fault!)
<p>
Giving a <tt>+RTS -f</tt><a name="-f RTS option"></a>
 option will print out the
RTS options actually available in your program (which vary, depending
on how you compiled).
<p>

<a name="--RTS option"></a>
<a name="-f RTS option"></a>
<a name="runtime_control_1.1"><h3>Generally-available RTS options</h3></a>
<a name="RTS options, general"></a>
<p>
The most important RTS options are:
<dl>
<dt><tt>-H&lt;size&gt;</tt>:
<dd><a name="-H<size> RTS option"></a>
<p>
Set the heap size to &lt;size&gt; bytes
[default: 4M].
<p>
<dt><tt>-K&lt;size&gt;</tt>:
<dd><a name="-K<size> RTS option"></a>
<p>
Set the stack size to &lt;size&gt; bytes [default: 64K].
For concurrent/parallel programs, it is the stack size of the main
thread; generally speaking, c/p stacks are in heap.
<p>
Note: if your program seems to be consuming infinite stack space, it
is probably in a loop :-) Of course, if stacks are in the heap, make
that infinite <i>heap</i> space...
<p>
<dt><tt>-s&lt;file&gt;</tt> or <tt>-S&lt;file&gt;</tt>:
<dd><a name="-S<file> RTS option"></a>
<p>
<a name="-s<file> RTS option"></a>
<p>
Write modest (<tt>-s</tt>) or verbose (<tt>-S</tt>) garbage-collector
statistics into file &lt;file&gt;. The default &lt;file&gt; is
&lt;program&gt;<tt>.stat</tt>. The &lt;file&gt; <tt>stderr</tt> is treated
specially, with the output really being sent to <tt>stderr</tt>.
<p>
The amount of heap allocation will typically increase as the total heap
size is reduced.  The reason for this odd behaviour is that updates of
promoted-to-old-generation objects may require the extra allocation of a new-generation
object to ensure that there are never any pointers from the old
generation to the new generation.
<p>
For some garbage collectors (not including the default one, sadly),
you can convert the <tt>-S</tt> output into a residency graph (in
PostScript), using the <tt>stat2resid</tt><a name="stat2resid"></a>
 utility in
the GHC distribution (<tt>ghc/utils/stat2resid</tt>).
<p>
<dt><tt>-N</tt>:
<dd><a name="-N RTS option"></a>
<p>
Normally, the garbage collector black-holes closures which are being
evaluated, as a space-saving measure.  That's exactly what you want
for ordinary Haskell programs.
<p>
When signal handlers are present, however, a computation may be
abandoned prematurely, leaving black holes behind.  If the signal
handler shares one of these black-holed closures, disaster can result.
Use the <tt>-N</tt> option to prevent black-holing by the garbage
collector if you suspect that your signal handlers may share <i>any</i>
subexpressions with the top-level computation.  Expect your heap usage
to increase, since the lifetimes of some closures may be extended.
</dl>
<p>

<a name="RTS options, general"></a>
<a name="-H<size> RTS option"></a>
<a name="-K<size> RTS option"></a>
<a name="-S<file> RTS option"></a>
<a name="-s<file> RTS option"></a>
<a name="stat2resid"></a>
<a name="-N RTS option"></a>
<a name="runtime_control_1.2"><h3>RTS options to control the garbage-collector</h3></a>
<a name="RTS options, garbage-collection"></a>
<p>
Besides the <tt>-H</tt> (set heap size) and <tt>-S</tt>/<tt>-s</tt> (GC stats) RTS
options, there are several options to give you precise control over
garbage collection.
<p>
<dl>
<dt><tt>-M&lt;n&gt;</tt>:
<dd><a name="-M<n> RTS option"></a>
<p>
Minimum % &lt;n&gt; of heap which must be available for allocation.
The default is 3%.
<p>
<dt><tt>-A&lt;size&gt;</tt>:
<dd><a name="-A<size> RTS option"></a>
<p>
Sets a limit on the size of the allocation area for generational
garbage collection to &lt;size&gt; bytes (<tt>-A</tt> gives default of 64k). If
a negative size is given the size of the allocation is fixed to
-&lt;size&gt;. For non-generational collectors, it fixes the minimum
heap which must be available after a collection, overriding the
<tt>-M&lt;n&gt;</tt> RTS option.
<p>
<dt><tt>-G&lt;size&gt;</tt>:
<dd><a name="-G<size> RTS option"></a>
<p>
Sets the percentage of free space to be promoted before a major
collection is invoked to &lt;size&gt;%. The default is 66%. If a
negative size is given it fixes the size of major generation threshold
to -&lt;size&gt; bytes.
<p>
<dt><tt>-F2s</tt>:
<dd><a name="-F2s RTS option"></a>
<p>
Forces a program compiled for generational GC to use two-space copying
collection. The two-space collector may outperform the generational
collector for programs which have a very low heap residency. It can
also be used to generate a statistics file from which a basic heap
residency profile can be produced (see Section <a href="#stat2resid">stat2resid</a>).
<p>
There will still be a small execution overhead imposed by the
generational compilation as the test for old generation updates will
still be executed (of course none will actually happen).  This
overhead is typically less than 1%.
<p>
<dt><tt>-j&lt;size&gt;</tt>:
<dd><a name="-j<size> RTS option"></a>
<p>
Force a major garbage collection every &lt;size&gt; bytes.  (Normally
used because you're keen on getting major-GC stats, notably heap residency
info.)
</dl>
<p>

<a name="RTS options, garbage-collection"></a>
<a name="-M<n> RTS option"></a>
<a name="-A<size> RTS option"></a>
<a name="-G<size> RTS option"></a>
<a name="-F2s RTS option"></a>
<a name="-j<size> RTS option"></a>
<a name="runtime_control_1.3"><h3>RTS options for profiling and Concurrent/Parallel Haskell</h3></a>

<p>
The RTS options related to profiling are described in
Chapter <a href="#prof-rts-options">prof-rts-options</a>;
and those for concurrent/parallel stuff, in Section <a href="#parallel-rts-opts">parallel-rts-opts</a>.
<p>

<a name="runtime_control_1.4"><h3>RTS options for hackers, debuggers, and over-interested souls</h3></a>
<a name="RTS options, hacking/debugging"></a>
<p>
These RTS options might be used (a) to avoid a GHC bug, (b) to see
"what's really happening", or (c) because you feel like it.  Not
recommended for everyday use!
<p>
<dl>
<dt><tt>-B</tt>:
<dd><a name="-B RTS option"></a>
<p>
Sound the bell at the start of each (major) garbage collection.
<p>
Oddly enough, people really do use this option!  Our pal in Durham
(England), PaulCallaghan, writes: "Some people here use it for a
variety of purposes -- honestly! -- e.g., confirmation that the
code/machine is doing something, infinite loop detection, gauging cost
of recently added code. Certain people can even tell what stage [the
program] is in by the beep pattern. But the major use is for annoying
others in the same office..."
<p>
<dt><tt>-I</tt>:
<dd>Use the "debugging mini-interpreter" with sanity-checking; you have
to have an appropriately-compiled version of the prelude, etc.
Goes together nicely with GDB (GNU debugger)...
(OLD, REALLY)
<p>
<dt><tt>-r&lt;file&gt;</tt>:
<dd><a name="-r <file> RTS option"></a>
<p>
Produce "ticky-ticky" statistics at the end of the program run.
The <tt>&lt;file&gt;</tt> business works just like on the <tt>-S</tt> RTS option (above).
<p>
"Ticky-ticky" statistics are counts of various program actions
(updates, enters, etc.)
The program must have been compiled using
<tt>-fstg-reduction-counts</tt><a name="-fstg-reduction-counts option"></a>
<p>
(a.k.a. "ticky-ticky profiling"), and, for it to be really useful,
linked with suitable system libraries.  Not a trivial undertaking:
consult the installation guide on how to set things up for
easy "ticky-ticky" profiling.
<p>
<dt><tt>-T&lt;num&gt;</tt>:
<dd><a name="-T RTS option"></a>
<p>
An RTS debugging flag; varying quantities of output depending on which bits
are set in &lt;num&gt;.
<p>
<dt><tt>-Z</tt>:
<dd><a name="-Z RTS option"></a>
<p>
Turn <i>off</i> "update-frame squeezing" at garbage-collection time.
(There's no particularly good reason to turn it off.)
</dl>
<p>

<a name="RTS options, hacking/debugging"></a>
<a name="-B RTS option"></a>
<a name="-r <file> RTS option"></a>
<a name="-fstg-reduction-counts option"></a>
<a name="-T RTS option"></a>
<a name="-Z RTS option"></a>
<a name="rts-hooks"><h3>"Hooks" to change RTS failure messages</h3></a>
<a name="hooks, RTS"></a>
<p>
<a name="RTS hooks"></a>
<p>
GHC lets you exercise rudimentary control over the messages printed
when the runtime system "blows up," e.g., on stack overflow.
<p>
Simply write some of the following procedures in C and then make sure
they get linked in, in preference to those in the RTS library:
<dl>
<dt><tt>void ErrorHdrHook (FILE *)</tt>:
<dd><a name="ErrorHdrHook"></a>
<p>
What's printed out before the message from <tt>error</tt>.
<p>
<dt><tt>void OutOfHeapHook (unsigned long, unsigned long)</tt>:
<dd><a name="OutOfHeapHook"></a>
<p>
The heap-overflow message.
<p>
<dt><tt>void StackOverflowHook (long int)</tt>:
<dd><a name="StackOverflowHook"></a>
<p>
The stack-overflow message.
<p>
<dt><tt>void MallocFailHook (long int)</tt>:
<dd><a name="MallocFailHook"></a>
<p>
The message printed if <tt>malloc</tt> fails.
<p>
<dt><tt>void PatErrorHdrHook (FILE *)</tt>:
<dd><a name="PatErrorHdrHook"></a>
<p>
The message printed if a pattern-match fails (the failures
that were not handled by the Haskell programmer).
<p>
<dt><tt>void PreTraceHook (FILE *)</tt>:
<dd><a name="PreTraceHook"></a>
<p>
What's printed out before a <tt>trace</tt> message.
<p>
<dt><tt>void PostTraceHook (FILE *)</tt>:
<dd><a name="PostTraceHook"></a>
<p>
What's printed out after a <tt>trace</tt> message.
</dl>
<p>
For example, here is the "hooks" code used by GHC itself:

<a name="hooks, RTS"></a>
<a name="RTS hooks"></a>
<a name="ErrorHdrHook"></a>
<a name="OutOfHeapHook"></a>
<a name="StackOverflowHook"></a>
<a name="MallocFailHook"></a>
<a name="PatErrorHdrHook"></a>
<a name="PreTraceHook"></a>
<a name="PostTraceHook"></a>
<pre>
#include &lt;stdio.h&gt;
#define W_ unsigned long int
#define I_ long int

void
ErrorHdrHook (where)
  FILE *where;
{
    fprintf(where, "\n"); /* no "Fail: " */
}

void
OutOfHeapHook (request_size, heap_size)
  W_ request_size; /* in bytes */
  W_ heap_size;    /* in bytes */
{
    fprintf(stderr, "GHC's heap exhausted;\nwhile trying to 
        allocate %lu bytes in a %lu-byte heap;\nuse the `-H&lt;size&gt;'
        option to increase the total heap size.\n",
        request_size,
        heap_size);
}

void
StackOverflowHook (stack_size)
  I_ stack_size;    /* in bytes */
{
    fprintf(stderr, "GHC stack-space overflow: current size
        %ld bytes.\nUse the `-K&lt;size&gt;' option to increase it.\n",
        stack_size);
}

void
PatErrorHdrHook (where)
  FILE *where;
{
    fprintf(where, "\n*** Pattern-matching error within GHC!\n\n
        This is a compiler bug; please report it to
        glasgow-haskell-bugs@dcs.glasgow.ac.uk.\n\nFail: ");
}

void
PreTraceHook (where)
  FILE *where;
{
    fprintf(where, "\n"); /* not "Trace On" */
}

void
PostTraceHook (where)
  FILE *where;
{
    fprintf(where, "\n"); /* not "Trace Off" */
}
</pre><p>

<p>





<p>

<a name="sooner-faster-quicker"><h2>Advice on: sooner, faster, smaller, stingier</h2></a>

<p>
Please advise us of other "helpful hints" that should go here!
<p>

<a name="sooner"><h3>Sooner: producing a program more quickly</h3></a>
<a name="compiling faster"></a>
<p>
<a name="faster compiling"></a>
<p>
<dl>
<p>
<dt>Don't use <tt>-O</tt> or (especially) <tt>-O2</tt>:
<dd>By using them, you are telling GHC that you are willing to suffer
longer compilation times for better-quality code.
<p>
GHC is surprisingly zippy for normal compilations without <tt>-O</tt>!
<p>
<dt>Use more memory:
<dd>Within reason, more memory for heap space means less garbage
collection for GHC, which means less compilation time.  If you use
the <tt>-Rgc-stats</tt> option, you'll get a garbage-collector report.
(Again, you can use the cheap-and-nasty <tt>-optCrts-Sstderr</tt> option to
send the GC stats straight to standard error.)
<p>
If it says you're using more than 20% of total time in garbage
collecting, then more memory would help.
<p>
You ask for more heap with the <tt>-H&lt;size&gt;</tt><a name="-H<size> option"></a>
<p>
option; e.g.: <tt>ghc -c -O -H16m Foo.hs</tt>.
<p>
If GHC persists in being a bad memory citizen, please report it as a
bug.
<p>
<dt>Don't use too much memory!
<dd>As soon as GHC plus its "fellow citizens" (other processes on your machine) start
using more than the <i>real memory</i> on your machine, and the machine
starts "thrashing," <i>the party is over</i>.  Compile times will be
worse than terrible!  Use something like the csh-builtin <tt>time</tt>
command to get a report on how many page faults you're getting.
<p>
If you don't know what virtual memory, thrashing, and page faults are,
or you don't know the memory configuration of your machine, <i>don't</i> try to be clever about memory use: you'll just make your life a
misery (and for other people, too, probably).
<p>
<dt>Try to use local disks when linking:
<dd>Because Haskell objects and libraries tend to be large, it can take
many real seconds to slurp the bits to/from an NFS filesystem (say).
<p>
It would be quite sensible to <i>compile</i> on a fast machine using
remotely-mounted disks; then <i>link</i> on a slow machine that had
your disks directly mounted.
<p>
<dt>Don't derive <tt>read</tt> for <tt>Text</tt> unnecessarily:
<dd>When doing <tt>deriving Text</tt>,
use <tt>-fomit-derived-read</tt><a name="-fomit-derived-read option"></a>
<p>
to derive only the <tt>showsPrec</tt> method.  Quicker, smaller code.
<p>
<dt>Don't re-export instance declarations:
<dd>(Note: This recommendation totally violates the Haskell language
standard.)
<p>
The Haskell module system dictates that instance declarations are
exported and re-exported into interface files with considerable gusto.
In a large system, especially one with mutually-recursive modules,
this tendency makes your interface files bigger (bad) and decreases
the chances that changes will be propagated incorrectly (bad).
<p>
If you wish, you may use a language-violating option,
<tt>-fomit-reexported-instances</tt>,
<a name="-fomit-reexported-instances option"></a>
<p>
to get just the effect you might expect.  It can't help but
speed things up.
<p>
<dt>GHC compiles some program constructs slowly:
<dd>Deeply-nested list comprehensions seem to be one such; in the past,
very large constant tables were bad, too.
<p>
We'd rather you reported such behaviour as a bug, so that we can try
to correct it.
<p>
The parts of the compiler that seem most prone to wandering off for a
long time are the abstract interpreters (strictness and update
analysers).  You can turn these off individually with
<tt>-fno-strictness</tt><a name="-fno-strictness anti-option"></a>
 and
<tt>-fno-update-analysis</tt>.<a name="-fno-update-analysis anti-option"></a>
<p>
If <tt>-ddump-simpl</tt> produces output after a reasonable time, but
<tt>-ddump-stg</tt> doesn't, then it's probably the update analyser
slowing you down.
<p>
If your module has big wads of constant data, GHC may produce a huge
basic block that will cause the native-code generator's register
allocator to founder.
<p>
If <tt>-ddump-absC</tt> produces output after a reasonable time, but
nothing after that -- it's probably the native-code generator.  Bring
on <tt>-fvia-C</tt><a name="-fvia-C option"></a>
 (not that GCC will be that quick about it, either).
<p>
<dt>Avoid the consistency-check on linking:
<dd>Use <tt>-no-link-chk</tt><a name="-no-link-chk"></a>
; saves effort.  This is probably
safe in a I-only-compile-things-one-way setup.
<p>
<dt>Explicit <tt>import</tt> declarations:
<dd>Instead of saying <tt>import Foo</tt>, say
<tt>import Foo (...stuff I want...)</tt>.
<p>
Truthfully, the reduction on compilation time will be very small.
However, judicious use of <tt>import</tt> declarations can make a
program easier to understand, so it may be a good idea anyway.
</dl>
<p>

<a name="compiling faster"></a>
<a name="faster compiling"></a>
<a name="-H<size> option"></a>
<a name="-fomit-derived-read option"></a>
<a name="-fomit-reexported-instances option"></a>
<a name="-fno-strictness anti-option"></a>
<a name="-fno-update-analysis anti-option"></a>
<a name="-fvia-C option"></a>
<a name="-no-link-chk"></a>
<a name="faster"><h3>Faster: producing a program that runs quicker</h3></a>
<a name="faster programs, how to produce"></a>
<p>
The key tool to use in making your Haskell program run faster are
GHC's profiling facilities, described separately in
part <a href="#profiling">profiling</a>.  There is <i>no substitute</i> for finding
where your program's time/space is <i>really</i> going, as opposed
to where you imagine it is going.
<p>
Another point to bear in mind: By far the best way to improve a
program's performance <i>dramatically</i> is to use better algorithms.
Once profiling has thrown the spotlight on the guilty
time-consumer(s), it may be better to re-think your program than to
try all the tweaks listed below.
<p>
Another extremely efficient way to make your program snappy is to use
library code that has been Seriously Tuned By Someone Else.  You <i>might</i> be able
to write a better quicksort than the one in the HBC library, but it
will take you much longer than typing <tt>import QSort</tt>.
(Incidentally, it doesn't hurt if the Someone Else is Lennart
Augustsson.)
<p>
Please report any overly-slow GHC-compiled programs.  The current
definition of "overly-slow" is "the HBC-compiled version ran
faster"...
<p>
<dl>
<p>
<dt>Optimise, using <tt>-O</tt> or <tt>-O2</tt>:
<dd>This is the most basic way
to make your program go faster.  Compilation time will be slower,
especially with <tt>-O2</tt>.
<p>
At version 0.26, <tt>-O2</tt> is nearly indistinguishable from <tt>-O</tt>.
<p>
<dt>Compile via C and crank up GCC:
<dd>Even with <tt>-O</tt>, GHC tries to
use a native-code generator, if available.  But the native
code-generator is designed to be quick, not mind-bogglingly clever.
Better to let GCC have a go, as it tries much harder on register
allocation, etc.
<p>
So, when we want very fast code, we use: <tt>-O -fvia-C -O2-for-C</tt>.
<p>
<dt>Overloaded functions are not your friend:
<dd>Haskell's overloading (using type classes) is elegant, neat, etc.,
etc., but it is death to performance if left to linger in an inner
loop.  How can you squash it?
<p>
<dl>
<dt>Give explicit type signatures:
<dd>Signatures are the basic trick; putting them on exported, top-level
functions is good software-engineering practice, anyway.
<p>
The automatic specialisation of overloaded functions should take care
of overloaded local and/or unexported functions.
<p>
<dt>Use <tt>SPECIALIZE</tt> pragmas:
<dd><a name="SPECIALIZE pragma"></a>
<p>
<a name="overloading, death to"></a>
<p>
(UK spelling also accepted.)  For key overloaded functions, you can
create extra versions (NB: more code space) specialised to particular
types.  Thus, if you have an overloaded function:

<a name="faster programs, how to produce"></a>
<a name="SPECIALIZE pragma"></a>
<a name="overloading, death to"></a>
<pre>
hammeredLookup :: Ord key =&gt; [(key, value)] -&gt; key -&gt; value
</pre><p>
If it is heavily used on lists with <tt>Widget</tt> keys, you could
specialise it as follows:

<pre>
{-# SPECIALIZE hammeredLookup :: [(Widget, value)] -&gt; Widget -&gt; value #-}
</pre><p>

To get very fancy, you can also specify a named function to use for
the specialised value, by adding <tt>= blah</tt>, as in:

<pre>
{-# SPECIALIZE hammeredLookup :: ...as before... = blah #-}
</pre><p>
It's <i>Your Responsibility</i> to make sure that <tt>blah</tt> really
behaves as a specialised version of <tt>hammeredLookup</tt>!!!
<p>
An example in which the <tt>= blah</tt> form will Win Big:

<pre>
toDouble :: Real a =&gt; a -&gt; Double
toDouble = fromRational . toRational

{-# SPECIALIZE toDouble :: Int -&gt; Double = i2d #-}
i2d (I# i) = D# (int2Double# i) -- uses Glasgow prim-op directly
</pre><p>
The <tt>i2d</tt> function is virtually one machine instruction; the
default conversion -- via an intermediate <tt>Rational</tt> -- is obscenely
expensive by comparison.
<p>
By using the US spelling, your <tt>SPECIALIZE</tt> pragma will work with
HBC, too.  Note that HBC doesn't support the <tt>= blah</tt> form.
<p>
A <tt>SPECIALIZE</tt> pragma for a function can be put anywhere its type
signature could be put.
<p>
<dt>Use <tt>SPECIALIZE instance</tt> pragmas:
<dd>Same idea, except for instance declarations.  For example:

<pre>
instance (Eq a) =&gt; Eq (Foo a) where { ... usual stuff ... }

{-# SPECIALIZE instance Eq (Foo [(Int, Bar)] #-}
</pre><p>
Compatible with HBC, by the way.
<p>
See also: overlapping instances, in Chapter <a href="#glasgow-hbc-exts">glasgow-hbc-exts</a>.
They are to <tt>SPECIALIZE instance</tt> pragmas what <tt>= blah</tt>
hacks are to <tt>SPECIALIZE</tt> (value) pragmas...
<p>
<dt>"How do I know what's happening with specialisations?":
<dd>The <tt>-fshow-specialisations</tt><a name="-fshow-specialisations option"></a>
<p>
will show the specialisations that actually take place.
<p>
The <tt>-fshow-import-specs</tt><a name="-fshow-import-specs option"></a>
 will
show the specialisations that GHC <i>wished</i> were available, but
were not.  You can add the relevant pragmas to your code if you wish.
<p>
You're a bit stuck if the desired specialisation is of a Prelude
function.  If it's Really Important, you can just snap a copy of the
Prelude code, rename it, and then SPECIALIZE that to your heart's
content.
<p>
<dt>"But how do I know where overloading is creeping in?":
<dd>A low-tech way: grep (search) your interface files for overloaded
type signatures; e.g.,:

<a name="-fshow-specialisations option"></a>
<a name="-fshow-import-specs option"></a>
<pre>
% egrep '^[a-z].*::.*=&gt;' *.hi
</pre><p>

Note: explicit export lists sometimes "mask" overloaded top-level
functions; i.e., you won't see anything about them in the interface
file.  I sometimes remove my export list temporarily, just to see what
pops out.
</dl>
<p>
<dt>Strict functions are your dear friends:
<dd>and, among other things, lazy pattern-matching is your enemy.
<p>
(If you don't know what a "strict function" is, please consult a
functional-programming textbook.  A sentence or two of
explanation here probably would not do much good.)
<p>
Consider these two code fragments:

<pre>
f (Wibble x y) =  ... # strict

f arg = let { (Wibble x y) = arg } in ... # lazy
</pre><p>
The former will result in far better code.
<p>
A less contrived example shows the use of <tt>cases</tt> instead
of <tt>lets</tt> to get stricter code (a good thing):

<pre>
f (Wibble x y)  # beautiful but slow
  = let
        (a1, b1, c1) = unpackFoo x
        (a2, b2, c2) = unpackFoo y
    in ...

f (Wibble x y)  # ugly, and proud of it
  = case (unpackFoo x) of { (a1, b1, c1) -&gt;
    case (unpackFoo y) of { (a2, b2, c2) -&gt;
    ...
    }}
</pre><p>

<p>
<dt>GHC loves single-constructor data-types:
<dd>It's all the better if a function is strict in a single-constructor
type (a type with only one data-constructor; for example, tuples are
single-constructor types).
<p>
<dt>"How do I find out a function's strictness?"
<dd>Don't guess -- look it up.
<p>
Look for your function in the interface file, then for the third field
in the pragma; it should say <tt>_S_ &lt;string&gt;</tt>.  The <tt>&lt;string&gt;</tt>
gives the strictness of the function's arguments.  <tt>L</tt> is lazy
(bad), <tt>S</tt> and <tt>E</tt> are strict (good), <tt>P</tt> is "primitive" (good),
<tt>U(...)</tt> is strict and
"unpackable" (very good), and <tt>A</tt> is absent (very good).
<p>
For an "unpackable" <tt>U(...)</tt> argument, the info inside
tells the strictness of its components.  So, if the argument is a
pair, and it says <tt>U(AU(LSS))</tt>, that means "the first component of the
pair isn't used; the second component is itself unpackable, with three
components (lazy in the first, strict in the second \& third)."
<p>
If the function isn't exported, just compile with the extra flag <tt>-ddump-simpl</tt>;
next to the signature for any binder, it will print the self-same
pragmatic information as would be put in an interface file.
(Besides, Core syntax is fun to look at!)
<p>
<dt>Force key functions to be <tt>INLINE</tt>d (esp. monads):
<dd>GHC (with <tt>-O</tt>, as always) tries to inline (or "unfold")
functions/values that are "small enough," thus avoiding the call
overhead and possibly exposing other more-wonderful optimisations.
<p>
You will probably see these unfoldings (in Core syntax) in your
interface files.
<p>
Normally, if GHC decides a function is "too expensive" to inline, it
will not do so, nor will it export that unfolding for other modules to
use.
<p>
The sledgehammer you can bring to bear is the
<tt>INLINE</tt><a name="INLINE pragma"></a>
 pragma, used thusly:

<a name="INLINE pragma"></a>
<pre>
key_function :: Int -&gt; String -&gt; (Bool, Double) 

#ifdef __GLASGOW_HASKELL__
{-# INLINE key_function #-}
#endif
</pre><p>
(You don't need to do the C pre-processor carry-on unless you're going
to stick the code through HBC -- it doesn't like <tt>INLINE</tt> pragmas.)
<p>
The major effect of an <tt>INLINE</tt> pragma is to declare a function's
"cost" to be very low.  The normal unfolding machinery will then be
very keen to inline it.
<p>
An <tt>INLINE</tt> pragma for a function can be put anywhere its type
signature could be put.
<p>
<tt>INLINE</tt> pragmas are a particularly good idea for the
<tt>then</tt>/<tt>return</tt> (or <tt>bind</tt>/<tt>unit</tt>) functions in a monad.
For example, in GHC's own <a href="#UniqueSupply"><tt>UniqueSupply</tt></a> monad code, we have:

<pre>
#ifdef __GLASGOW_HASKELL__
{-# INLINE thenUs #-}
{-# INLINE returnUs #-}
#endif
</pre><p>

GHC reserves the right to <i>disallow</i> any unfolding, even if you
explicitly asked for one.  That's because a function's body may
become <i>unexportable</i>, because it mentions a non-exported value,
to which any importing module would have no access.
<p>
If you want to see why candidate unfoldings are rejected, use the
<tt>-freport-disallowed-unfoldings</tt>
<a name="-freport-disallowed-unfoldings"></a>
<p>
option.
<p>
<dt>Don't let GHC ignore pragmatic information:
<dd>Sort-of by definition, GHC is allowed to ignore pragmas in interfaces.
Your program should still work, if not as well.
<p>
Normally, GHC <i>will</i> ignore an unfolding pragma in an interface if
it cannot figure out all the names mentioned in the unfolding.  (A
very much hairier implementation could make sure This Never Happens,
but life is too short to wage constant battle with Haskell's module
system.)
<p>
If you want to prevent such ignorings, give GHC a
<tt>-fshow-pragma-name-errs</tt>
option.<a name="-fshow-pragma-name-errs option"></a>
<p>
It will then treat any unresolved names in pragmas as <i>errors</i>, rather than inconveniences.
<p>
<dt>Explicit <tt>export</tt> list:
<dd>If you do not have an explicit export list in a module, GHC must
assume that everything in that module will be exported.  This has
various pessimising effect.  For example, if a bit of code is actually
<i>unused</i> (perhaps because of unfolding effects), GHC will not be
able to throw it away, because it is exported and some other module
may be relying on its existence.
<p>
GHC can be quite a bit more aggressive with pieces of code if it knows
they are not exported.
<p>
<dt>Look at the Core syntax!
<dd>(The form in which GHC manipulates your code.)  Just run your
compilation with <tt>-ddump-simpl</tt> (don't forget the <tt>-O</tt>).
<p>
If profiling has pointed the finger at particular functions, look at
their Core code.  <tt>lets</tt> are bad, <tt>cases</tt> are good, dictionaries
(<tt>d.&lt;Class&gt;.&lt;Unique&gt;</tt>) [or anything overloading-ish] are bad,
nested lambdas are bad, explicit data constructors are good, primitive
operations (e.g., <tt>eqInt#</tt>) are good, ...
<p>
<dt>Use unboxed types (a GHC extension):
<dd>When you are <i>really</i> desperate for speed, and you want to
get right down to the "raw bits."
Please see chapter <a href="#glasgow-unboxed">glasgow-unboxed</a> for some information about
using unboxed types.
<p>
<dt>Use <tt>_ccall_s</tt> (a GHC extension) to plug into fast libraries:
<dd>This may take real work, but... There exist piles of
massively-tuned library code, and the best thing is not
to compete with it, but link with it.
<p>
Chapter <a href="#glasgow-ccalls">glasgow-ccalls</a> says a little about how to use C calls.
<p>
<dt>Don't use <tt>Float</tt>s:
<dd>We don't provide specialisations of Prelude functions for <tt>Float</tt>
(but we do for <tt>Double</tt>).  If you end up executing overloaded
code, you will lose on performance, perhaps badly.
<p>
<tt>Floats</tt> (probably 32-bits) are almost always a bad idea, anyway,
unless you Really Know What You Are Doing.  Use Doubles.  There's
rarely a speed disadvantage -- modern machines will use the same
floating-point unit for both.  With <tt>Doubles</tt>, you are much less
likely to hang yourself with numerical errors.
<p>
<dt>Use a bigger heap!
<dd>If your program's GC stats (<tt>-S</tt><a name="-S RTS option"></a>
 RTS option)
indicate that it's doing lots of garbage-collection (say, more than
20% of execution time), more memory might help -- with the
<tt>-H&lt;size&gt;</tt><a name="-H<size> RTS option"></a>
 RTS option.
<p>
<dt>Use a smaller heap!
<dd>Some programs with a very small heap residency (toy programs, usually)
actually benefit from running the heap size way down.  The
<tt>-H&lt;size&gt;</tt> RTS option, as above.
<p>
<dt>Use a smaller "allocation area":
<dd>If you can get the garbage-collector's youngest generation to fit
entirely in your machine's cache, it may make quite a difference.
The effect is <i>very machine dependent</i>.  But, for example,
a <tt>+RTS -A128k</tt><a name="-A<size> RTS option"></a>
 option on one of our
DEC Alphas was worth an immediate 5% performance boost.
</dl>
<p>

<a name="-freport-disallowed-unfoldings"></a>
<a name="-fshow-pragma-name-errs option"></a>
<a name="-S RTS option"></a>
<a name="-H<size> RTS option"></a>
<a name="-A<size> RTS option"></a>
<a name="smaller"><h3>Smaller: producing a program that is smaller</h3></a>
<a name="smaller programs, how to produce"></a>
<p>
Decrease the "go-for-it" threshold for unfolding smallish expressions.
Give a <tt>-funfolding-use-threshold0</tt><a name="-funfolding-use-threshold0 option"></a>
<p>
option for the extreme case. ("Only unfoldings with zero cost should proceed.")
<p>
(Note: I have not been too successful at producing code smaller
than that which comes out with <tt>-O</tt>.  WDP 94/12)
<p>
Use <tt>-fomit-derived-read</tt> if you are using a lot of derived
instances of <tt>Text</tt> (and don't need the read methods).
<p>
Use <tt>strip</tt> on your executables.
<p>

<a name="smaller programs, how to produce"></a>
<a name="-funfolding-use-threshold0 option"></a>
<a name="stingier"><h3>Stingier: producing a program that gobbles less heap space</h3></a>
<a name="memory, using less heap"></a>
<p>
<a name="space-leaks, avoiding"></a>
<p>
<a name="heap space, using less"></a>
<p>
"I think I have a space leak..."  Re-run your program with
<tt>+RTS -Sstderr</tt>,<a name="-Sstderr RTS option"></a>
 and remove all doubt!
(You'll see the heap usage get bigger and bigger...)  [Hmmm... this
might be even easier with the <tt>-F2s</tt><a name="-F2s RTS option"></a>
 RTS
option; so...  <tt>./a.out +RTS -Sstderr -F2s</tt>...]
<p>
Once again, the profiling facilities (part <a href="#profiling">profiling</a>) are the
basic tool for demystifying the space behaviour of your program.
<p>
Strict functions are good to space usage, as they are for time, as
discussed in the previous section.  Strict functions get right down to
business, rather than filling up the heap with closures (the system's
notes to itself about how to evaluate something, should it eventually
be required).
<p>
If you have a true blue "space leak" (your program keeps gobbling up
memory and never "lets go"), then 7 times out of 10 the problem is
related to a <i>CAF</i> (constant applicative form).  Real people call
them "top-level values that aren't functions."  Thus, for example:

<a name="memory, using less heap"></a>
<a name="space-leaks, avoiding"></a>
<a name="heap space, using less"></a>
<a name="-Sstderr RTS option"></a>
<a name="-F2s RTS option"></a>
<pre>
x = (1 :: Int)
f y = x
ones = [ 1, (1 :: Float), .. ]
</pre><p>
<tt>x</tt> and <tt>ones</tt> are CAFs; <tt>f</tt> is not.
<p>
The GHC garbage collectors are not clever about CAFs.  The part of the
heap reachable from a CAF is never collected.  In the case of
<tt>ones</tt> in the example above, it's <i>disastrous</i>.  For this
reason, the GHC "simplifier" tries hard to avoid creating CAFs, but
it cannot subvert the will of a determined CAF-writing programmer (as
in the case above).






<a name="profiling"><h2>Profiling Haskell programs</h2></a>
<a name="profiling, with cost-centres"></a>
<p>
<a name="cost-centre profiling"></a>
<p>
Glasgow Haskell comes with a time and space profiling system. Its
purpose is to help you improve your understanding of your program's
execution behaviour, so you can improve it.
<p>
Any comments, suggestions and/or improvements you have to are welcome.
Recommended "profiling tricks" would be especially cool!
<p>

<a name="profiling, with cost-centres"></a>
<a name="cost-centre profiling"></a>
<a name="profiling-intro"><h3>How to profile a Haskell program</h3></a>

The GHC approach to profiling is very simple: annotate the expressions
you consider "interesting" with <i>cost centre</i> labels (strings);
so, for example, you might have:
<p>

<pre>
f x y
  = let
        output1 = _scc_ "Pass1" ( pass1 x )
        output2 = _scc_ "Pass2" ( pass2 output1 y )
        output3 = _scc_ "Pass3" ( pass3 (output2 `zip` [1 .. ]) )
    in concat output3
</pre><p>

The costs of the evaluating the expressions bound to <tt>output1</tt>,
<tt>output2</tt> and <tt>output3</tt> will be attributed to the "cost
centres" <tt>Pass1</tt>, <tt>Pass2</tt> and <tt>Pass3</tt>, respectively.
<p>
The costs of evaluating other expressions, e.g., <tt>concat output4</tt>,
will be inherited by the scope which referenced the function <tt>f</tt>.
<p>
You can put in cost-centres via <tt>_scc_</tt> constructs by hand, as in
the example above.  Perfectly cool.  That's probably what you <i>would</i> do if your program divided into obvious "passes" or
"phases", or whatever.
<p>
If your program is large or you have no clue what might be gobbling
all the time, you can get GHC to mark all functions with <tt>_scc_</tt>
constructs, automagically.  Add an <tt>-auto</tt> compilation flag to the
usual <tt>-prof</tt> option.
<p>
Once you start homing in on the Guilty Suspects, you may well switch
from automagically-inserted cost-centres to a few well-chosen ones of
your own.
<p>
To use profiling, you must <i>compile</i> and <i>run</i> with special
options.  (We usually forget the "run" magic! -- Do as we say, not as
we do...) Details follow.
<p>
If you're serious about this profiling game, you should probably read
one or more of the Sansom/Peyton Jones papers about the GHC profiling
system.  Just visit the Glasgow FP Web page...
<p>

<a name="prof-compiler-options"><h3>Compiling programs for profiling</h3></a>
<a name="profiling options"></a>
<p>
<a name="options, for profiling"></a>
<p>

<p>
To make use of the cost centre profiling system <i>all</i> modules must
be compiled and linked with the <tt>-prof</tt> option.<a name="-prof option"></a>
<p>
Any <tt>_scc_</tt> constructs you've put in your source will spring to life.
<p>
Without a <tt>-prof</tt> option, your <tt>_scc_</tt>s are ignored; so you can
compiled <tt>_scc_</tt>-laden code without changing it.
<p>
There are a few other profiling-related compilation options.  Use them
<i>in addition to</i> <tt>-prof</tt>.  These do not have to be used
consistently for all modules in a program.
<p>
<dl>
<dt><tt>-auto</tt>:
<dd><a name="-auto option"></a>
<p>
GHC will automatically add <tt>_scc_</tt> constructs for
all top-level, exported functions.
<p>
<dt><tt>-auto-all</tt>:
<dd><a name="-auto-all option"></a>
<p>
<i>All</i> top-level functions, exported or not, will be automatically
<tt>_scc_</tt>'d.
<p>
<dt><tt>-ignore-scc</tt>:
<dd><a name="-ignore-scc option"></a>
<p>
Ignore any <tt>_scc_</tt> constructs,
so a module which already has <tt>_scc_</tt>s can be
compiled for profiling with the annotations ignored.
<p>
<dt><tt>-G&lt;group&gt;</tt>:
<dd><a name="-G<group> option"></a>
<p>
Specifies the &lt;group&gt; to be attached to all the cost-centres
declared in the module. If no group is specified it defaults to the
module name.
</dl>
<p>
In addition to the <tt>-prof</tt> option your system might be setup to
enable you to compile and link with the <tt>-prof-details</tt>
<a name="\tr{-prof-details option}"></a>
 option instead. This enables
additional detailed counts to be reported with the <tt>-P</tt> RTS option.
<p>

<a name="-prof option"></a>
<a name="-auto option"></a>
<a name="-auto-all option"></a>
<a name="-ignore-scc option"></a>
<a name="-G<group> option"></a>
<a name="\tr{-prof-details option}"></a>



<p>

<a name="profiling options"></a>
<a name="options, for profiling"></a>
<a name="prof-rts-options"><h3>How to control your profiled program at runtime</h3></a>
<a name="profiling RTS options"></a>
<p>
<a name="RTS options, for profiling"></a>
<p>

<p>
It isn't enough to compile your program for profiling with <tt>-prof</tt>!
<p>
When you <i>run</i> your profiled program, you must tell the runtime system (RTS)
what you want to profile (e.g., time and/or space), and how you wish
the collected data to be reported.  You also may wish to set the
sampling interval used in time profiling.
<p>
Executive summary: <tt>./a.out +RTS -p</tt> produces a time profile in
<tt>a.out.prof</tt>; <tt>./a.out +RTS -hC</tt> produces space-profiling
info which can be mangled by <tt>hp2ps</tt> and viewed with <tt>ghostview</tt>
(or equivalent).
<p>
Profiling runtime flags are passed to your program between the usual
<tt>+RTS</tt> and <tt>-RTS</tt> options.
<p>
<dl>
<dt><tt>-p&lt;sort&gt;</tt> or <tt>-P&lt;sort&gt;</tt>:
<dd><a name="-p<sort> RTS option (profiling)"></a>
<p>
<a name="-P<sort> RTS option (profiling)"></a>
<p>
<a name="time profile"></a>
<p>
<a name="serial time profile"></a>
<p>
The <tt>-p</tt> option produces a standard <i>time profile</i> report.
It is written into the file &lt;program&gt;<tt>.prof</tt>.
<p>
The <tt>-P</tt> option produces a more detailed report containing the
actual time and allocation data as well.  (Not used much.)
<p>
The <tt>-P</tt> option also produces <i>serial time-profiling</i>
information, in the file &lt;program&gt;<tt>.time</tt>. This can be
converted into a (somewhat unsatisfactory) PostScript graph using
<tt>hp2ps</tt> (see Section <a href="#hp2ps">hp2ps</a>).
<p>
???? -F2s needed for serial time profile??? <B>ToDo</B>
<p>
The &lt;sort&gt; indicates how the cost centres are to be sorted in the
report. Valid &lt;sort&gt; options are:
<dl>
<dt><tt>T</tt>:
<dd>by time, largest first (the default);
<dt><tt>A</tt>:
<dd>by bytes allocated, largest first;
<dt><tt>C</tt>:
<dd>alphabetically by group, module and cost centre.
</dl>
<p>
<dt><tt>-i&lt;secs&gt;</tt>:
<dd><a name="-i<secs> RTS option (profiling)"></a>
<p>
Set the profiling (sampling) interval to <tt>&lt;secs&gt;</tt> seconds (the
default is 1 second).
<p>
<dt><tt>-h&lt;break-down&gt;</tt>:
<dd><a name="-h<break-down> RTS option (profiling)"></a>
<p>
<a name="heap profile"></a>
<p>
Produce a detailed <i>space profile</i> of the heap occupied by live
closures. The profile is written to the file &lt;program&gt;<tt>.hp</tt>
from which a PostScript graph can be produced using <tt>hp2ps</tt> (see
Section <a href="#hp2ps">hp2ps</a>).
<p>
The heap space profile may be broken down by different criteria:
<dl>
<dt><tt>-hC</tt>:
<dd>cost centre which produced the closure (the default).
<dt><tt>-hM</tt>:
<dd>cost centre module which produced the closure.
<dt><tt>-hG</tt>:
<dd>cost centre group which produced the closure.
<dt><tt>-hD</tt>:
<dd>closure description  --  a string describing the closure.
<dt><tt>-hY</tt>:
<dd>closure type  --  a string describing the closure's type.
<p>
</dl>
By default all live closures in the heap are profiled, but particular
closures of interest can be selected (see below). 
</dl>
<p>
Heap (space) profiling uses hash tables. If these tables
should fill the run will abort. The
<tt>-z&lt;tbl&gt;&lt;size&gt;</tt><a name="-z<tbl><size> RTS option (profiling)"></a>
 option is used to
increase the size of the relevant hash table (<tt>C</tt>, <tt>M</tt>,
<tt>G</tt>, <tt>D</tt> or <tt>Y</tt>, defined as for &lt;break-down&gt; above). The
actual size used is the next largest power of 2.
<p>
The heap profile can be restricted to particular closures of interest.
The closures of interest can selected by the attached cost centre
(module:label, module and group), closure category (description, type,
and kind) and closure age using the following options:
<dl>
<dt><tt>-c\{&lt;mod&gt;:&lt;lab&gt;,&lt;mod&gt;:&lt;lab&gt;...\}</tt>:
<dd><a name="-c{<lab>} RTS option (profiling)"></a>
<p>
Selects individual cost centre(s).
<dt><tt>-m\{&lt;mod&gt;,&lt;mod&gt;...\}</tt>:
<dd><a name="-m{<mod>} RTS option (profiling)"></a>
<p>
Selects all cost centres from the module(s) specified.
<dt><tt>-g\{&lt;grp&gt;,&lt;grp&gt;...\}</tt>:
<dd><a name="-g{<grp>} RTS option (profiling)"></a>
<p>
Selects all cost centres from the groups(s) specified.
<dt><tt>-d\{&lt;des&gt;,&lt;des&gt;...\}</tt>:
<dd><a name="-d{<des>} RTS option (profiling)"></a>
<p>
Selects closures which have one of the specified descriptions.
<dt><tt>-y\{&lt;typ&gt;,&lt;typ&gt;...\}</tt>:
<dd><a name="-y{<typ>} RTS option (profiling)"></a>
<p>
Selects closures which have one of the specified type descriptions.
<dt><tt>-k\{&lt;knd&gt;,&lt;knd&gt;...\}</tt>:
<dd><a name="-k{<knd>} RTS option (profiling)"></a>
<p>
Selects closures which are of one of the specified closure kinds.
Valid closure kinds are <tt>CON</tt> (constructor), <tt>FN</tt> (manifest
function), <tt>PAP</tt> (partial application), <tt>BH</tt> (black hole) and
<tt>THK</tt> (thunk).
<p>
</dl>
The space occupied by a closure will be reported in the heap profile
if the closure satisfies the following logical expression:
<p><pre>
([-c] or [-m] or [-g]) and ([-d] or [-y] or [-k]) 

<a name="-p<sort> RTS option (profiling)"></a>
<a name="-P<sort> RTS option (profiling)"></a>
<a name="time profile"></a>
<a name="serial time profile"></a>
<a name="-i<secs> RTS option (profiling)"></a>
<a name="-h<break-down> RTS option (profiling)"></a>
<a name="heap profile"></a>
<a name="-z<tbl><size> RTS option (profiling)"></a>
<a name="-c{<lab>} RTS option (profiling)"></a>
<a name="-m{<mod>} RTS option (profiling)"></a>
<a name="-g{<grp>} RTS option (profiling)"></a>
<a name="-d{<des>} RTS option (profiling)"></a>
<a name="-y{<typ>} RTS option (profiling)"></a>
<a name="-k{<knd>} RTS option (profiling)"></a>
</pre><p>
where a particular option is true if the closure (or its attached cost
centre) is selected by the option (or the option is not specified).




<p>

<a name="profiling RTS options"></a>
<a name="RTS options, for profiling"></a>
<a name="prof-output"><h3>What's in a profiling report?</h3></a>
<a name="profiling report, meaning thereof"></a>
<p>

<p>
When you run your profiled program with the <tt>-p</tt> RTS option
<a name="\tr{-p<sort> RTS option (profiling)}"></a>
, you get the following
information about your "cost centres":
<p>
<dl>
<p>
<dt><tt>COST CENTRE</tt>:
<dd>The cost-centre's name.
<p>
<dt><tt>MODULE</tt>:
<dd>The module associated with the cost-centre;
important mostly if you have identically-named cost-centres in
different modules.
<p>
<dt><tt>scc</tt>:
<dd>How many times this cost-centre was entered; think
of it as "I got to the <tt>_scc_</tt> construct this many times..."
<p>
<dt><tt>%time</tt>:
<dd>What part of the time was spent in this cost-centre (see also "ticks,"
below).
<p>
<dt><tt>%alloc</tt>:
<dd>What part of the memory allocation was done in this cost-centre
(see also "bytes," below).
<p>
<dt><tt>inner</tt>:
<dd>How many times this cost-centre "passed control" to an inner
cost-centre; for example, <tt>scc=4</tt> plus <tt>subscc=8</tt> means
"This <tt>_scc_</tt> was entered four times, but went out to
other <tt>_scc_s</tt> eight times."
<p>
<dt><tt>cafs</tt>:
<dd>How many CAFs this cost centre evaluated.
<p>
<dt><tt>dicts</tt>:
<dd>How many dictionaries this cost centre evaluated.
</dl>
<p>
In addition you can use the <tt>-P</tt> RTS option <a name="\tr{-P<sort> RTS     option (profiling)}"></a>
 to get the following additional information: 
<dl>
<p>
<dt><tt>ticks</tt>:
<dd>The raw number of time "ticks" which were
attributed to this cost-centre; from this, we get the <tt>%time</tt>
figure mentioned above.
<p>
<dt><tt>bytes</tt>:
<dd>Number of bytes allocated in the heap while in
this cost-centre; again, this is the raw number from which we
get the <tt>%alloc</tt> figure mentioned above.
</dl>
<p>
Finally if you built your program with <tt>-prof-details</tt>
<a name="\tr{-prof-details option}"></a>
 the <tt>-P</tt> RTS option will also
produce the following information:
<dl>
<p>
<dt><tt>closures</tt>:
<dd>How many heap objects were allocated; these objects may be of varying
size.  If you divide the number of bytes (mentioned below) by this
number of "closures", then you will get the average object size.
(Not too interesting, but still...)
<p>
<dt><tt>thunks</tt>:
<dd>How many times we entered (evaluated) a thunk -- an unevaluated
object in the heap -- while we were in this cost-centre.
<p>
<dt><tt>funcs</tt>:
<dd>How many times we entered (evaluated) a function while we we in this
cost-centre.  (In Haskell, functions are first-class values and may be
passed as arguments, returned as results, evaluated, and generally
manipulated just like data values)
<p>
<dt><tt>PAPs</tt>:
<dd>How many times we entered (evaluated) a partial application (PAP), i.e.,
a function applied to fewer arguments than it needs.  For example, <tt>Int</tt>
addition applied to one argument would be a PAP.  A PAP is really
just a particular form for a function.
</dl>

<a name="\tr{-p<sort> RTS option (profiling)}"></a>
<a name="\tr{-P<sort> RTS     option (profiling)}"></a>
<a name="\tr{-prof-details option}"></a>



<p>

<a name="profiling report, meaning thereof"></a>
<a name="prof-graphs"><h3>Producing graphical heap profiles</h3></a>
<a name="heap profiles, producing"></a>
<p>

<p>
Utility programs which produce graphical profiles.
<p>

<a name="hp2ps"><h4><tt>hp2ps</tt>--heap profile to PostScript</h4></a>
<a name="hp2ps (utility)"></a>
<p>
<a name="heap profiles"></a>
<p>
<a name="PostScript, from heap profiles"></a>
<p>
USAGE: <tt>hp2ps</tt> [flags] [&lt;file&gt;[<tt>.stat</tt>]]
<p>
The program <tt>hp2ps</tt><a name="hp2ps"></a>
 converts a heap profile as
produced by the <tt>-h&lt;break-down&gt;</tt><a name="-h<break-down> RTS option"></a>
<p>
runtime option into a PostScript graph of the heap profile. By
convention, the file to be processed by <tt>hp2ps</tt> has a <tt>.hp</tt>
extension. The PostScript output is written to &lt;file&gt;<tt>.ps</tt>. If
&lt;file&gt; is omitted entirely, then the program behaves as a filter.
<p>
<tt>hp2ps</tt> is distributed in <tt>ghc/utils/hp2ps</tt>. It was originally
developed by Dave Wakeling as part of the HBC/LML heap
profiler.
<p>
The flags are:
<dl>
<dt><tt>-d</tt>
<dd>In order to make graphs more readable, <tt>hp2ps</tt> sorts the shaded
bands for each identifier. The default sort ordering is for the bands
with the largest area to be stacked on top of the smaller ones.  The
<tt>-d</tt> option causes rougher bands (those representing series of
values with the largest standard deviations) to be stacked on top of
smoother ones.
<p>
<dt><tt>-b</tt>
<dd>Normally, <tt>hp2ps</tt> puts the title of the graph in a small box at the
top of the page. However, if the JOB string is too long to fit in a
small box (more than 35 characters), then
<tt>hp2ps</tt> will choose to use a big box instead.  The <tt>-b</tt>
option forces <tt>hp2ps</tt> to use a big box.
<p>
<dt><tt>-e&lt;float&gt;[in|mm|pt]</tt>
<dd>Generate encapsulated PostScript suitable for inclusion in LaTeX
documents.  Usually, the PostScript graph is drawn in landscape mode
in an area 9 inches wide by 6 inches high, and <tt>hp2ps</tt> arranges
for this area to be approximately centred on a sheet of a4 paper.
This format is convenient of studying the graph in detail, but it is
unsuitable for inclusion in LaTeX documents.  The <tt>-e</tt> option
causes the graph to be drawn in portrait mode, with float specifying
the width in inches, millimetres or points (the default).  The
resulting PostScript file conforms to the Encapsulated PostScript
(EPS) convention, and it can be included in a LaTeX document using
Rokicki's dvi-to-PostScript converter <tt>dvips</tt>.
<p>
<dt><tt>-g</tt>
<dd>Create output suitable for the <tt>gs</tt> PostScript previewer (or
similar). In this case the graph is printed in portrait mode without
scaling. The output is unsuitable for a laser printer.
<p>
<dt><tt>-l</tt>
<dd>Normally a profile is limited to 20 bands with additional identifiers
being grouped into an <tt>OTHER</tt> band. The <tt>-l</tt> flag removes this
20 band and limit, producing as many bands as necessary. No key is
produced as it won't fit!. It is useful for creation time profiles
with many bands.
<p>
<dt><tt>-m&lt;int&gt;</tt>
<dd>Normally a profile is limited to 20 bands with additional identifiers
being grouped into an <tt>OTHER</tt> band. The <tt>-m</tt> flag specifies an
alternative band limit (the maximum is 20).
<p>
<tt>-m0</tt> requests the band limit to be removed. As many bands as
necessary are produced. However no key is produced as it won't fit! It
is useful for displaying creation time profiles with many bands.
<p>
<dt><tt>-p</tt>
<dd>Use previous parameters. By default, the PostScript graph is
automatically scaled both horizontally and vertically so that it fills
the page.  However, when preparing a series of graphs for use in a
presentation, it is often useful to draw a new graph using the same
scale, shading and ordering as a previous one. The <tt>-p</tt> flag causes
the graph to be drawn using the parameters determined by a previous
run of <tt>hp2ps</tt> on file. These are extracted from
file<tt>.aux</tt>.
<p>
<dt><tt>-s</tt>
<dd>Use a small box for the title.
<p>
<dt><tt>-t&lt;float&gt;</tt>
<dd>Normally trace elements which sum to a total of less than 1% of the
profile are removed from the profile. The <tt>-t</tt> option allows this
percentage to be modified (maximum 5%). 
<p>
<tt>-t0</tt> requests no trace elements to be removed from the profile,
ensuring that all the data will be displayed. 
<p>
<dt><tt>-?</tt>
<dd>Print out usage information.
</dl>
<p>

<a name="hp2ps (utility)"></a>
<a name="heap profiles"></a>
<a name="PostScript, from heap profiles"></a>
<a name="hp2ps"></a>
<a name="-h<break-down> RTS option"></a>
<a name="stat2resid"><h4><tt>stat2resid</tt> -- residency info from GC stats</h4></a>
<a name="stat2resid (utility)"></a>
<p>
<a name="GC stats -- residency info"></a>
<p>
<a name="residency, from GC stats"></a>
<p>
USAGE: <tt>stat2resid</tt> [&lt;file&gt;[<tt>.stat</tt>] [&lt;outfile&gt;]]
<p>
The program <tt>stat2resid</tt><a name="stat2resid"></a>
 converts a detailed
garbage collection statistics file produced by the 
<tt>-S</tt><a name="-S RTS option"></a>
 runtime option into a PostScript heap
residency graph. The garbage collection statistics file can be
produced without compiling your program for profiling.
<p>
By convention, the file to be processed by <tt>stat2resid</tt> has a
<tt>.stat</tt> extension. If the &lt;outfile&gt; is not specified the
PostScript will be written to &lt;file&gt;<tt>.resid.ps</tt>. If
&lt;file&gt; is omitted entirely, then the program behaves as a filter. 
<p>
The plot can not be produced from the statistics file for a
generational collector, though a suitable stats file can be produced
using the <tt>-F2s</tt><a name="-F2s RTS option"></a>
 runtime option when the
program has been compiled for generational garbage collection (the
default).
<p>
<tt>stat2resid</tt> is distributed in <tt>ghc/utils/stat2resid</tt>.

<a name="stat2resid (utility)"></a>
<a name="GC stats---residency info"></a>
<a name="residency, from GC stats"></a>
<a name="stat2resid"></a>
<a name="-S RTS option"></a>
<a name="-F2s RTS option"></a>



<p>

<a name="heap profiles, producing"></a>




<p>

<a name="glasgow-exts"><h2>Glasgow extensions to Haskell</h2></a>
<a name="Haskell, Glasgow extensions"></a>
<p>
<a name="extensions, Glasgow Haskell"></a>
<p>
As with all known Haskell systems, GHC implements some extensions to
the language.
To use them, you'll need to give
a <tt>-fglasgow-exts</tt>
<a name="-fglasgow-exts option"></a>
 option.
<p>
Virtually all of the Glasgow extensions serve to give you access to the
underlying facilities with which we implement Haskell.  Thus, you can
get at the Raw Iron, if you are willing to write some non-standard
code at a more primitive level.  You need not be "stuck" on
performance because of the implementation costs of Haskell's
"high-level" features -- you can always code "under" them.  In an
extreme case, you can write all your time-critical code in C, and then
just glue it together with Haskell!
<p>
Executive summary of our extensions:
<dl>
<dt>Unboxed types and primitive operations:
<dd>You can get right down
to the raw machine types and operations; included in this are
"primitive arrays" (direct access to Big Wads of Bytes).
Please see Chapter <a href="#glasgow-unboxed">glasgow-unboxed</a> and following.
<p>
<dt>Calling out to C:
<dd>Just what it sounds like.  We provide <i>lots</i> of rope that you can dangle around your neck.
Please see Chapter <a href="#glasgow-ccalls">glasgow-ccalls</a>.
<p>
<dt>"Monadic I/O:"
<dd>This stuff will be coming to you For Real
with Haskell 1.3, whenever that is.
Please see Chapter <a href="#io-1-3">io-1-3</a> (the "1.3 I/O" section).
<p>
<dt>"HBC-ish" extensions:
<dd>Extensions implemented because people said,
"HBC does Y.  Could you teach GHC to do the same?"  Please see
Chapter <a href="#glasgow-hbc-exts">glasgow-hbc-exts</a> for a quick list.
</dl>
<p>
Before you get too carried away working at the lowest level (e.g.,
sloshing <tt>MutableByteArray#</tt>s around your program), you may wish to
check if there are system libraries that provide a "Haskellised
veneer" over the features you want.  See Part <a href="#syslibs">syslibs</a>.
<p>
The definitive guide for many of the low-level facilities in GHC is
the "state interface document" (distributed in
<tt>ghc/docs/state-interface.dvi</tt>).  We do not repeat its details here.
<p>

<a name="Haskell, Glasgow extensions"></a>
<a name="extensions, Glasgow Haskell"></a>
<a name="-fglasgow-exts option"></a>
<a name="glasgow-unboxed"><h3>Unboxed types</h3></a>
<a name="Unboxed types (Glasgow extension)"></a>
<p>
These types correspond to the "raw machine" types you would use in
C: <tt>Int#</tt> (long int), <tt>Double#</tt> (double),
<tt>Addr#</tt> (void *), etc.  The <i>primitive
operations</i> (PrimOps) on these types are what you might expect; e.g.,
<tt>(+#)</tt> is addition on <tt>Int#</tt>s, and is the machine-addition that
we all know and love -- usually one instruction.
<p>
A numerically-intensive program using unboxed types can go a <i>lot</i>
faster than its "standard" counterpart -- we saw a threefold speedup
on one example.
<p>
Please see the very first part of the "state interface document"
(distributed in <tt>ghc/docs/state-interface.dvi</tt>) for the details of
unboxed types and the operations on them.
<p>

<a name="Unboxed types (Glasgow extension)"></a>
<a name="glasgow-ST-monad"><h3>Primitive state-transformer monad</h3></a>
<a name="state transformers (Glasgow extensions)"></a>
<p>
This monad underlies our implementation of arrays, mutable and immutable,
and our implementation of I/O, including "C calls".
<p>
You probably won't use the monad directly, but you might use all those
other things!
<p>
The "state interface document" defines the state-related types in
sections 1.4 and 1.5, and the monad itself in section 2.1.
<p>

<a name="state transformers (Glasgow extensions)"></a>
<a name="glasgow-prim-arrays"><h3>Primitive arrays, mutable and otherwise</h3></a>
<a name="primitive arrays (Glasgow extension)"></a>
<p>
<a name="arrays, primitive (Glasgow extension)"></a>
<p>
GHC knows about quite a few flavours of Large Swathes of Bytes.
<p>
First, GHC distinguishes between primitive arrays of (boxed) Haskell
objects (type <tt>Array# obj</tt>) and primitive arrays of bytes (type
<tt>ByteArray#</tt>).
<p>
Second, it distinguishes between...
<dl>
<dt>Immutable:
<dd>Arrays that do not change (as with "standard" Haskell arrays); you
can only read from them.  Obviously, they do not need the care and
attention of the state-transformer monad.
<p>
<dt>Mutable:
<dd>Arrays that may be changed or "mutated."  All the operations on them
live within the state-transformer monad and the updates happen <i>in-place</i>.
<p>
<dt>"Static" (in C land):
<dd>A C routine may pass an <tt>Addr#</tt> pointer back into Haskell land.
There are then primitive operations with which you may merrily grab
values over in C land, by indexing off the "static" pointer.
<p>
<dt>"Stable" pointers:
<dd>If, for some reason, you wish to hand a Haskell pointer (i.e., <i>not</i> an unboxed value) to a C routine, you first make the pointer
"stable," so that the garbage collector won't forget that it exists.
That is, GHC provides a safe way to pass Haskell pointers to C.
<p>
Please see Section <a href="#glasgow-stablePtrs">glasgow-stablePtrs</a> for more details.
<p>
<dt>"Malloc" pointers:
<dd>A "malloc" pointer is a safe way to pass a C pointer to Haskell and
have Haskell do the Right Thing when it no longer references the
object.  So, for example, C could pass a large bitmap over to Haskell
and say "please free this memory when you're done with it."
<p>
Please see Section <a href="#glasgow-mallocPtrs">glasgow-mallocPtrs</a> for more details.
</dl>
<p>
See sections 1.4 and 1.6 of the "state interface document" for the
details of all these "primitive array" types and the operations on
them.
<p>

<a name="primitive arrays (Glasgow extension)"></a>
<a name="arrays, primitive (Glasgow extension)"></a>
<a name="glasgow-ccalls"><h3>Calling C directly from Haskell</h3></a>
<a name="C calls (Glasgow extension)"></a>
<p>
<a name="_ccall_ (Glasgow extension)"></a>
<p>
<a name="_casm_ (Glasgow extension)"></a>
<p>
SINCE VERSION 0.22: "Literal-literals", e.g., <tt>"NULL"</tt>, can now
be any `boxed-primitive' type -- they are not automatically taken to be
<tt>_Addr</tt>s.  This is cool, except you may sometimes have to put in
a type signature to force the desired type.
<p>
SINCE VERSION 0.19: <tt>ccall</tt> and <tt>casm</tt> have been renamed to
<tt>_ccall_</tt> and <tt>_casm_</tt> and <tt>veryDangerousCcall</tt> and
<tt>veryDangerousCasm</tt> have been removed.  It is no longer necessary
(nor legal!) to unbox/rebox the arguments and results to <a href="#_ccall_"><tt>_ccall_</tt></a>.
GHC does the unboxing/reboxing for you.
<p>
GOOD ADVICE: Because this stuff is not Entirely Stable as far as names
and things go, you would be well-advised to keep your C-callery
corraled in a few modules, rather than sprinkled all over your code.
It will then be quite easy to update later on.
<p>
WARNING AS OF 0.26: Yes, the <tt>_ccall_</tt> stuff probably <i>will
change</i>, to something better, of course!  We are only at the
musing-about-it stage, however.
<p>

<a name="C calls (Glasgow extension)"></a>
<a name="_ccall_ (Glasgow extension)"></a>
<a name="_casm_ (Glasgow extension)"></a>
<a name="ccall-intro"><h4><tt>_ccall_</tt> and <tt>_casm_</tt>: an introduction</h4></a>

<p>
The simplest way to use a simple C function

<pre>
double fooC( FILE *in, char c, int i, double d, unsigned int u )
</pre><p>
is to provide a Haskell wrapper

<pre>
fooH :: Char -&gt; Int -&gt; Double -&gt; _Word -&gt; PrimIO Double
fooH c i d w = _ccall_ fooC ``stdin'' c i d w
</pre><p>
The function <a href="#fooH"><tt>fooH</tt></a> will unbox all of its arguments, call the C
function <tt>fooC</tt> and box the corresponding arguments.
<p>
So, if you want to do C-calling, you have to confront the underlying
Glasgow I/O system.  It's just your typical monad whatnot.
<p>
One of the annoyances about <tt>_ccall_</tt>s is when the C types don't quite
match the Haskell compiler's ideas.  For this, the <tt>_casm_</tt> variant
may be just the ticket (NB: <i>no chance</i> of such code going through
a native-code generator):

<pre>
oldGetEnv name
  = _casm_ ``%r = getenv((char *) %0);'' name `thenPrimIO` \ litstring@(A# str#) -&gt;
    returnPrimIO (
        if (litstring == ``NULL'') then
            Failure (SearchError ("GetEnv:"++name))
        else
            Str (unpackCString# str#)
    )
</pre><p>

The first literal-literal argument to a <tt>_casm_</tt> is like a
<tt>printf</tt> format: <tt>%r</tt> is replaced with the "result,"
<tt>%0</tt>--<tt>%n-1</tt> are replaced with the 1st--nth arguments.  As you
can see above, it is an easy way to do simple C casting.  Everything
said about <tt>_ccall_</tt> goes for <tt>_casm_</tt> as well.
<p>

<a name="glasgow-foreign-headers"><h4>Using function headers</h4></a>
<a name="C calls -- function headers"></a>
<p>
When generating C (using the <tt>-fvia-C</tt> directive), one can assist
the C compiler in detecting type errors by using the <tt>-#include</tt>
directive to provide <tt>.h</tt> files containing function headers.
<p>
For example,

<a name="C calls---function headers"></a>
<pre>
typedef unsigned long *StgMallocPtr;
typedef long StgInt;

extern void          initialiseEFS PROTO( (StgInt size) );
extern StgInt        terminateEFS ();
extern StgMallocPtr  emptyEFS();
extern StgMallocPtr  updateEFS PROTO( (StgMallocPtr a, StgInt i, StgInt x) );
extern StgInt        lookupEFS PROTO( (StgMallocPtr a, StgInt i) );
</pre><p>

You can find appropriate definitions for <tt>StgInt</tt>,
<tt>StgMallocPtr</tt>, etc using <tt>gcc</tt> on your architecture by
consulting <tt>ghc/includes/StgTypes.lh</tt>.  The following table
summarises the relationship between Haskell types and C types.
<p>

<pre>
C type name                Haskell Type                
\hline<p><tt>StgChar</tt>  <tt>Char#</tt>              
<tt>StgInt</tt>            <tt>Int#</tt>               
<tt>StgWord</tt>           <tt>Word#</tt>              
<tt>StgAddr</tt>           <tt>Addr#</tt>              
<tt>StgFloat</tt>          <tt>Float#</tt>             
<tt>StgDouble</tt>         <tt>Double#</tt>            
<tt>StgArray</tt>          <tt>Array#</tt>             
<tt>StgByteArray</tt>      <tt>ByteArray#</tt>         
<tt>StgArray</tt>          <tt>MutableArray#</tt>      
<tt>StgByteArray</tt>      <tt>MutableByteArray#</tt>  
<tt>StgStablePtr</tt>      <tt>StablePtr#</tt>         
<tt>StgMallocPtr</tt>      <tt>MallocPtr#</tt>         
</pre>


Note that this approach is only <i>essential</i> for returning
<tt>float</tt>s (or if <tt>sizeof(int) != sizeof(int *)</tt> on your
architecture) but is a Good Thing for anyone who cares about writing
solid code.  You're crazy not to do it.
<p>

<a name="glasgow-stablePtrs"><h4>Subverting automatic unboxing with "stable pointers"</h4></a>
<a name="stable pointers (Glasgow extension)"></a>
<p>
The arguments of a <tt>_ccall_</tt> are automatically unboxed before the
call.  There are two reasons why this is usually the Right Thing to do:
<ul>
<li>C is a strict language: it would be excessively tedious to pass
unevaluated arguments and require the C programmer to force their
evaluation before using them.
<p>
<li>Boxed values are stored on the Haskell heap and may be moved
within the heap if a garbage collection occurs  --  that is, pointers
to boxed objects are not <i>stable</i>.
</ul>
<p>
It is possible to subvert the unboxing process by creating a "stable
pointer" to a value and passing the stable pointer instead.  (To use
stable pointers, you must <tt>import PreludeGlaMisc</tt>.) For example, to
pass/return an integer lazily to C functions <tt>storeC</tt> and
<tt>fetchC</tt>, one might write:

<a name="stable pointers (Glasgow extension)"></a>
<pre>
storeH :: Int -&gt; PrimIO ()
storeH x = makeStablePtr x              `thenPrimIO` \ stable_x -&gt;
           _ccall_ storeC stable_x

fetchH :: PrimIO Int
fetchH x = _ccall_ fetchC               `thenPrimIO` \ stable_x -&gt;
           deRefStablePtr stable_x      `thenPrimIO` \ x -&gt;
           freeStablePtr stable_x       `seqPrimIO`
           returnPrimIO x
</pre><p>

The garbage collector will refrain from throwing a stable pointer away
until you explicitly call one of the following from C or Haskell.

<pre>
void freeStablePointer( StgStablePtr stablePtrToToss )
freeStablePtr :: _StablePtr a -&gt; PrimIO ()
</pre><p>

As with the use of <tt>free</tt> in C programs, GREAT CARE SHOULD BE
EXERCISED to ensure these functions are called at the right time: too
early and you get dangling references (and, if you're lucky, an error
message from the runtime system); too late and you get space leaks.
<p>

<a name="glasgow-mallocPtrs"><h4>Pointing outside the Haskell heap</h4></a>
<a name="malloc pointers (Glasgow extension)"></a>
<p>
There are two types that <tt>ghc</tt> programs can use to reference
(heap-allocated) objects outside the Haskell world: <tt>_Addr</tt> and
<tt>_MallocPtr</tt>.  (You must import <tt>PreludeGlaMisc</tt> to use
<tt>_MallocPtr</tt>.)
<p>
If you use <tt>_Addr</tt>, it is up to you to the programmer to arrange
allocation and deallocation of the objects.
<p>
If you use <tt>_MallocPtr</tt>, <tt>ghc</tt>'s garbage collector will
call the user-supplied C function

<a name="malloc pointers (Glasgow extension)"></a>
<pre>
void FreeMallocPtr( StgMallocPtr garbageMallocPtr )
</pre><p>
when the Haskell world can no longer access the object.  Since
<tt>_MallocPtr</tt>s only get released when a garbage collection occurs,
we provide ways of triggering a garbage collection from within C and
from within Haskell.

<pre>
void StgPerformGarbageCollection()
performGC :: PrimIO ()
</pre><p>

<p>

<a name="glasgow-avoiding-monads"><h4>Avoiding monads</h4></a>
<a name="C calls to `pure C'"></a>
<p>
<a name="unsafePerformPrimIO (PreludeGlaST)"></a>
<p>
The <tt>_ccall_</tt> construct is part of the <tt>PrimIO</tt> monad because 9
out of 10 uses will be to call imperative functions with side effects
such as <tt>printf</tt>.  Use of the monad ensures that these operations
happen in a predictable order in spite of laziness and compiler
optimisations.
<p>
There are three situations where one might like to use
<a href="#unsafePerformPrimIO"><tt>unsafePerformPrimIO</tt></a> to avoid the monad:
<ul>
<li>Calling a function with no side-effects:

<a name="C calls to `pure C'"></a>
<a name="unsafePerformPrimIO (PreludeGlaST)"></a>
<pre>
atan2d :: Double -&gt; Double -&gt; Double
atan2d y x = unsafePerformPrimIO (_ccall_ atan2d y x)

sincosd :: Double -&gt; (Double, Double)
sincosd x = unsafePerformPrimIO (
        newDoubleArray (0, 1)           `thenPrimIO` \ da -&gt;
        _casm_ ``sincosd( %0, &amp;((double *)%1[0]), &amp;((double *)%1[1]) );'' x da
                                        `seqPrimIO`
        readDoubleArray da 0            `thenPrimIO` \ s -&gt;
        readDoubleArray da 1            `thenPrimIO` \ c -&gt;
        returnPrimIO (s, c)
        )
</pre><p>

<li>Calling a set of functions which have side-effects but which can
be used in a purely functional manner.
<p>
For example, an imperative implementation of a purely functional
lookup-table might be accessed using the following functions.
<p>

<pre>
empty :: EFS x
update :: EFS x -&gt; Int -&gt; x -&gt; EFS x
lookup :: EFS a -&gt; Int -&gt; a

empty = unsafePerformPrimIO (_ccall_ emptyEFS)

update a i x = unsafePerformPrimIO (
        makeStablePtr x         `thenPrimIO` \ stable_x -&gt;
        _ccall_ updateEFS a i stable_x
        )

lookup a i = unsafePerformPrimIO (
        _ccall_ lookupEFS a i   `thenPrimIO` \ stable_x -&gt;
        deRefStablePtr stable_x
        )
</pre><p>

You will almost always want to use <tt>_MallocPtr</tt>s with this.
<p>
<li>Calling a side-effecting function even though the results will
be unpredictable.  For example the <tt>trace</tt> function is defined by:
<p>

<pre>
trace :: String -&gt; a -&gt; a
trace string expr = unsafePerformPrimIO (
                  appendChan# ``stderr'' "Trace On:\n"          `seqPrimIO`
                  appendChan# ``stderr'' string                 `seqPrimIO`
                  appendChan# ``stderr'' "\nTrace Off.\n"       `seqPrimIO`
                  returnPrimIO expr )
</pre><p>

(This kind of use is not highly recommended  --  it is only really
useful in debugging code.)
<p>
</ul>
<p>

<a name="ccall-gotchas"><h4>C-calling "gotchas" checklist</h4></a>
<a name="C call dangers"></a>
<p>
And some advice, too.
<p>
<ul>
<li><tt>_ccall_</tt> is part of the <tt>PrimIO</tt> monad  --  not the 1.3 <tt>IO</tt> Monad.
Use the function 

<a name="C call dangers"></a>
<pre>
primIOToIO :: PrimIO a -&gt; IO a
</pre><p>
to promote a <tt>_ccall_</tt> to the <tt>IO</tt> monad.
<p>
<li>For modules that use <tt>_ccall_</tt>s, etc., compile with <tt>-fvia-C</tt>.<a name="-fvia-C option"></a>
<p>
You don't have to, but you should.
<p>
Also, use the <tt>-#include "prototypes.h"</tt> flag (hack) to inform the
C compiler of the fully-prototyped types of all the C functions you
call.  (Section <a href="#glasgow-foreign-headers">glasgow-foreign-headers</a> says more about this...)
<p>
This scheme is the <i>only</i> way that you will get <i>any</i>
typechecking of your <tt>_ccall_</tt>s.  (It shouldn't be that way,
but...)
<p>
<li>Try to avoid <tt>_ccall_</tt>s to C functions that take <tt>float</tt>
arguments or return <tt>float</tt> results.  Reason: if you do, you will
become entangled in (ANSI?) C's rules for when arguments/results are
promoted to <tt>doubles</tt>.  It's a nightmare and just not worth it.
Use <tt>doubles</tt> if possible.
<p>
If you do use <tt>floats</tt>, check and re-check that the right thing is
happening.  Perhaps compile with <tt>-keep-hc-file-too</tt> and look at
the intermediate C (<tt>.hc</tt> file).
<p>
<li>The compiler uses two non-standard type-classes when
type-checking the arguments and results of <tt>_ccall_</tt>: the arguments
(respectively result) of <tt>_ccall_</tt> must be instances of the class
<tt>_CCallable</tt> (respectively <tt>_CReturnable</tt>.  (Neither class
defines any methods  --  their only function is to keep the
type-checker happy.)
<p>
The type checker must be able to figure out just which of the
C-callable/returnable types is being used.  If it can't, you have to
add type signatures. For example,

<a name="-fvia-C option"></a>
<pre>
f x = _ccall_ foo x
</pre><p>
is not good enough, because the compiler can't work out what type <a href="#x"><tt>x</tt></a> is, nor 
what type the <a href="#_ccall_"><tt>_ccall_</tt></a> returns.  You have to write, say:

<pre>
f :: Int -&gt; PrimIO Double
f x = _ccall_ foo x
</pre><p>

This table summarises the standard instances of these classes.
<p>

<pre>
C type name                Haskell Type                
\hline<p><tt>StgChar</tt>  <tt>Char#</tt>              
<tt>StgInt</tt>            <tt>Int#</tt>               
<tt>StgWord</tt>           <tt>Word#</tt>              
<tt>StgAddr</tt>           <tt>Addr#</tt>              
<tt>StgFloat</tt>          <tt>Float#</tt>             
<tt>StgDouble</tt>         <tt>Double#</tt>            
<tt>StgArray</tt>          <tt>Array#</tt>             
<tt>StgByteArray</tt>      <tt>ByteArray#</tt>         
<tt>StgArray</tt>          <tt>MutableArray#</tt>      
<tt>StgByteArray</tt>      <tt>MutableByteArray#</tt>  
<tt>StgStablePtr</tt>      <tt>StablePtr#</tt>         
<tt>StgMallocPtr</tt>      <tt>MallocPtr#</tt>         
Type                        CCallable  CReturnable  Which is probably...               
\hline<p><tt>Char</tt>      Yes        Yes          <tt>unsigned char</tt>             
<tt>Int</tt>                Yes        Yes          <tt>long int</tt>                  
<tt>_Word</tt>              Yes        Yes          <tt>unsigned long int</tt>         
<tt>_Addr</tt>              Yes        Yes          <tt>char *</tt>                    
<tt>Float</tt>              Yes        Yes          <tt>float</tt>                     
<tt>Double</tt>             Yes        Yes          <tt>double</tt>                    
<tt>()</tt>                 No         Yes          <tt>void</tt>                      
<tt>[Char]</tt>             Yes        No           <tt>char *</tt> (null-terminated)  
<tt>Array</tt>              Yes        No           <tt>unsigned long *</tt>           
<tt>_ByteArray</tt>         Yes        No           <tt>unsigned long *</tt>           
<tt>_MutableArray</tt>      Yes        No           <tt>unsigned long *</tt>           
<tt>_MutableByteArray</tt>  Yes        No           <tt>unsigned long *</tt>           
<tt>_State</tt>             Yes        Yes          nothing!                           
<tt>_StablePtr</tt>         Yes        Yes          <tt>unsigned long *</tt>           
<tt>_MallocPtr</tt>         Yes        Yes          see later                          
</pre>


The brave and careful programmer can add their own instances of these
classes for the following types:
<ul>
<li>A <i>boxed-primitive</i> type may be made an instance of both
<tt>_CCallable</tt> and <tt>_CReturnable</tt>.  
<p>
A boxed primitive type is any data type with a
single unary constructor with a single primitive argument.  For
example, the following are all boxed primitive types:
<p>

<pre>
Int
Double
data XDisplay = XDisplay Addr#
data EFS a = EFS# MallocPtr#
</pre><p>


<pre>
instance _CCallable   (EFS a)
instance _CReturnable (EFS a)
</pre><p>

<li>Any datatype with a single nullary constructor may be made an
instance of <tt>_CReturnable</tt>.  For example:
<p>

<pre>
data MyVoid = MyVoid
instance _CReturnable MyVoid
</pre><p>

<li>As at version 0.26, <tt>String</tt> (i.e., <tt>[Char]</tt>) is still
not a <tt>_CReturnable</tt> type.
<p>
Also, the now-builtin type <tt>_PackedString</tt> is neither
<tt>_CCallable</tt> nor <tt>_CReturnable</tt>.  (But there are functions in
the PackedString interface to let you get at the necessary bits...)
</ul>
<p>
<li>The code-generator will complain if you attempt to use <tt>%r</tt>
in a <tt>_casm_</tt> whose result type is <tt>PrimIO ()</tt>; or if you don't
use <tt>%r</tt> <i>precisely</i> once for any other result type.  These
messages are supposed to be helpful and catch bugs -- please tell us
if they wreck your life.
<p>
<li>If you call out to C code which may trigger the Haskell garbage
collector (examples of this later...), then you must use the
<tt>_ccall_GC_</tt> or <tt>_casm_GC_</tt> variant of C-calls.  (This does not
work with the native code generator - use <tt>\fvia-C</tt>.) This stuff is
hairy with a capital H!
</ul>
<p>

<a name="glasgow-hbc-exts"><h3>"HBC-ish" extensions implemented by GHC</h3></a>
<a name="HBC-like Glasgow extensions"></a>
<p>
<a name="extensions, HBC-like"></a>
<p>
<dl>
<p>
<dt><a href="#fromInt"><tt>fromInt</tt></a> method in class <a href="#Num"><tt>Num</tt></a>:
<dd>It's there.  Converts from an <tt>Int</tt> to the type.
<p>
<dt><a href="#toInt"><tt>toInt</tt></a> method in class <a href="#Integral"><tt>Integral</tt></a>:
<dd>Converts from type type to an <tt>Int</tt>.
<p>
<dt>Overlapping instance declarations:
<dd><a name="overlapping instances"></a>
<p>
<a name="instances, overlapping"></a>
<p>
In <tt>instance &lt;context&gt; =&gt; Class (T x1 ... xn)</tt>, the <tt>xi</tt>s can be
<i>types</i>, rather than just <i>type variables</i>.
<p>
Thus, you can have an instance <tt>instance Foo [Char]</tt>, as well as
the more general <tt>instance Foo [a]</tt>; the former will be used in
preference to the latter, where applicable.
<p>
As Lennart says, "This is a dubious feature and should not be used
carelessly."
<p>
See also: <tt>SPECIALIZE instance</tt> pragmas, in Chapter <a href="#faster">faster</a>.
<p>
<dt>Signal-handling I/O request:
<dd><a name="signal handling (extension)"></a>
<p>
<a name="SigAction I/O request"></a>
<p>
The Haskell-1.2 I/O request <tt>SigAction n act</tt> installs a signal handler for signal
<tt>n :: Int</tt>.  The number is the usual UNIX signal number.  The action
is of this type:

<a name="HBC-like Glasgow extensions"></a>
<a name="extensions, HBC-like"></a>
<a name="overlapping instances"></a>
<a name="instances, overlapping"></a>
<a name="signal handling (extension)"></a>
<a name="SigAction I/O request"></a>
<pre>
data SigAct
  = SAIgnore
  | SADefault
  | SACatch Dialogue
</pre><p>

The corresponding continuation-style I/O function is the unsurprising:

<pre>
sigAction :: Int -&gt; SigAct -&gt; FailCont -&gt; SuccCont -&gt; Dialogue
</pre><p>

When a signal handler is installed with <tt>SACatch</tt>, receipt of the
signal causes the current top-level computation to be abandoned, and
the specified dialogue to be executed instead.  The abandoned
computation may leave some partially evaluated expressions in a
non-resumable state.  If you believe that your top-level computation
and your signal handling dialogue may share subexpressions, you should
execute your program with the <tt>-N</tt> RTS option, to prevent
black-holing.
<p>
The <tt>-N</tt> option is not available with concurrent/parallel programs,
so great care should be taken to avoid shared subexpressions between
the top-level computation and any signal handlers when using threads.
<p>
</dl>
<p>





<p>

<a name="syslibs"><h2>System libraries</h2></a>
<a name="system libraries"></a>
<p>
<a name="libraries, system"></a>
<p>
We intend to provide more and more ready-to-use Haskell code, so that
every program doesn't have to invent everything from scratch.
<p>
At the moment, we supply a part of the HBC library, as well as the
beginnings of one of our own ("GHC library").
<p>
If you provide a <tt>-syslib &lt;name&gt;</tt><a name="-syslib <name> option"></a>
 option,
then the interfaces for that library will come into scope (and may be
<tt>import</tt>ed), and the code will be added in at link time.
<p>

<a name="system libraries"></a>
<a name="libraries, system"></a>
<a name="-syslib <name> option"></a>
<a name="GHC-library"><h3>The GHC system library</h3></a>
<a name="library, GHC"></a>
<p>
<a name="GHC library"></a>
<p>
We have started to put together a "GHC system library."
<p>
At the moment, the library is made of generally-useful bits of the
compiler itself.
<p>
To use this library, just give a <tt>-syslib ghc</tt><a name="-syslib ghc option"></a>
<p>
option to GHC, both for compiling and linking.
<p>

<a name="library, GHC"></a>
<a name="GHC library"></a>
<a name="-syslib ghc option"></a>
<a name="Bag"><h4>The <a href="#Bag"><tt>Bag</tt></a> type</h4></a>
<a name="Bag module (GHC syslib)"></a>
<p>
A <i>bag</i> is an unordered collection of elements which may contain
duplicates.  To use, <tt>import Bag</tt>.
<p>

<a name="Bag module (GHC syslib)"></a>
<pre>
emptyBag        :: Bag elt
unitBag         :: elt -&gt; Bag elt

unionBags       :: Bag elt   -&gt; Bag elt -&gt; Bag elt
unionManyBags   :: [Bag elt] -&gt; Bag elt
snocBag         :: Bag elt   -&gt; elt     -&gt; Bag elt

elemBag         :: Eq elt =&gt; elt -&gt; Bag elt -&gt; Bool
isEmptyBag      ::                  Bag elt -&gt; Bool
filterBag       :: (elt -&gt; Bool) -&gt; Bag elt -&gt; Bag elt
partitionBag    :: (elt -&gt; Bool) -&gt; Bag elt-&gt; (Bag elt, Bag elt)
        -- returns the elements that do/don't satisfy the predicate

listToBag       :: [elt] -&gt; Bag elt
bagToList       :: Bag elt -&gt; [elt]
</pre><p>

<p>

<a name="BitSet"><h4>The <a href="#BitSet"><tt>BitSet</tt></a> type</h4></a>
<a name="BitSet module (GHC syslib)"></a>
<p>
Bit sets are a fast implementation of sets of integers ranging from 0
to one less than the number of bits in a machine word (typically 31).
If any element exceeds the maximum value for a particular machine
architecture, the results of these operations are undefined.  You have
been warned.  ["If you put any safety checks in this code, I will have
to kill you." --JSM]
<p>

<a name="BitSet module (GHC syslib)"></a>
<pre>
mkBS        :: [Int]  -&gt; BitSet
listBS      :: BitSet -&gt; [Int]
emptyBS     :: BitSet 
singletonBS :: Int    -&gt; BitSet

unionBS     :: BitSet -&gt; BitSet -&gt; BitSet
minusBS     :: BitSet -&gt; BitSet -&gt; BitSet
elementBS   :: Int    -&gt; BitSet -&gt; Bool
intersectBS :: BitSet -&gt; BitSet -&gt; BitSet

isEmptyBS   :: BitSet -&gt; Bool
</pre><p>

<p>

<a name="FiniteMap"><h4>The <a href="#FiniteMap"><tt>FiniteMap</tt></a> type</h4></a>
<a name="FiniteMap module (GHC syslib)"></a>
<p>
What functional programmers call a <i>finite map</i>, everyone else
calls a <i>lookup table</i>.
<p>
Out code is derived from that in this paper:
<p><pre>
S Adams
"Efficient sets: a balancing act"
Journal of functional programming 3(4) Oct 1993, pages 553-562

<a name="FiniteMap module (GHC syslib)"></a>
</pre><p>
Guess what?  The implementation uses balanced trees.
<p>

<pre>
--      BUILDING
emptyFM         :: FiniteMap key elt
singletonFM     :: key -&gt; elt -&gt; FiniteMap key elt
listToFM        :: Ord key =&gt; [(key,elt)] -&gt; FiniteMap key elt
                        -- In the case of duplicates, the last is taken

--      ADDING AND DELETING
                   -- Throws away any previous binding
                   -- In the list case, the items are added starting with the
                   -- first one in the list
addToFM         :: Ord key =&gt; FiniteMap key elt -&gt; key -&gt; elt  -&gt; FiniteMap key elt
addListToFM     :: Ord key =&gt; FiniteMap key elt -&gt; [(key,elt)] -&gt; FiniteMap key elt

                   -- Combines with previous binding
addToFM_C       :: Ord key =&gt; (elt -&gt; elt -&gt; elt)
                           -&gt; FiniteMap key elt -&gt; key -&gt; elt  
                           -&gt; FiniteMap key elt
addListToFM_C   :: Ord key =&gt; (elt -&gt; elt -&gt; elt)
                           -&gt; FiniteMap key elt -&gt; [(key,elt)] 
                           -&gt; FiniteMap key elt

                   -- Deletion doesn't complain if you try to delete something
                   -- which isn't there
delFromFM       :: Ord key =&gt; FiniteMap key elt -&gt; key   -&gt; FiniteMap key elt
delListFromFM   :: Ord key =&gt; FiniteMap key elt -&gt; [key] -&gt; FiniteMap key elt

--      COMBINING
                   -- Bindings in right argument shadow those in the left
plusFM          :: Ord key =&gt; FiniteMap key elt -&gt; FiniteMap key elt
                           -&gt; FiniteMap key elt

                   -- Combines bindings for the same thing with the given function
plusFM_C        :: Ord key =&gt; (elt -&gt; elt -&gt; elt) 
                           -&gt; FiniteMap key elt -&gt; FiniteMap key elt -&gt; FiniteMap key elt

minusFM         :: Ord key =&gt; FiniteMap key elt -&gt; FiniteMap key elt -&gt; FiniteMap key elt
                   -- (minusFM a1 a2) deletes from a1 any bindings which are bound in a2

intersectFM     :: Ord key =&gt; FiniteMap key elt -&gt; FiniteMap key elt -&gt; FiniteMap key elt 
intersectFM_C   :: Ord key =&gt; (elt -&gt; elt -&gt; elt)
                           -&gt; FiniteMap key elt -&gt; FiniteMap key elt -&gt; FiniteMap key elt 

--      MAPPING, FOLDING, FILTERING
foldFM          :: (key -&gt; elt -&gt; a -&gt; a) -&gt; a -&gt; FiniteMap key elt -&gt; a
mapFM           :: (key -&gt; elt1 -&gt; elt2) -&gt; FiniteMap key elt1 -&gt; FiniteMap key elt2
filterFM        :: Ord key =&gt; (key -&gt; elt -&gt; Bool) 
                           -&gt; FiniteMap key elt -&gt; FiniteMap key elt

--      INTERROGATING
sizeFM          :: FiniteMap key elt -&gt; Int
isEmptyFM       :: FiniteMap key elt -&gt; Bool

elemFM          :: Ord key =&gt; key -&gt; FiniteMap key elt -&gt; Bool
lookupFM        :: Ord key =&gt; FiniteMap key elt -&gt; key -&gt; Maybe elt
lookupWithDefaultFM
                :: Ord key =&gt; FiniteMap key elt -&gt; elt -&gt; key -&gt; elt
                -- lookupWithDefaultFM supplies a "default" elt
                -- to return for an unmapped key

--      LISTIFYING
fmToList        :: FiniteMap key elt -&gt; [(key,elt)]
keysFM          :: FiniteMap key elt -&gt; [key]
eltsFM          :: FiniteMap key elt -&gt; [elt]
</pre><p>

<p>

<a name="ListSetOps"><h4>The <a href="#ListSetOps"><tt>ListSetOps</tt></a> type</h4></a>
<a name="ListSetOps module (GHC syslib)"></a>
<p>
Just a few set-sounding operations on lists.  If you want sets, use
the <tt>Set</tt> module.
<p>

<a name="ListSetOps module (GHC syslib)"></a>
<pre>
unionLists          :: Eq a =&gt; [a] -&gt; [a] -&gt; [a]
intersectLists      :: Eq a =&gt; [a] -&gt; [a] -&gt; [a]
minusList           :: Eq a =&gt; [a] -&gt; [a] -&gt; [a]
disjointLists       :: Eq a =&gt; [a] -&gt; [a] -&gt; Bool
intersectingLists   :: Eq a =&gt; [a] -&gt; [a] -&gt; Bool
</pre><p>

<p>

<a name="Maybes"><h4>The <a href="#Maybes"><tt>Maybes</tt></a> type</h4></a>
<a name="Maybes module (GHC syslib)"></a>
<p>
Note: a <tt>Maybe</tt> type is nearly inevitable in Haskell 1.3.
You should use this module with <tt>-fhaskell-1.3</tt>.
<p>
Two non-abstract types:

<a name="Maybes module (GHC syslib)"></a>
<pre>
data Maybe    a       = Nothing       | Just a -- Prelude; re-exported
data MaybeErr val err = Succeeded val | Failed err
</pre><p>

Some operations to do with <tt>Maybe</tt> (some commentary follows):

<pre>
maybeToBool :: Maybe a -&gt; Bool      -- Nothing =&gt; False; Just =&gt; True
catMaybes   :: [Maybe a] -&gt; [a]
allMaybes   :: [Maybe a] -&gt; Maybe [a]
firstJust   :: [Maybe a] -&gt; Maybe a
findJust    :: (a -&gt; Maybe b) -&gt; [a] -&gt; Maybe b

assocMaybe  :: Eq a =&gt; [(a,b)] -&gt; a -&gt; Maybe b
mkLookupFun :: (key -&gt; key -&gt; Bool) -- Equality predicate
            -&gt; [(key,val)]          -- The assoc list
            -&gt; (key -&gt; Maybe val)   -- A lookup fun to use

    -- a monad thing
thenMaybe   :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b
returnMaybe :: a -&gt; Maybe a
failMaybe   :: Maybe a
mapMaybe    :: (a -&gt; Maybe b) -&gt; [a] -&gt; Maybe [b]
</pre><p>

<a href="#catMaybes"><tt>catMaybes</tt></a> takes a list of <a href="#Maybe"><tt>Maybe</tt></a>s and returns a list of the
contents of all the <a href="#Just"><tt>Just</tt></a>s in it.
<p>
<a href="#allMaybes"><tt>allMaybes</tt></a> collects a list of <a href="#Justs"><tt>Justs</tt></a> into a single <a href="#Just"><tt>Just</tt></a>, returning
<a href="#Nothing"><tt>Nothing</tt></a> if there are any <a href="#Nothings"><tt>Nothings</tt></a>.
<p>
<a href="#firstJust"><tt>firstJust</tt></a> takes a list of <a href="#Maybes"><tt>Maybes</tt></a> and returns the
first <a href="#Just"><tt>Just</tt></a> if there is one, or <a href="#Nothing"><tt>Nothing</tt></a> otherwise.
<p>
<a href="#assocMaybe"><tt>assocMaybe</tt></a> looks up in an association list, returning
<a href="#Nothing"><tt>Nothing</tt></a> if it fails.
<p>
Now, some operations to do with <tt>MaybeErr</tt> (comments follow):

<pre>
    -- a monad thing (surprise, surprise)
thenMaB   :: MaybeErr a err -&gt; (a -&gt; MaybeErr b err) -&gt; MaybeErr b err
returnMaB :: val -&gt; MaybeErr val err
failMaB   :: err -&gt; MaybeErr val err

listMaybeErrs :: [MaybeErr val err] -&gt; MaybeErr [val] [err]
foldlMaybeErrs :: (acc -&gt; input -&gt; MaybeErr acc err)
               -&gt; acc
               -&gt; [input]
               -&gt; MaybeErr acc [err]
</pre><p>

<a href="#listMaybeErrs"><tt>listMaybeErrs</tt></a> takes a list of <a href="#MaybeErrs"><tt>MaybeErrs</tt></a> and, if they all succeed,
returns a <a href="#Succeeded"><tt>Succeeded</tt></a> of a list of their values.  If any fail, it
returns a <a href="#Failed"><tt>Failed</tt></a> of the list of all the errors in the list.
<p>
<a href="#foldlMaybeErrs"><tt>foldlMaybeErrs</tt></a> works along a list, carrying an accumulator; it
applies the given function to the accumulator and the next list item,
accumulating any errors that occur.
<p>

<a name="PackedString"><h4>The <a href="#_PackedString"><tt>_PackedString</tt></a> type</h4></a>
<a name="PackedString module (GHC syslib)"></a>
<p>
The type <tt>_PackedString</tt> is built-in, i.e., no
special action (other than a <tt>-fglasgow-exts</tt> flag) is required to
use it.
<p>
The documentation here describes the <i>built-in</i> functions.
<p>
You may also access this code as a system library and <i>not</i> use
the <tt>-fglasgow-exts</tt> flag.  Just do <tt>import PackedString</tt>,
heave in your <tt>-syslib ghc</tt>, and drop off the leading underscores
which you see here.
<p>
We still may change this interface (again).
<p>
The basic type and functions which are available are:

<a name="PackedString module (GHC syslib)"></a>
<pre>
data _PackedString

_packString      :: [Char] -&gt; _PackedString
_packStringST    :: [Char] -&gt; _ST s _PackedString
_packCString     :: _Addr  -&gt; _PackedString
_packCBytes      :: Int -&gt; _Addr -&gt; _PackedString
_packCBytesST    :: Int -&gt; _Addr -&gt; _ST s _PackedString
_packBytesForC   :: [Char] -&gt; _ByteArray Int
_packBytesForCST :: [Char] -&gt; _ST s (_ByteArray Int)
_byteArrayToPS   :: _ByteArray Int -&gt; _PackedString
_psToByteArray   :: _PackedString -&gt; _ByteArray Int

_unpackPS        :: _PackedString -&gt; [Char]
</pre><p>

We also provide a wad of list-manipulation-like functions:

<pre>
_nilPS      :: _PackedString
_consPS     :: Char -&gt; _PackedString -&gt; _PackedString

_headPS     :: _PackedString -&gt; Char
_tailPS     :: _PackedString -&gt; _PackedString
_nullPS     :: _PackedString -&gt; Bool
_appendPS   :: _PackedString -&gt; _PackedString -&gt; _PackedString
_lengthPS   :: _PackedString -&gt; Int
_indexPS    :: _PackedString -&gt; Int -&gt; Char
            -- 0-origin indexing into the string
_mapPS      :: (Char -&gt; Char) -&gt; _PackedString -&gt; _PackedString {-or String?-}
_filterPS   :: (Char -&gt; Bool) -&gt; _PackedString -&gt; _PackedString {-or String?-}
_foldlPS    :: (a -&gt; Char -&gt; a) -&gt; a -&gt; _PackedString -&gt; a
_foldrPS    :: (Char -&gt; a -&gt; a) -&gt; a -&gt; _PackedString -&gt; a
_takePS     :: Int -&gt; _PackedString -&gt; _PackedString
_dropPS     :: Int -&gt; _PackedString -&gt; _PackedString
_splitAtPS  :: Int -&gt; _PackedString -&gt; (_PackedString, _PackedString)
_takeWhilePS:: (Char -&gt; Bool) -&gt; _PackedString -&gt; _PackedString
_dropWhilePS:: (Char -&gt; Bool) -&gt; _PackedString -&gt; _PackedString
_spanPS     :: (Char -&gt; Bool) -&gt; _PackedString -&gt; (_PackedString, _PackedString)
_breakPS    :: (Char -&gt; Bool) -&gt; _PackedString -&gt; (_PackedString, _PackedString)
_linesPS    :: _PackedString -&gt; [_PackedString]
_wordsPS    :: _PackedString -&gt; [_PackedString]
_reversePS  :: _PackedString -&gt; _PackedString
_concatPS   :: [_PackedString] -&gt; _PackedString

_substrPS   :: _PackedString -&gt; Int -&gt; Int -&gt; _PackedString
            -- pluck out a piece of a _PS
            -- start and end chars you want; both 0-origin-specified
</pre><p>

<p>

<a name="Pretty"><h4>The <a href="#Pretty"><tt>Pretty</tt></a> type</h4></a>
<a name="Pretty module (GHC syslib)"></a>
<p>
This is the pretty-printer that we use in GHC.
<p>

<a name="Pretty module (GHC syslib)"></a>
<pre>
type Pretty

ppShow          :: Int{-width-} -&gt; Pretty -&gt; [Char]

pp'SP           :: Pretty -- "comma space"
ppComma         :: Pretty -- ,
ppEquals        :: Pretty -- =
ppLbrack        :: Pretty -- [
ppLparen        :: Pretty -- (
ppNil           :: Pretty -- nothing
ppRparen        :: Pretty -- )
ppRbrack        :: Pretty -- ]
ppSP            :: Pretty -- space
ppSemi          :: Pretty -- ;

ppChar          :: Char -&gt; Pretty
ppDouble        :: Double -&gt; Pretty
ppFloat         :: Float -&gt; Pretty
ppInt           :: Int -&gt; Pretty
ppInteger       :: Integer -&gt; Pretty
ppRational      :: Rational -&gt; Pretty
ppStr           :: [Char] -&gt; Pretty

ppAbove         :: Pretty -&gt; Pretty -&gt; Pretty
ppAboves        :: [Pretty] -&gt; Pretty
ppBeside        :: Pretty -&gt; Pretty -&gt; Pretty
ppBesides       :: [Pretty] -&gt; Pretty
ppCat           :: [Pretty] -&gt; Pretty
ppHang          :: Pretty -&gt; Int -&gt; Pretty -&gt; Pretty
ppInterleave    :: Pretty -&gt; [Pretty] -&gt; Pretty -- spacing between
ppIntersperse   :: Pretty -&gt; [Pretty] -&gt; Pretty -- no spacing between
ppNest          :: Int -&gt; Pretty -&gt; Pretty
ppSep           :: [Pretty] -&gt; Pretty
</pre><p>

<p>

<a name="Set"><h4>The <a href="#Set"><tt>Set</tt></a> type</h4></a>
<a name="Set module (GHC syslib)"></a>
<p>
Our implementation of <i>sets</i> (key property: no duplicates) is just
a variant of the <tt>FiniteMap</tt> module.
<p>

<a name="Set module (GHC syslib)"></a>
<pre>
mkSet           :: Ord a =&gt; [a]  -&gt; Set a
setToList       :: Set a -&gt; [a]
emptySet        :: Set a
singletonSet    :: a -&gt; Set a

union           :: Ord a =&gt; Set a -&gt; Set a -&gt; Set a
unionManySets   :: Ord a =&gt; [Set a] -&gt; Set a
intersect       :: Ord a =&gt; Set a -&gt; Set a -&gt; Set a
minusSet        :: Ord a =&gt; Set a -&gt; Set a -&gt; Set a
mapSet          :: Ord a =&gt; (b -&gt; a) -&gt; Set b -&gt; Set a

elementOf       :: Ord a =&gt; a -&gt; Set a -&gt; Bool
isEmptySet      :: Set a -&gt; Bool
</pre><p>

<p>

<a name="Util"><h4>The <a href="#Util"><tt>Util</tt></a> type</h4></a>
<a name="Util module (GHC syslib)"></a>
<p>
Stuff that has been useful to use in writing the compiler.  Don't be
too surprised if this stuff moves/gets-renamed/etc.
<p>

<a name="Util module (GHC syslib)"></a>
<pre>
-- general list processing
forall          :: (a -&gt; Bool) -&gt; [a] -&gt; Bool
exists          :: (a -&gt; Bool) -&gt; [a] -&gt; Bool
zipEqual        :: [a] -&gt; [b] -&gt; [(a,b)]
nOfThem         :: Int -&gt; a -&gt; [a]
lengthExceeds   :: [a] -&gt; Int -&gt; Bool
isSingleton     :: [a] -&gt; Bool

-- association lists
assoc       :: Eq a =&gt; String -&gt; [(a, b)] -&gt; a -&gt; b

-- duplicate handling
hasNoDups    :: Eq a =&gt; [a] -&gt; Bool
equivClasses :: (a -&gt; a -&gt; _CMP_TAG) -&gt; [a] -&gt; [[a]]
runs         :: (a -&gt; a -&gt; Bool)     -&gt; [a] -&gt; [[a]]
removeDups   :: (a -&gt; a -&gt; _CMP_TAG) -&gt; [a] -&gt; ([a], [[a]])

-- sorting (don't complain of no choice...)
quicksort          :: (a -&gt; a -&gt; Bool)     -&gt; [a] -&gt; [a]
sortLt             :: (a -&gt; a -&gt; Bool)     -&gt; [a] -&gt; [a]
stableSortLt       :: (a -&gt; a -&gt; Bool)     -&gt; [a] -&gt; [a]
mergesort          :: (a -&gt; a -&gt; _CMP_TAG) -&gt; [a] -&gt; [a]
mergeSort          :: Ord a =&gt; [a] -&gt; [a]
naturalMergeSort   :: Ord a =&gt; [a] -&gt; [a]
mergeSortLe        :: Ord a =&gt; [a] -&gt; [a]
naturalMergeSortLe :: Ord a =&gt; [a] -&gt; [a]

-- transitive closures
transitiveClosure :: (a -&gt; [a])         -- Successor function
                  -&gt; (a -&gt; a -&gt; Bool)   -- Equality predicate
                  -&gt; [a] 
                  -&gt; [a]                -- The transitive closure

-- accumulating (Left, Right, Bi-directional)
mapAccumL :: (acc -&gt; x -&gt; (acc, y))
                        -- Function of elt of input list and
                        -- accumulator, returning new accumulator and
                        -- elt of result list
          -&gt; acc        -- Initial accumulator
          -&gt; [x]        -- Input list
          -&gt; (acc, [y]) -- Final accumulator and result list

mapAccumR :: (acc -&gt; x -&gt; (acc, y)) -&gt; acc -&gt; [x] -&gt; (acc, [y])

mapAccumB :: (accl -&gt; accr -&gt; x -&gt; (accl, accr,y))
          -&gt; accl -&gt; accr -&gt; [x]
          -&gt; (accl, accr, [y])

-- comparisons
cmpString :: String -&gt; String -&gt; _CMP_TAG

-- this type is built-in
data _CMP_TAG = _LT | _EQ | _GT

-- pairs
applyToPair :: ((a -&gt; c), (b -&gt; d)) -&gt; (a, b) -&gt; (c, d)
applyToFst  :: (a -&gt; c) -&gt; (a, b) -&gt; (c, b)
applyToSnd  :: (b -&gt; d) -&gt; (a, b) -&gt; (a, d)
foldPair    :: (a-&gt;a-&gt;a, b-&gt;b-&gt;b) -&gt; (a, b) -&gt; [(a, b)] -&gt; (a, b)
unzipWith   :: (a -&gt; b -&gt; c) -&gt; [(a, b)] -&gt; [c]
</pre><p>

<p>

<a name="C-interfaces"><h3>Interfaces to C libraries</h3></a>
<a name="C library interfaces"></a>
<p>
<a name="interfaces, C library"></a>
<p>
The GHC system library (<tt>-syslib ghc</tt>) also provides interfaces to
several useful C libraries, mostly from the GNU project.
<p>

<a name="C library interfaces"></a>
<a name="interfaces, C library"></a>
<a name="Readline"><h4>The <a href="#Readline"><tt>Readline</tt></a> interface</h4></a>
<a name="Readline library (GHC syslib)"></a>
<p>
<a name="command-line editing library"></a>
<p>
(Darren Moffat supplied the <tt>Readline</tt> interface.)
<p>
The <tt>Readline</tt> module is a straightforward interface to the GNU
Readline library.  As such, you will need to look at the GNU
documentation (and have a <tt>libreadline.a</tt> file around somewhere...)
<p>
You'll need to link any Readlining program with <tt>-lreadline -ltermcap</tt>,
besides the usual <tt>-syslib ghc</tt> (and <tt>-fhaskell-1.3</tt>).
<p>
The main function you'll use is:

<a name="Readline library (GHC syslib)"></a>
<a name="command-line editing library"></a>
<pre>
readline :: String{-the prompt-} -&gt; IO String
</pre><p>

If you want to mess around with Full Readline G(l)ory, we also
provide:

<pre>
rlInitialize, addHistory,

rlBindKey, rlAddDefun, RlCallbackFunction(..),

rlGetLineBuffer, rlSetLineBuffer, rlGetPoint, rlSetPoint, rlGetEnd,
rlSetEnd, rlGetMark, rlSetMark, rlSetDone, rlPendingInput,

rlPrompt, rlTerminalName, rlSetReadlineName, rlGetReadlineName
</pre><p>
(All those names are just Haskellised versions of what you
will see in the GNU readline documentation.)
<p>

<a name="Regexp"><h4>The <a href="#Regexp"><tt>Regexp</tt></a> and <a href="#MatchPS"><tt>MatchPS</tt></a> interfaces</h4></a>
<a name="Regex library (GHC syslib)"></a>
<p>
<a name="MatchPS library (GHC syslib)"></a>
<p>
<a name="regular-expressions library"></a>
<p>
(Sigbjorn Finne supplied the regular-expressions interface.)
<p>
The <tt>Regex</tt> library provides quite direct interface to the GNU
regular-expression library, for doing manipulation on
<tt>_PackedString</tt>s.  You probably need to see the GNU documentation
if you are operating at this level.
<p>
The datatypes and functions that <tt>Regex</tt> provides are:

<a name="Regex library (GHC syslib)"></a>
<a name="MatchPS library (GHC syslib)"></a>
<a name="regular-expressions library"></a>
<pre>
data PatBuffer  # just a bunch of bytes (mutable)

data REmatch
 = REmatch (Array Int GroupBounds)  -- for $1, ... $n
           GroupBounds              -- for $` (everything before match)
           GroupBounds              -- for $&amp; (entire matched string)
           GroupBounds              -- for $' (everything after)
           GroupBounds              -- for $+ (matched by last bracket)

-- GroupBounds hold the interval where a group
-- matched inside a string, e.g.
--
-- matching "reg(exp)" "a regexp" returns the pair (5,7) for the
-- (exp) group. (_PackedString indices start from 0)

type GroupBounds = (Int, Int)

re_compile_pattern
        :: _PackedString        -- pattern to compile
        -&gt; Bool                 -- True &lt;=&gt; assume single-line mode
        -&gt; Bool                 -- True &lt;=&gt; case-insensitive
        -&gt; PrimIO PatBuffer

re_match :: PatBuffer           -- compiled regexp
         -&gt; _PackedString       -- string to match
         -&gt; Int                 -- start position
         -&gt; Bool                -- True &lt;=&gt; record results in registers
         -&gt; PrimIO (Maybe REmatch)

-- Matching on 2 strings is useful when you're dealing with multiple
-- buffers, which is something that could prove useful for
-- PackedStrings, as we don't want to stuff the contents of a file
-- into one massive heap chunk, but load (smaller chunks) on demand.

re_match2 :: PatBuffer          -- 2-string version
          -&gt; _PackedString
          -&gt; _PackedString
          -&gt; Int
          -&gt; Int
          -&gt; Bool
          -&gt; PrimIO (Maybe REmatch)

re_search :: PatBuffer          -- compiled regexp
          -&gt; _PackedString      -- string to search
          -&gt; Int                -- start index
          -&gt; Int                -- stop index
          -&gt; Bool               -- True &lt;=&gt; record results in registers
          -&gt; PrimIO (Maybe REmatch)

re_search2 :: PatBuffer         -- Double buffer search
           -&gt; _PackedString
           -&gt; _PackedString
           -&gt; Int               -- start index
           -&gt; Int               -- range (?)
           -&gt; Int               -- stop index
           -&gt; Bool              -- True &lt;=&gt; results in registers
           -&gt; PrimIO (Maybe REmatch)
</pre><p>

The <tt>MatchPS</tt> module provides Perl-like "higher-level" facilities
to operate on <tt>_PackedStrings</tt>.  The regular expressions in
question are in Perl syntax.  The "flags" on various functions can
include: <tt>i</tt> for case-insensitive, <tt>s</tt> for single-line mode, and
<tt>g</tt> for global.  (It's probably worth your time to peruse the
source code...)
<p>

<pre>
matchPS :: _PackedString    -- regexp
        -&gt; _PackedString    -- string to match
        -&gt; [Char]           -- flags
        -&gt; Maybe REmatch    -- info about what matched and where

searchPS :: _PackedString   -- regexp
         -&gt; _PackedString   -- string to match
         -&gt; [Char]          -- flags
         -&gt; Maybe REmatch

-- Perl-like match-and-substitute:
substPS :: _PackedString    -- regexp
        -&gt; _PackedString    -- replacement
        -&gt; [Char]           -- flags
        -&gt; _PackedString    -- string
        -&gt; _PackedString

-- same as substPS, but no prefix and suffix:
replacePS :: _PackedString  -- regexp
          -&gt; _PackedString  -- replacement
          -&gt; [Char]         -- flags
          -&gt; _PackedString  -- string
          -&gt; _PackedString

match2PS :: _PackedString   -- regexp
         -&gt; _PackedString   -- string1 to match
         -&gt; _PackedString   -- string2 to match
         -&gt; [Char]          -- flags
         -&gt; Maybe REmatch

search2PS :: _PackedString  -- regexp
          -&gt; _PackedString  -- string to match
          -&gt; _PackedString  -- string to match
          -&gt; [Char]         -- flags
          -&gt; Maybe REmatch

-- functions to pull the matched pieces out of an REmatch:

getMatchesNo    :: REmatch -&gt; Int
getMatchedGroup :: REmatch -&gt; Int -&gt; _PackedString -&gt; _PackedString
getWholeMatch   :: REmatch -&gt; _PackedString -&gt; _PackedString
getLastMatch    :: REmatch -&gt; _PackedString -&gt; _PackedString
getAfterMatch   :: REmatch -&gt; _PackedString -&gt; _PackedString

-- (reverse) brute-force string matching;
-- Perl equivalent is index/rindex:
findPS, rfindPS :: _PackedString -&gt; _PackedString -&gt; Maybe Int

-- Equivalent to Perl "chop" (off the last character, if any):
chopPS :: _PackedString -&gt; _PackedString

-- matchPrefixPS: tries to match as much as possible of strA starting
-- from the beginning of strB (handy when matching fancy literals in
-- parsers):
matchPrefixPS :: _PackedString -&gt; _PackedString -&gt; Int
</pre><p>

<p>

<a name="Socket"><h4>Network-interface toolkit -- <a href="#Socket"><tt>Socket</tt></a> and <a href="#SocketPrim"><tt>SocketPrim</tt></a></h4></a>
<a name="SocketPrim interface (GHC syslib)"></a>
<p>
<a name="Socket interface (GHC syslib)"></a>
<p>
<a name="network-interface library"></a>
<p>
<a name="sockets library"></a>
<p>
<a name="BSD sockets library"></a>
<p>
(Darren Moffat supplied the network-interface toolkit.)
<p>
Your best bet for documentation is to look at the code -- really! --  
normally in <tt>ghc/lib/ghc/\{BSD,Socket,SocketPrim\}.lhs</tt>.
<p>
The <tt>BSD</tt> module provides functions to get at system-database info;
pretty straightforward if you're into this sort of thing:

<a name="SocketPrim interface (GHC syslib)"></a>
<a name="Socket interface (GHC syslib)"></a>
<a name="network-interface library"></a>
<a name="sockets library"></a>
<a name="BSD sockets library"></a>
<pre>
getHostName         :: IO String

getServiceByName    :: ServiceName -&gt; IO ServiceEntry
getServicePortNumber:: ServiceName -&gt; IO PortNumber
getServiceEntry     :: IO ServiceEntry
setServiceEntry     :: Bool -&gt; IO ()
endServiceEntry     :: IO ()

getProtocolByName   :: ProtocolName -&gt; IO ProtocolEntry
getProtocolByNumber :: ProtocolNumber -&gt; IO ProtcolEntry
getProtocolNumber   :: ProtocolName -&gt; ProtocolNumber
getProtocolEntry    :: IO ProtocolEntry
setProtocolEntry    :: Bool -&gt; IO ()
endProtocolEntry    :: IO ()

getHostByName       :: HostName -&gt; IO HostEntry
getHostByAddr       :: Family -&gt; HostAddress -&gt; IO HostEntry
getHostEntry        :: IO HostEntry
setHostEntry        :: Bool -&gt; IO ()
endHostEntry        :: IO ()
</pre><p>

The <tt>SocketPrim</tt> interface provides quite direct access to the
socket facilities in a BSD Unix system, including all the
complications.  We hope you don't need to use it!  See the source if
needed...
<p>
The <tt>Socket</tt> interface is a "higher-level" interface to sockets,
and it is what we recommend.  Please tell us if the facilities it
offers are inadequate to your task!
<p>
The interface is relatively modest:

<pre>
connectTo       :: Hostname -&gt; PortID -&gt; IO Handle
listenOn        :: PortID -&gt; IO Socket

accept          :: Socket -&gt; IO (Handle, HostName)
sendTo          :: Hostname -&gt; PortID -&gt; String -&gt; IO ()

recvFrom        :: Hostname -&gt; PortID -&gt; IO String
socketPort      :: Socket -&gt; IO PortID

data PortID     -- PortID is a non-abstract type
  = Service String      -- Service Name eg "ftp"
  | PortNumber Int      -- User defined Port Number
  | UnixSocket String   -- Unix family socket in file system

type Hostname = String
</pre><p>

Various examples of networking Haskell code are provided in
<tt>ghc/misc/examples/</tt>, notably the <tt>net???/Main.hs</tt> programs.
<p>

<a name="HBC-library"><h3>The HBC system library</h3></a>
<a name="HBC system library"></a>
<p>
<a name="system library, HBC"></a>
<p>
This documentation is stolen directly from the HBC distribution.  The
modules that GHC does not support (because they require HBC-specific
extensions) are omitted.
<p>
<dl>
<dt><tt>Either</tt>:
<dd><a name="Either module (HBC library)"></a>
<p>
A binary sum data type:

<a name="HBC system library"></a>
<a name="system library, HBC"></a>
<a name="Either module (HBC library)"></a>
<pre>
data Either a b = Left a | Right b
</pre><p>
The constructor <tt>Left</tt> is typically used for errors; it can be
renamed to <tt>Wrong</tt> on import.
<p>
<dt><tt>Maybe</tt>:
<dd><a name="Maybe module (HBC library)"></a>
<p>
A type for failure or success:

<a name="Maybe module (HBC library)"></a>
<pre>
data Maybe a = Nothing | Just a
thenM :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b
    -- apply a function that may fail
</pre><p>

<dt><tt>Option</tt>:
<dd><a name="Option module (HBC library)"></a>
<p>
An alias for <tt>Maybe</tt>:

<a name="Option module (HBC library)"></a>
<pre>
data Option a = None | Some a
thenO :: Option a -&gt; (a -&gt; Option b) -&gt; Option b
</pre><p>

<dt><tt>ListUtil</tt>:
<dd><a name="ListUtil module (HBC library)"></a>
<p>
Various useful functions involving lists that are missing from the
<tt>Prelude</tt>:

<a name="ListUtil module (HBC library)"></a>
<pre>
assoc :: (Eq c) =&gt; (a -&gt; b) -&gt; b -&gt; [(c, a)] -&gt; c -&gt; b
        -- assoc f d l k looks for k in the association list l, if it
        -- is found f is applied to the value, otherwise d is returned.
concatMap :: (a -&gt; [b]) -&gt; [a] -&gt; [b]
        -- flattening map (LML's concmap)
unfoldr :: (a -&gt; (b, a)) -&gt; (a -&gt; Bool) -&gt; a -&gt; [b]
        -- unfoldr f p x repeatedly applies f to x until (p x) holds.
        -- (f x) should give a list element and a new x.
mapAccuml :: (a -&gt; b -&gt; (a, c)) -&gt; a -&gt; [b] -&gt; (a, [c])
        -- mapAccuml f s l maps f over l, but also threads the state s
        -- through (LML's mapstate).
union :: (Eq a) =&gt; [a] -&gt; [a] -&gt; [a]
        -- union of two lists
intersection :: (Eq a) =&gt; [a] -&gt; [a] -&gt; [a]
        -- intersection of two lists
chopList :: ([a] -&gt; (b, [a])) -&gt; [a] -&gt; [b]
        -- LMLs choplist
assocDef :: (Eq a) =&gt; [(a, b)] -&gt; b -&gt; a -&gt; b
        -- LMLs assocdef
lookup :: (Eq a) =&gt; [(a, b)] -&gt; a -&gt; Option b
        -- lookup l k looks for the key k in the association list l
        -- and returns an optional value
tails :: [a] -&gt; [[a]]
        -- return all the tails of a list
rept :: (Integral a) =&gt; a -&gt; b -&gt; [b]
        -- repeat a value a number of times
groupEq :: (a-&gt;a-&gt;Bool) -&gt; [a] -&gt; [[a]]
        -- group list elements according to an equality predicate
group :: (Eq a) =&gt; [a] -&gt; [[a]]
        -- group according to} ==
readListLazily :: (Text a) =&gt; String -&gt; [a]
        -- read a list in a lazy fashion
</pre><p>

<dt><tt>Pretty</tt>:
<dd><a name="Pretty module (HBC library)"></a>
<p>
John Hughes's pretty printing library.  

<a name="Pretty module (HBC library)"></a>
<pre>
type Context = (Bool, Int, Int, Int)
type IText = Context -&gt; [String]
text :: String -&gt; IText                 -- just text
(~.) :: IText -&gt; IText -&gt; IText         -- horizontal composition
(^.) :: IText -&gt; IText -&gt; IText         -- vertical composition
separate :: [IText] -&gt; IText            -- separate by spaces
nest :: Int -&gt; IText -&gt; IText           -- indent
pretty :: Int -&gt; Int -&gt; IText -&gt; String -- format it
</pre><p>

<dt><tt>QSort</tt>:
<dd><a name="QSort module (HBC library)"></a>
<p>
A sort function using quicksort.

<a name="QSort module (HBC library)"></a>
<pre>
sortLe :: (a -&gt; a -&gt; Bool) -&gt; [a] -&gt; [a]
        -- sort le l  sorts l with le as less than predicate
sort :: (Ord a) =&gt; [a] -&gt; [a]
        -- sort l  sorts l using the Ord class
</pre><p>

<dt><tt>Random</tt>:
<dd><a name="Random module (HBC library)"></a>
<p>
Random numbers.

<a name="Random module (HBC library)"></a>
<pre>
randomInts :: Int -&gt; Int -&gt; [Int]
        -- given two seeds gives a list of random Int
randomDoubles :: Int -&gt; Int -&gt; [Double]
        -- random Double with uniform distribution in (0,1)
normalRandomDoubles :: Int -&gt; Int -&gt; [Double]
        -- random Double with normal distribution, mean 0, variance 1
</pre><p>

<dt><tt>Trace</tt>:
<dd>Simple tracing.  (Note: This comes with GHC anyway.)

<pre>
trace :: String -&gt; a -&gt; a       -- trace x y  prints x and returns y
</pre><p>

<dt><tt>Miranda</tt>:
<dd><a name="Miranda module (HBC library)"></a>
<p>
Functions found in the Miranda library.
(Note: Miranda is a registered trade mark of Research Software Ltd.)
<p>
<dt><tt>Word</tt>:
<dd><a name="Word module (HBC library)"></a>
<p>
Bit manipulation.  (GHC doesn't implement absolutely all of this.
And don't count on <a href="#Word"><tt>Word</tt></a> being 32 bits on a Alpha...)

<a name="Miranda module (HBC library)"></a>
<a name="Word module (HBC library)"></a>
<pre>
class Bits a where
    bitAnd :: a -&gt; a -&gt; a       -- bitwise and
    bitOr :: a -&gt; a -&gt; a        -- bitwise or
    bitXor :: a -&gt; a -&gt; a       -- bitwise xor
    bitCompl :: a -&gt; a          -- bitwise negation
    bitRsh :: a -&gt; Int -&gt; a     -- bitwise right shift
    bitLsh :: a -&gt; Int -&gt; a     -- bitwise left shift
    bitSwap :: a -&gt; a           -- swap word halves
    bit0 :: a                   -- word with least significant bit set
    bitSize :: a -&gt; Int         -- number of bits in a word

data Byte                       -- 8  bit quantity
data Short                      -- 16 bit quantity
data Word                       -- 32 bit quantity

instance Bits Byte, Bits Short, Bits Word
instance Eq Byte, Eq Short, Eq Word
instance Ord Byte, Ord Short, Ord Word
instance Text Byte, Text Short, Text Word
instance Num Byte, Num Short, Num Word
wordToShorts :: Word -&gt; [Short]   -- convert a Word to two Short
wordToBytes :: Word -&gt; [Byte]     -- convert a Word to four Byte
bytesToString :: [Byte] -&gt; String -- convert a list of Byte to a String (bit by bit)
wordToInt :: Word -&gt; Int          -- convert a Word to Int
shortToInt :: Short -&gt; Int        -- convert a Short to Int
byteToInt :: Byte -&gt; Int          -- convert a Byte to Int
</pre><p>

<dt><tt>Time</tt>:
<dd><a name="Time module (HBC library)"></a>
<p>
Manipulate time values (a Double with seconds since 1970).

<a name="Time module (HBC library)"></a>
<pre>
--               year mon  day  hour min  sec  dec-sec  weekday
data Time = Time Int  Int  Int  Int  Int  Int  Double  Int
dblToTime :: Double -&gt; Time     -- convert a Double to a Time
timeToDbl :: Time -&gt; Double     -- convert a Time to a Double
timeToString :: Time -&gt; String  -- convert a Time to a readable String
</pre><p>

<dt><tt>Hash</tt>:
<dd><a name="Hash module (HBC library)"></a>
<p>
Hashing functions.

<a name="Hash module (HBC library)"></a>
<pre>
class Hashable a where
    hash :: a -&gt; Int                            -- hash a value, return an Int
-- instances for all Prelude types
hashToMax :: (Hashable a) =&gt; Int -&gt; a -&gt; Int    -- hash into interval [0..x-1]
</pre><p>

<dt><tt>NameSupply</tt>:
<dd><a name="NameSupply module (HBC library)"></a>
<p>
Functions to generate unique names (Int).

<a name="NameSupply module (HBC library)"></a>
<pre>
type Name = Int
initialNameSupply :: NameSupply
        -- The initial name supply (may be different every
        -- time the program is run.
splitNameSupply :: NameSupply -&gt; (NameSupply,NameSupply)
        -- split the namesupply into two
getName :: NameSupply -&gt; Name
        -- get the name associated with a name supply
</pre><p>

<dt><tt>Parse</tt>:
<dd><a name="Parse module (HBC library)"></a>
<p>
Higher order functions to build parsers.  With a little care these
combinators can be used to build efficient parsers with good error
messages.

<a name="Parse module (HBC library)"></a>
<pre>
infixr 8 +.+ , ..+ , +.. 
infix  6 `act` , &gt;&gt;&gt; , `into` , .&gt; 
infixr 4 ||| , ||! , |!! 
data ParseResult a b 
type Parser a b = a -&gt; Int -&gt; ParseResult a b 
(|||) :: Parser a b -&gt; Parser a b -&gt; Parser a b
        -- Alternative
(||!) :: Parser a b -&gt; Parser a b -&gt; Parser a b
        -- Alternative, but with committed choice
(|!!) :: Parser a b -&gt; Parser a b -&gt; Parser a b
        -- Alternative, but with committed choice
(+.+) :: Parser a b -&gt; Parser a c -&gt; Parser a (b,c)
        -- Sequence
(..+) :: Parser a b -&gt; Parser a c -&gt; Parser a c
        -- Sequence, throw away first part
(+..) :: Parser a b -&gt; Parser a c -&gt; Parser a b
        -- Sequence, throw away second part
act   :: Parser a b -&gt; (b-&gt;c) -&gt; Parser a c
        -- Action
(&gt;&gt;&gt;) :: Parser a (b,c) -&gt; (b-&gt;c-&gt;d) -&gt; Parser a d
        -- Action on two items
(.&gt;) :: Parser a b -&gt; c -&gt; Parse a c
        -- Action ignoring value
into :: Parser a b -&gt; (b -&gt; Parser a c) -&gt; Parser a c
        -- Use a produced value in a parser.
succeed b :: Parser a b
        -- Always succeeds without consuming a token
failP :: Parser a b
        -- Always fails.
many :: Parser a b -&gt; Parser a [b]
        -- Kleene star
many1 :: Parser a b -&gt; Parser a [b]
        -- Kleene plus
count :: Parser a b -&gt; Int -&gt; Parser a [b]
        -- Parse an exact number of items
sepBy1 :: Parser a b -&gt; Parser a c -&gt; Parser a [b]
        -- Non-empty sequence of items separated by something
sepBy :: Parser a b -&gt; Parser a c -&gt; Parser a [b]
        -- Sequence of items separated by something
lit :: (Eq a, Text a) =&gt; a -&gt; Parser [a] a
        -- Recognise a literal token from a list of tokens
litp :: String -&gt; (a-&gt;Bool) -&gt; Parser [a] a
        -- Recognise a token with a predicate.
        -- The string is a description for error messages.
testp :: String -&gt; (a -&gt; Bool) -&gt; (Parser b a) -&gt; Parser b a
        -- Test a semantic value. 
token :: (a -&gt; Either String (b, a)) -&gt; Parser a b
        -- General token recogniser.
parse :: Parser a b -&gt; a -&gt; Either ([String], a) [(b, a)]
        -- Do a parse.  Return either error (possible tokens and rest
        -- of tokens) or all possible parses.
sParse :: (Text a) =&gt; (Parser [a] b) -&gt; [a] -&gt; Either String b
        -- Simple parse.  Return error message or result.
</pre><p>

<p>
<dt><tt>Native</tt>:
<dd><a name="Native module (HBC library)"></a>
<p>
Functions to convert the primitive types <tt>Int</tt>, <tt>Float</tt>, and <tt>Double</tt> to
their native representation as a list of bytes (<tt>Char</tt>).  If such a list
is read/written to a file it will have the same format as when, e.g.,
C read/writes the same kind of data.

<a name="Native module (HBC library)"></a>
<pre>
type Bytes = [Char] -- A byte stream is just a list of characters

class Native a where 
    showBytes     :: a -&gt; Bytes -&gt; Bytes
        -- prepend the representation of an item the a byte stream
    listShowBytes :: [a] -&gt; Bytes -&gt; Bytes
        -- prepend the representation of a list of items to a stream
        -- (may be more efficient than repeating showBytes).
    readBytes     :: Bytes -&gt; Maybe (a, Bytes)
        -- get an item from the stream and return the rest,
        -- or fail if the stream is to short.
    listReadBytes :: Int -&gt; Bytes -&gt; Maybe ([a], Bytes)
        -- read n items from a stream.

instance Native Int 
instance Native Float 
instance Native Double 
instance (Native a, Native b) =&gt; Native (a,b)
        -- juxtaposition of the two items
instance (Native a, Native b, Native c) =&gt; Native (a, b, c)
        -- juxtaposition of the three items
instance (Native a) =&gt; Native [a]
        -- an item count in an Int followed by the items

shortIntToBytes :: Int -&gt; Bytes -&gt; Bytes
        -- Convert an Int to what corresponds to a short in C.
bytesToShortInt :: Bytes -&gt; Maybe (Int, Bytes)
        -- Get a short from a byte stream and convert to an Int.

showB :: (Native a) =&gt; a -&gt; Bytes       -- Simple interface to showBytes.
readB :: (Native a) =&gt; Bytes -&gt; a       -- Simple interface to readBytes.
</pre><p>

<dt><tt>Number</tt>:
<dd><a name="Number module (HBC library)"></a>
<p>
Simple numbers that belong to all numeric classes and behave like
a naive user would expect (except that printing is still ugly).
(NB: GHC does not provide a magic way to use <tt>Numbers</tt> everywhere,
but you should be able to do it with normal <tt>import</tt>ing and
<tt>default</tt>ing.)

<a name="Number module (HBC library)"></a>
<pre>
data Number                     -- The type itself.
instance ...                    -- All reasonable instances.
isInteger :: Number -&gt; Bool     -- Test if a Number is an integer.
</pre><p>
</dl>





<p>

<a name="concurrent-and-parallel"><h2>Concurrent and Parallel Haskell</h2></a>
<a name="Concurrent Haskell"></a>
<p>
<a name="Parallel Haskell"></a>
<p>
Concurrent and Parallel Haskell are Glasgow extensions to Haskell
which let you structure your program as a group of independent
`threads'.
<p>
Concurrent and Parallel Haskell have very different purposes.
<p>
Concurrent Haskell is for applications which have an inherent
structure of interacting, concurrent tasks (i.e. `threads').  Threads
in such programs may be <i>required</i>.  For example, if a concurrent
thread has been spawned to handle a mouse click, it isn't
optional -- the user wants something done!
<p>
A Concurrent Haskell program implies multiple `threads' running within
a single Unix process on a single processor.
<p>
Simon Peyton Jones and Sigbjorn Finne have a paper available,
"Concurrent Haskell: preliminary version."
(draft available via <tt>ftp</tt>
from <tt>ftp.dcs.gla.ac.uk/pub/glasgow-fp/drafts</tt>).
<p>
Parallel Haskell is about <i>speed</i> -- spawning threads onto multiple
processors so that your program will run faster.  The `threads'
are always <i>advisory</i> -- if the runtime system thinks it can
get the job done more quickly by sequential execution, then fine.
<p>
A Parallel Haskell program implies multiple processes running on
multiple processors, under a PVM (Parallel Virtual Machine) framework.
<p>
Parallel Haskell was first released with GHC 0.26; it is more about
"research fun" than about "speed." That will change.  There is no
paper about Parallel Haskell.  That will change, too.
<p>
Some details about Concurrent and Parallel Haskell follow.
<p>

<a name="Concurrent Haskell"></a>
<a name="Parallel Haskell"></a>
<a name="parallel_1.1"><h3>Concurrent and Parallel Haskell -- language features</h3></a>
<a name="Concurrent Haskell -- features"></a>
<p>
<a name="Parallel Haskell -- features"></a>
<p>

<a name="Concurrent Haskell---features"></a>
<a name="Parallel Haskell---features"></a>
<a name="parallel_1.1.1"><h4>Features specific to Concurrent Haskell</h4></a>

<p>

<a name="parallel_1.1.1.1"><h5>The <tt>Concurrent</tt> interface (recommended)</h5></a>
<a name="Concurrent interface"></a>
<p>
GHC provides a <tt>Concurrent</tt> module, a common interface to a
collection of useful concurrency abstractions, including those
mentioned in the "concurrent paper".
<p>
Just put <tt>import Concurrent</tt> into your modules, and away you go.
NB: intended for use with the <tt>-fhaskell-1.3</tt> flag.
<p>
To create a "required thread":
<p>

<a name="Concurrent interface"></a>
<pre>
forkIO :: IO a -&gt; IO a
</pre><p>

The <tt>Concurrent</tt> interface also provides access to "I-Vars"
and "M-Vars", which are two flavours of <i>synchronising variables</i>.
<a name="synchronising variables (Glasgow extension)"></a>
<p>
<a name="concurrency -- synchronising variables"></a>
<p>
<tt>_IVars</tt><a name="_IVars (Glasgow extension)"></a>
 are write-once
variables.  They start out empty, and any threads that attempt to read
them will block until they are filled.  Once they are written, any
blocked threads are freed, and additional reads are permitted.
Attempting to write a value to a full <tt>_IVar</tt> results in a runtime
error.  Interface:

<a name="synchronising variables (Glasgow extension)"></a>
<a name="concurrency -- synchronising variables"></a>
<a name="_IVars (Glasgow extension)"></a>
<pre>
type IVar a = _IVar a -- more convenient name

newIVar     :: IO (_IVar a)
readIVar    :: _IVar a -&gt; IO a
writeIVar   :: _IVar a -&gt; a -&gt; IO ()
</pre><p>

<tt>_MVars</tt><a name="_MVars (Glasgow extension)"></a>
 are rendezvous points,
mostly for concurrent threads.  They begin empty, and any attempt to
read an empty <tt>_MVar</tt> blocks.  When an <tt>_MVar</tt> is written, a
single blocked thread may be freed.  Reading an <tt>_MVar</tt> toggles its
state from full back to empty.  Therefore, any value written to an
<tt>_MVar</tt> may only be read once.  Multiple reads and writes are
allowed, but there must be at least one read between any two
writes. Interface:

<a name="_MVars (Glasgow extension)"></a>
<pre>
type MVar a  = _MVar a -- more convenient name

newEmptyMVar :: IO (_MVar a)
newMVar      :: a -&gt; IO (_MVar a)
takeMVar     :: _MVar a -&gt; IO a
putMVar      :: _MVar a -&gt; a -&gt; IO ()
readMVar     :: _MVar a -&gt; IO a
swapMVar     :: _MVar a -&gt; a -&gt; IO a
</pre><p>

A <i>channel variable</i> (<a href="#CVar"><tt>CVar</tt></a>) is a one-element channel, as
described in the paper:
<p>

<pre>
data CVar a
newCVar :: IO (CVar a)
putCVar :: CVar a -&gt; a -&gt; IO ()
getCVar :: CVar a -&gt; IO a
</pre><p>

A <a href="#Channel"><tt>Channel</tt></a> is an unbounded channel:
<p>

<pre>
data Chan a 
newChan         :: IO (Chan a)
putChan         :: Chan a -&gt; a -&gt; IO ()
getChan         :: Chan a -&gt; IO a
dupChan         :: Chan a -&gt; IO (Chan a)
unGetChan       :: Chan a -&gt; a -&gt; IO ()
getChanContents :: Chan a -&gt; IO [a]
</pre><p>

General and quantity semaphores:
<p>

<pre>
data QSem
newQSem     :: Int   -&gt; IO QSem
waitQSem    :: QSem  -&gt; IO ()
signalQSem  :: QSem  -&gt; IO ()

data QSemN
newQSemN    :: Int   -&gt; IO QSemN
signalQSemN :: QSemN -&gt; Int -&gt; IO ()
waitQSemN   :: QSemN -&gt; Int -&gt; IO ()
</pre><p>

Merging streams -- binary and n-ary:
<p>

<pre>
mergeIO  :: [a]   -&gt; [a] -&gt; IO [a]
nmergeIO :: [[a]] -&gt; IO [a]
</pre><p>

A <i>Sample variable</i> (<a href="#SampleVar"><tt>SampleVar</tt></a>) is slightly different from a
normal <a href="#_MVar"><tt>_MVar</tt></a>:
<ul>
<li>Reading an empty <a href="#SampleVar"><tt>SampleVar</tt></a> causes the reader to block
    (same as <a href="#takeMVar"><tt>takeMVar</tt></a> on empty <a href="#_MVar"><tt>_MVar</tt></a>).
<li>Reading a filled <a href="#SampleVar"><tt>SampleVar</tt></a> empties it and returns value.
    (same as <a href="#takeMVar"><tt>takeMVar</tt></a>)
<li>Writing to an empty <a href="#SampleVar"><tt>SampleVar</tt></a> fills it with a value, and
potentially, wakes up a blocked reader  (same as for <a href="#putMVar"><tt>putMVar</tt></a> on empty <a href="#_MVar"><tt>_MVar</tt></a>).
<li>Writing to a filled <a href="#SampleVar"><tt>SampleVar</tt></a> overwrites the current value.
 (different from <a href="#putMVar"><tt>putMVar</tt></a> on full <a href="#_MVar"><tt>_MVar</tt></a>.)
</ul>
<p>

<pre>
type SampleVar a = _MVar (Int, _MVar a)

emptySampleVar :: SampleVar a -&gt; IO ()
newSampleVar   :: IO (SampleVar a)
readSample     :: SampleVar a -&gt; IO a
writeSample    :: SampleVar a -&gt; a -&gt; IO ()
</pre><p>

Finally, there are operations to delay a concurrent thread, and to
make one wait:<a name="delay a concurrent thread"></a>
<p>
<a name="wait for a file descriptor"></a>
<p>

<a name="delay a concurrent thread"></a>
<a name="wait for a file descriptor"></a>
<pre>
threadDelay :: Int -&gt; IO () -- delay rescheduling for N microseconds
threadWait  :: Int -&gt; IO () -- wait for input on specified file descriptor
</pre><p>

<p>

<a name="parallel_1.1.2"><h4>Features specific to Parallel Haskell</h4></a>

<p>

<a name="parallel_1.1.2.1"><h5>The <tt>Parallel</tt> interface (recommended)</h5></a>
<a name="Parallel interface"></a>
<p>
GHC provides two functions for controlling parallel execution, through
the <tt>Parallel</tt> interface:

<a name="Parallel interface"></a>
<pre>
interface Parallel where
infixr 0 `par`
infixr 1 `seq`

par :: a -&gt; b -&gt; b
seq :: a -&gt; b -&gt; b
</pre><p>

The expression <tt>(x `par` y)</tt> <i>sparks</i> the evaluation of <tt>x</tt>
(to weak head normal form) and returns <tt>y</tt>.  Sparks are queued for
execution in FIFO order, but are not executed immediately.  At the
next heap allocation, the currently executing thread will yield
control to the scheduler, and the scheduler will start a new thread
(until reaching the active thread limit) for each spark which has not
already been evaluated to WHNF.
<p>
The expression <tt>(x `seq` y)</tt> evaluates <tt>x</tt> to weak head normal
form and then returns <tt>y</tt>.  The <tt>seq</tt> primitive can be used to
force evaluation of an expression beyond WHNF, or to impose a desired
execution sequence for the evaluation of an expression.
<p>
For example, consider the following parallel version of our old
nemesis, <tt>nfib</tt>:
<p>

<pre>
import Parallel

nfib :: Int -&gt; Int
nfib n | n &lt;= 1 = 1
       | otherwise = par n1 (seq n2 (n1 + n2 + 1))
                     where n1 = nfib (n-1) 
                           n2 = nfib (n-2)
</pre><p>

For values of <tt>n</tt> greater than 1, we use <tt>par</tt> to spark a thread
to evaluate <tt>nfib (n-1)</tt>, and then we use <tt>seq</tt> to force the
parent thread to evaluate <tt>nfib (n-2)</tt> before going on to add
together these two subexpressions.  In this divide-and-conquer
approach, we only spark a new thread for one branch of the computation
(leaving the parent to evaluate the other branch).  Also, we must use
<tt>seq</tt> to ensure that the parent will evaluate <tt>n2</tt> <i>before</i>
<tt>n1</tt> in the expression <tt>(n1 + n2 + 1)</tt>.  It is not sufficient to
reorder the expression as <tt>(n2 + n1 + 1)</tt>, because the compiler may
not generate code to evaluate the addends from left to right.
<p>

<a name="parallel_1.1.2.2"><h5>Underlying functions and primitives</h5></a>
<a name="parallelism primitives"></a>
<p>
<a name="primitives for parallelism"></a>
<p>
The functions <tt>par</tt> and <tt>seq</tt> are really just renamings:

<a name="parallelism primitives"></a>
<a name="primitives for parallelism"></a>
<pre>
par a b = _par_ a b
seq a b = _seq_ a b
</pre><p>

The functions <tt>_par_</tt> and <tt>_seq_</tt> are built into GHC, and unfold
into uses of the <tt>par#</tt> and <tt>seq#</tt> primitives, respectively.  If
you'd like to see this with your very own eyes, just run GHC with the
<tt>-ddump-simpl</tt> option.  (Anything for a good time...)
<p>
You can use <tt>_par_</tt> and <tt>_seq_</tt> in Concurrent Haskell, though
I'm not sure why you would want to.
<p>

<a name="parallel_1.1.3"><h4>Features common to Concurrent and Parallel Haskell</h4></a>

<p>
Actually, you can use the <tt>`par`</tt> and <tt>`seq`</tt> combinators
(really for Parallel Haskell) in Concurrent Haskell as well.
But doing things like "<tt>par</tt> to <tt>forkIO</tt> many required threads"
counts as "jumping out the 9th-floor window, just to see what happens."
<p>

<a name="parallel_1.1.3.1"><h5>Scheduling policy for concurrent/parallel threads</h5></a>
<a name="Scheduling -- concurrent/parallel"></a>
<p>
<a name="Concurrent/parallel scheduling"></a>
<p>
Runnable threads are scheduled in round-robin fashion.  Context
switches are signalled by the generation of new sparks or by the
expiry of a virtual timer (the timer interval is configurable with the
<tt>-C[&lt;num&gt;]</tt><a name="-C<num> RTS option (concurrent, parallel)"></a>
 RTS option).
However, a context switch doesn't really happen until the next heap
allocation.  If you want extremely short time slices, the <tt>-C</tt> RTS
option can be used to force a context switch at each and every heap
allocation.
<p>
When a context switch occurs, pending sparks which have not already
been reduced to weak head normal form are turned into new threads.
However, there is a limit to the number of active threads (runnable or
blocked) which are allowed at any given time.  This limit can be
adjusted with the <tt>-t&lt;num&gt;</tt><a name="-t <num> RTS option (concurrent, parallel)"></a>
<p>
RTS option (the default is 32).  Once the
thread limit is reached, any remaining sparks are deferred until some
of the currently active threads are completed.
<p>

<a name="Scheduling---concurrent/parallel"></a>
<a name="Concurrent/parallel scheduling"></a>
<a name="-C<num> RTS option (concurrent, parallel)"></a>
<a name="-t <num> RTS option (concurrent, parallel)"></a>
<a name="parallel_1.2"><h3>How to use Concurrent and Parallel Haskell</h3></a>

<p>
[You won't get far unless your GHC system was configured/built with
concurrency and/or parallelism enabled.  (They require separate
library modules.)  The relevant section of the installation guide says
how to do this.]
<p>

<a name="parallel_1.2.1"><h4>Using Concurrent Haskell</h4></a>
<a name="Concurrent Haskell -- use"></a>
<p>
To compile a program as Concurrent Haskell, use the <tt>-concurrent</tt>
option,<a name="-concurrent option"></a>
 both when compiling <i>and
linking</i>.  You will probably need the <tt>-fglasgow-exts</tt> option, too.
<p>
Three RTS options are provided for modifying the behaviour of the
threaded runtime system.  See the descriptions of <tt>-C[&lt;us&gt;]</tt>, <tt>-q</tt>,
and <tt>-t&lt;num&gt;</tt> in Section <a href="#parallel-rts-opts">parallel-rts-opts</a>.
<p>

<a name="Concurrent Haskell---use"></a>
<a name="-concurrent option"></a>
<a name="concurrent-problems"><h5>Potential problems with Concurrent Haskell</h5></a>
<a name="Concurrent Haskell problems"></a>
<p>
<a name="problems, Concurrent Haskell"></a>
<p>
The main thread in a Concurrent Haskell program is given its own
private stack space, but all other threads are given stack space from
the heap.  Stack space for the main thread can be
adjusted as usual with the <tt>-K</tt> RTS
option,<a name="-K RTS option (concurrent, parallel)"></a>
 but if this
private stack space is exhausted, the main thread will switch to stack
segments in the heap, just like any other thread.  Thus, problems
which would normally result in stack overflow in "sequential Haskell"
can be expected to result in heap overflow when using threads.
<p>
The concurrent runtime system uses black holes as synchronisation
points for subexpressions which are shared among multiple threads.  In
"sequential Haskell", a black hole indicates a cyclic data
dependency, which is a fatal error.  However, in concurrent execution, a
black hole may simply indicate that the desired expression is being
evaluated by another thread.  Therefore, when a thread encounters a
black hole, it simply blocks and waits for the black hole to be
updated.  Cyclic data dependencies will result in deadlock, and the
program will fail to terminate.
<p>
Because the concurrent runtime system uses black holes as
synchronisation points, it is not possible to disable black-holing
with the <tt>-N</tt> RTS option.<a name="-N RTS option"></a>
 Therefore, the use
of signal handlers (including timeouts) with the concurrent runtime
system can lead to problems if a thread attempts to enter a black hole
that was created by an abandoned computation.  The use of signal
handlers in conjunction with threads is strongly discouraged.
<p>

<a name="Concurrent Haskell problems"></a>
<a name="problems, Concurrent Haskell"></a>
<a name="-K RTS option (concurrent, parallel)"></a>
<a name="-N RTS option"></a>
<a name="parallel_1.2.2"><h4>Using Parallel Haskell</h4></a>
<a name="Parallel Haskell -- use"></a>
<p>
[You won't be able to execute parallel Haskell programs unless PVM3
(Parallel Virtual Machine, version 3) is installed at your site.]
<p>
To compile a Haskell program for parallel execution under PVM, use the
<tt>-parallel</tt> option,<a name="-parallel option"></a>
 both when compiling
<i>and linking</i>.  You will probably want to <tt>import Parallel</tt>
into your Haskell modules.
<p>
To run your parallel program, once PVM is going, just invoke it "as
normal".  The main extra RTS option is <tt>-N&lt;n&gt;</tt>, to say how many
PVM "processors" your program to run on.  (For more details of
all relevant RTS options, please see section <a href="#parallel-rts-opts">parallel-rts-opts</a>.)
<p>
In truth, running Parallel Haskell programs and getting information
out of them (e.g., parallelism profiles) is a battle with the vagaries of
PVM, detailed in the following sections.
<p>

<a name="Parallel Haskell---use"></a>
<a name="-parallel option"></a>
<a name="parallel_1.2.2.1"><h5>Dummy's guide to using PVM</h5></a>
<a name="PVM, how to use"></a>
<p>
<a name="Parallel Haskell -- PVM use"></a>
<p>
Before you can run a parallel program under PVM, you must set the
required environment variables (PVM's idea, not ours); something like,
probably in your <tt>.cshrc</tt> or equivalent:

<a name="PVM, how to use"></a>
<a name="Parallel Haskell---PVM use"></a>
<pre>
setenv PVM_ROOT /wherever/you/put/it
setenv PVM_ARCH `$PVM_ROOT/lib/pvmgetarch`
setenv PVM_DPATH $PVM_ROOT/lib/pvmd
</pre><p>

Creating and/or controlling your "parallel machine" is a purely-PVM
business; nothing specific to Parallel Haskell.
<p>
You use the <tt>pvm</tt><a name="pvm command"></a>
 command to start PVM on your
machine.  You can then do various things to control/monitor your
"parallel machine;" the most useful being:
<p>

<a name="pvm command"></a>
<pre>
<tt>Control-D</tt>            exit <tt>pvm</tt>, leaving it running     
<tt>halt</tt>                 kill off this "parallel machine" \& exit  
<tt>add &lt;host&gt;</tt>     add <tt>&lt;host&gt;</tt> as a processor  
<tt>delete &lt;host&gt;</tt>  delete <tt>&lt;host&gt;</tt>              
<tt>reset</tt>                kill what's going, but leave PVM up       
<tt>conf</tt>                 list the current configuration            
<tt>ps</tt>                   report processes' status                  
<tt>pstat &lt;pid&gt;</tt>    status of a particular process            
</pre>


The PVM documentation can tell you much, much more about <tt>pvm</tt>!
<p>

<a name="parallel_1.2.3"><h4>Parallelism profiles</h4></a>
<a name="parallelism profiles"></a>
<p>
<a name="profiles, parallelism"></a>
<p>
<a name="visualisation tools"></a>
<p>
With Parallel Haskell programs, we usually don't care about the
results -- only with "how parallel" it was!  We want pretty pictures.
<p>
Parallelism profiles (a la <tt>hbcpp</tt>) can be generated with the
<tt>-q</tt><a name="-q RTS option (concurrent, parallel)"></a>
 RTS option.  The
per-processor profiling info is dumped into files named
<tt>&lt;full-path&gt;&lt;program&gt;.gr</tt>.  These are then munged into a PostScript picture,
which you can then display.  For example, to run your program
<tt>a.out</tt> on 8 processors, then view the parallelism profile, do:
<p>

<a name="parallelism profiles"></a>
<a name="profiles, parallelism"></a>
<a name="visualisation tools"></a>
<a name="-q RTS option (concurrent, parallel)"></a>
<pre>
% ./a.out +RTS -N8 -q
% grs2gr *.???.gr &gt; temp.gr     # combine the 8 .gr files into one
% gr2ps -O temp.gr              # cvt to .ps; output in temp.ps
% ghostview -seascape temp.ps   # look at it!
</pre><p>

The scripts for processing the parallelism profiles are distributed
in <tt>ghc/utils/parallel/</tt>.
<p>

<a name="parallel_1.2.4"><h4>Other useful info about running parallel programs</h4></a>

<p>
The "garbage-collection statistics" RTS options can be useful for
seeing what parallel programs are doing.  If you do either <tt>+RTS -Sstderr</tt><a name="-Sstderr RTS option"></a>
 or <tt>+RTS -sstderr</tt>, then
you'll get mutator, garbage-collection, etc., times on standard
error. The standard error of all PE's other than the `main thread'
appears in <tt>/tmp/pvml.nnn</tt>, courtesy of PVM.
<p>
Whether doing <tt>+RTS -Sstderr</tt> or not, a handy way to watch
what's happening overall is: <tt>tail -f /tmp/pvml.nnn</tt>.
<p>

<a name="-Sstderr RTS option"></a>
<a name="parallel-rts-opts"><h4>RTS options for Concurrent/Parallel Haskell</h4></a>
<a name="RTS options, concurrent"></a>
<p>
<a name="RTS options, parallel"></a>
<p>
<a name="Concurrent Haskell -- RTS options"></a>
<p>
<a name="Parallel Haskell -- RTS options"></a>
<p>
Besides the usual runtime system (RTS) options
(part <a href="#runtime-control">runtime-control</a>), there are a few options particularly
for concurrent/parallel execution.
<p>
<dl>
<dt><tt>-N&lt;N&gt;</tt>:
<dd><a name="-N<N> RTS option (parallel)"></a>
<p>
(PARALLEL ONLY) Use <tt>&lt;N&gt;</tt> PVM processors to run this program;
the default is 2.
<p>
<dt><tt>-C[&lt;us&gt;]</tt>:
<dd><a name="-C<us> RTS option"></a>
<p>
Sets the context switch interval to &lt;us&gt; microseconds.  A context
switch will occur at the next heap allocation after the timer expires.
With <tt>-C0</tt> or <tt>-C</tt>, context switches will occur as often as
possible (at every heap allocation).  By default, context switches
occur every 10 milliseconds.  Note that many interval timers are only
capable of 10 millisecond granularity, so the default setting may be
the finest granularity possible, short of a context switch at every
heap allocation.
<p>
<dt><tt>-q[v]</tt>:
<dd><a name="-q RTS option"></a>
<p>
Produce a quasi-parallel profile of thread activity, in the file
<tt>&lt;program&gt;.qp</tt>.  In the style of <tt>hbcpp</tt>, this profile records
the movement of threads between the green (runnable) and red (blocked)
queues.  If you specify the verbose suboption (<tt>-qv</tt>), the green
queue is split into green (for the currently running thread only) and
amber (for other runnable threads).  We do not recommend that you use
the verbose suboption if you are planning to use the <tt>hbcpp</tt>
profiling tools or if you are context switching at every heap check
(with <tt>-C</tt>).
<p>
<dt><tt>-t&lt;num&gt;</tt>:
<dd><a name="-t<num> RTS option"></a>
<p>
Limit the number of concurrent threads per processor to &lt;num&gt;.
The default is 32.  Each thread requires slightly over 1K <i>words</i>
in the heap for thread state and stack objects.  (For 32-bit machines,
this translates to 4K bytes, and for 64-bit machines, 8K bytes.)
<p>
<dt><tt>-d</tt>:
<dd><a name="-d RTS option (parallel)"></a>
<p>
(PARALLEL ONLY) Turn on debugging.  It pops up one xterm (or GDB, or
something...) per PVM processor.  We use the standard <tt>debugger</tt>
script that comes with PVM3, but we sometimes meddle with the
<tt>debugger2</tt> script.  We include ours in the GHC distribution,
in <tt>ghc/utils/pvm/</tt>.
<p>
<dt><tt>-e&lt;num&gt;</tt>:
<dd><a name="-e<num> RTS option (parallel)"></a>
<p>
(PARALLEL ONLY) Limit the number of pending sparks per processor to
<tt>&lt;num&gt;</tt>. The default is 100. A larger number may be appropriate if
your program generates large amounts of parallelism initially.
<p>
<dt><tt>-Q&lt;num&gt;</tt>:
<dd><a name="-Q<num> RTS option (parallel)"></a>
<p>
(PARALLEL ONLY) Set the size of packets transmitted between processors
to <tt>&lt;num&gt;</tt>. The default is 1024 words. A larger number may be
appropriate if your machine has a high communication cost relative to
computation speed.
<p>
</dl>
<p>

<a name="RTS options, concurrent"></a>
<a name="RTS options, parallel"></a>
<a name="Concurrent Haskell---RTS options"></a>
<a name="Parallel Haskell---RTS options"></a>
<a name="-N<N> RTS option (parallel)"></a>
<a name="-C<us> RTS option"></a>
<a name="-q RTS option"></a>
<a name="-t<num> RTS option"></a>
<a name="-d RTS option (parallel)"></a>
<a name="-e<num> RTS option (parallel)"></a>
<a name="-Q<num> RTS option (parallel)"></a>
<a name="parallel-problems"><h5>Potential problems with Parallel Haskell</h5></a>
<a name="Parallel Haskell -- problems"></a>
 
<a name="problems, Parallel Haskell"></a>
 
<p>
The "Potential problems" for Concurrent Haskell also apply for
Parallel Haskell.  Please see Section <a href="#concurrent-problems">concurrent-problems</a>.
<p>

<a name="Parallel Haskell---problems"></a>
<a name="problems, Parallel Haskell"></a>




<p>

<a name="wrong"><h2>What to do when something goes wrong</h2></a>
<a name="problems"></a>
<p>
If you still have a problem after consulting this section, then you
may have found a <i>bug</i> -- please report it!  See
Chapter <a href="#bug-reports">bug-reports</a> for a list of things we'd like to know about
your bug.  If in doubt, send a report -- we love mail from irate users :-!
<p>
(Part <a href="#vs-Haskell-defn">vs-Haskell-defn</a>, which describes Glasgow Haskell's
shortcomings vs. the Haskell language definition, may also be of
interest.)
<p>

<a name="problems"></a>
<a name="wrong-compiler"><h3>When the compiler "does the wrong thing"</h3></a>
<a name="compiler problems"></a>
<p>
<a name="problems with the compiler"></a>
<p>
<dl>
<p>
<dt>"Help! The compiler crashed (or `panic'd)!"
<dd>These events are <i>always</i> bugs in the GHC system -- please report
them.
<p>
<dt>"The compiler ran out of heap (or stack) when compiling itself!"
<dd>It happens.  We try to supply reasonable <tt>-H&lt;n&gt;</tt> flags for
<tt>ghc/compiler/</tt> and <tt>ghc/lib/</tt>, but GHC's memory consumption
can vary by platform (e.g., on a 64-bit machine).
<p>
Just say <tt>make all EXTRA_HC_OPTS=-H&lt;a reasonable number&gt;</tt> and see
how you get along.
<p>
<dt>"The compiler died with a pattern-matching error."
<dd>This is a bug just as surely as a "panic." Please report it.
<p>
<dt>"Some confusion about a value specialised to a type..."  Huh???
<dd>(A deeply obscure and unfriendly error message.)
<p>
This message crops up when the typechecker sees a reference in an
interface pragma to a specialisation of an overloaded value
(function); for example, <tt>elem</tt> specialised for type <tt>[Char]</tt>
(<tt>String</tt>).  The problem is: it doesn't <i>know</i> that such a
specialisation exists!
<p>
The cause of this problem is (please report any other cases...): The
compiler has imported pragmatic info for the value in question from
more than one interface, and the multiple interfaces did not agree
<i>exactly</i> about the value's pragmatic info.  Since the compiler
doesn't know whom to believe, it believes none of them.
<p>
The cure is to re-compile the modules that <i>re-export</i> the
offending value (after possibly re-compiling its defining module).
Now the pragmatic info should be exactly the same in every case, and
things should be fine.
<p>
<dt>"Can't see the data constructors for a ccall/casm" Huh?
<dd>GHC "unboxes" C-call arguments and "reboxes" C-call results for you.
To do this, it {\\em has} to be able to see the types fully;
abstract types won't do!
<p>
Thus, if you say <tt>data Foo = Foo Int#</tt>
(a cool "boxed primitive" type), but then make it abstract
(only <tt>data Foo</tt> appears in the interface), then GHC can't figure
out what to do with <tt>Foo</tt> arguments/results to C-calls.
<p>
Solutions: either make the type unabstract, or compile with <tt>-O</tt>.
With the latter, the constructor info will be passed along in
the interface pragmas.
<p>
<dt>"This is a terrible error message."
<dd>If you think that GHC could have produced a better error message,
please report it as a bug.
<p>
<dt>"What about these `trace' messages from GHC?"
<dd>Almost surely not a problem.  About some specific cases...
<dl>
<dt>Simplifier still going after N iterations:
<dd>Sad, but harmless.  You can change the number with a
<tt>-fmax-simplifier-iterations&lt;N&gt;</tt><a name="-fmax-simplifier-iterations<N> option"></a>
 option (no space);
and you can see what actions took place in each iteration by
turning on the <tt>-fshow-simplifier-progress</tt>
<a name="-fshow-simplifier-progress option"></a>
 option.
<p>
If the simplifier definitely seems to be "looping," please report
it.
</dl>
<p>
<dt>"What about this warning from the C compiler?"
<dd>For example: "...warning: `Foo' declared `static' but never defined."
Unsightly, but not a problem.
<p>
<dt>Sensitivity to <tt>.hi</tt> interface files:
<dd>GHC is very sensitive about interface files.  For example, if it picks
up a non-standard <tt>Prelude.hi</tt> file, pretty terrible things will
happen.  If you turn on
<tt>-fno-implicit-prelude</tt><a name="-fno-implicit-prelude option"></a>
, the
compiler will almost surely die, unless you know what you are doing.
<p>
Furthermore, as sketched below, you may have big problems
running programs compiled using unstable interfaces.
<p>
<dt>"I think GHC is producing incorrect code":
<dd>Unlikely :-) A useful be-more-paranoid option to give to GHC is
<tt>-dcore-lint</tt><a name="-dcore-lint option"></a>
; this causes a "lint" pass to
check for errors (notably type errors) after each Core-to-Core
transformation pass.  We run with <tt>-dcore-lint</tt> on all the time; it
costs about 5% in compile time.  (Or maybe 25%; who knows?)
<p>
<dt>"Why did I get a link error?"
<dd>If the linker complains about not finding <tt>_&lt;something&gt;_fast</tt>, then
your interface files haven't settled -- keep on compiling!  (In
particular, this error means that arity information, which you can see
in any <tt>.hi</tt> file, has changed.)
<p>
<dt>"What's a `consistency error'?"
<dd>(These are reported just after linking your program.)
<p>
You tried to link incompatible object files, e.g., normal ones
(registerised, Appel garbage-collector) with profiling ones (two-space
collector).  Or those compiled by a previous version of GHC
with an incompatible newer version.
<p>
If you run <tt>nm -o *.o | egrep 't (cc|hsc)\.'</tt> (or, on
unregisterised files: <tt>what *.o</tt>), you'll see all the consistency
tags/strings in your object files.  They must all be the same!
(<B>ToDo</B>: tell you what they mean...)
<p>
<dt>"Is this line number right?"
<dd>On this score, GHC usually does pretty well, especially
if you "allow" it to be off by one or two.  In the case of an
instance or class declaration, the line number
may only point you to the declaration, not to a specific method.
<p>
Please report line-number errors that you find particularly unhelpful.
</dl>
<p>

<a name="compiler problems"></a>
<a name="problems with the compiler"></a>
<a name="-fmax-simplifier-iterations<N> option"></a>
<a name="-fshow-simplifier-progress option"></a>
<a name="-fno-implicit-prelude option"></a>
<a name="-dcore-lint option"></a>
<a name="wrong-compilee"><h3>When your program "does the wrong thing"</h3></a>
<a name="problems running your program"></a>
<p>
(For advice about overly slow or memory-hungry Haskell programs,
please see part <a href="#sooner-faster-quicker">sooner-faster-quicker</a>).
<p>
<dl>
<p>
<dt>"Help! My program crashed!"
<dd>(e.g., a `segmentation fault' or `core dumped')
<p>
If your program has no <a href="#_ccall_"><tt>_ccall_</tt></a>s/<a href="#_casm_"><tt>_casm_</tt></a>s in it, then a crash is always
a BUG in the GHC system, except in one case: If your program is made
of several modules, each module must have been compiled with a stable
group of interface (<tt>.hi</tt>) files.
<p>
For example, if an interface is lying about the type of an imported
value then GHC may well generate duff code for the importing module.
<i>This applies to pragmas inside interfaces too!</i>  If the pragma is
lying (e.g., about the "arity" of a value), then duff code may result.
Furthermore, arities may change even if types do not.
<p>
In short, if you compile a module and its interface changes, then all
the modules that import that interface <i>must</i> be re-compiled.
<p>
A useful option to alert you when interfaces change is
<tt>-hi-diffs</tt><a name="-hi-diffs option"></a>
.  It will run <tt>diff</tt> on the
changed interface file, before and after, when applicable.
<p>
If you are using <tt>make</tt>, a useful tool to make sure that every
module <i>is</i> up-to-date with respect to its imported interfaces is
<tt>mkdependHS</tt> (which comes with GHC).  Please see
chapter <a href="#mkdependHS">mkdependHS</a>.
<p>
If you are down to your last-compile-before-a-bug-report, we
would recommend that you add a <tt>-dcore-lint</tt> option (for
extra checking) to your compilation options.
<p>
So, before you report a bug because of a core dump, you should probably:

<a name="problems running your program"></a>
<a name="-hi-diffs option"></a>
<pre>
% rm *.o        # scrub your object files
% make my_prog  # re-make your program; use -hi-diffs to highlight changes
% ./my_prog ... # retry...
</pre><p>

Of course, if you have <a href="#_ccall_"><tt>_ccall_</tt></a>s/<a href="#_casm_"><tt>_casm_</tt></a>s in your program then all bets
are off, because you can trash the heap, the stack, or whatever.
<p>
If you are interested in hard-core debugging of a crashing
GHC-compiled program, please see chapter <a href="#hard-core-debug">hard-core-debug</a>.
<p>
<dt>"My program entered an `absent' argument."
<dd>This is definitely caused by a bug in GHC. Please report it.
<p>
<dt>"What's with this `arithmetic (or `floating') exception' "?
<dd><a href="#Int"><tt>Int</tt></a>, <a href="#Float"><tt>Float</tt></a>, and <a href="#Double"><tt>Double</tt></a> arithmetic is <i>unchecked</i>.  Overflows
and underflows are <i>silent</i>.  Divide-by-zero <i>may</i> cause an
untrapped exception (please report it if it does).  I suppose other
arithmetic uncheckiness might cause an exception, too...
</dl>
<p>

<a name="bug-reports"><h3>How to report a bug in the GHC system</h3></a>
<a name="bug reports"></a>
<p>
Glasgow Haskell is a changing system so there are sure to be bugs in
it.  Please report them to
<tt>glasgow-haskell-bugs@dcs.glasgow.ac.uk</tt>!  (However, please check
the earlier part of this section to be sure it's not a known
not-really-a problem.)
<p>
The name of the bug-reporting game is: facts, facts, facts.
Don't omit them because "Oh, they won't be interested..."
<ul>
<li>What kind of machine are you running on, and exactly what version of the
operating system are you using? (<tt>cat /etc/motd</tt> often shows the desired
information.)
<p>
<li>What version of GCC are you using? <tt>gcc -v</tt> will tell you.
<p>
<li>Run the sequence of compiles/runs that caused the offending behaviour,
capturing all the input/output in a "script" (a UNIX command) or in
an Emacs shell window.  We'd prefer to see the whole thing.
<p>
<li>Be sure any Haskell compilations are run with a <tt>-v</tt> (verbose)
flag, so we can see exactly what was run, what versions of things you
have, etc.
<p>
<li>What is the program behaviour that is wrong, in your opinion?
<p>
<li>If practical, please send enough source files/interface files for us
to duplicate the problem.
<p>
<li>If you are a Hero and track down the problem in the compilation-system
sources, please send us <i>whole files</i> (by e-mail or FTP) that we
can compare against some base release.
</ul>
<p>

<a name="bug reports"></a>
<a name="hard-core-debug"><h3>Hard-core debugging of GHC-compiled programs</h3></a>
<a name="debugging, hard-core"></a>
<p>
If your program is crashing, you should almost surely file a bug
report, as outlined in previous sections.
<p>
This section suggests ways to Make Further Progress Anyway.
<p>
The first thing to establish is: Is it a garbage-collection (GC) bug?
Try your program with a very large heap and a <tt>-Sstderr</tt> RTS
flag.
<ul>
<li>If it crashes <i>without</i> garbage-collecting, then it is
definitely <i>not</i> a GC bug.
<li>If you can make it crash with one heap size but not with another, then
it <i>probably is</i> a GC bug.
<li>If it crashes with the normal
collector, but not when you force two-space collection (<tt>-F2s</tt>
runtime flag), then it <i>probably is</i> a GC bug.
</ul>
<p>
If it <i>is</i> a GC bug, you may be able to avoid it by using a
particular heap size or by using a <tt>-F2s</tt> runtime flag.  (But don't
forget to report the bug!!!)
<p>
<B>ToDo</B>: more here?

<a name="debugging, hard-core"></a>




<p>

<a name="vs-Haskell-defn"><h2>Haskell 1.2 vs. Glasgow Haskell 0.26: language non-compliance</h2></a>
<a name="GHC vs the Haskell 1.2 language"></a>
<p>
<a name="Haskell 1.2 language vs GHC"></a>
<p>
This section lists Glasgow Haskell infelicities in its implementation
of Haskell 1.2.  See also the "when things go wrong" section
(part <a href="#wrong">wrong</a>) for information about crashes, space leaks, and
other undesirable phenomena.
<p>
The limitations here are listed in Haskell-Report order (roughly).
<p>

<a name="GHC vs the Haskell 1.2 language"></a>
<a name="Haskell 1.2 language vs GHC"></a>
<a name="infelicities-exprs-pats"><h3>Expressions and patterns</h3></a>

<p>
<dl>
<p>
<dt>Some valid irrefutable patterns are rejected:
<dd>As syntax errors; just put parentheses around them.
<p>
<dt>Very long <a href="#String"><tt>String</tt></a> constants:
<dd>May not go through.  If you add a "string gap" every
few thousand characters, then the strings can be as long
as you like.
<p>
Bear in mind that string gaps and the <tt>-cpp</tt><a name="-cpp option"></a>
<p>
option don't mix.  The C-preprocessor may munch the backslashes.
<p>
<dt>Very long literal lists:
<dd>These may tickle a "yacc stack overflow" error in the parser.
(It depends on the Yacc used to build your parser.)
</dl>
<p>

<a name="-cpp option"></a>
<a name="infelicities-decls"><h3>Declarations and bindings</h3></a>

<p>
<dl>
<p>
<dt>Contexts on <a href="#data"><tt>data</tt></a> declarations are ignored:
<dd>Not that they do much, anyway...  This won't wreck your life.
(We still [vaguely] plan to add them, however.)
<p>
<dt>Location of instance declarations is unchecked:
<dd>We don't check that instance declarations occur either in the module
where the class is declared or the module where the data type is
declared.  This shouldn't hurt you.
<p>
For better or worse, we <i>do</i> check if you try to declare a Prelude
instance (Prelude class, Prelude type; e.g., <tt>instance Num Bool</tt>)
in one of your own modules.  For some reason, people like to do this!
(But it is not legal Haskell.)
<p>
<dt>Derived instances of <a href="#Text"><tt>Text</tt></a> for infix constructors:
<dd>All the carry-on about derived <a href="#readsPrec"><tt>readsPrec</tt></a> and <a href="#showsPrec"><tt>showsPrec</tt></a> for infix
constructors -- we don't do it (yet).  We treat them the same way as
all other constructors.
<p>
<dt>Derived instances of <a href="#Binary"><tt>Binary</tt></a>:
<dd>We don't.  (We don't do anything <a href="#Binary"><tt>Binary</tt></a>ish.)
</dl>
<p>

<a name="infelicities-Modules"><h3>Module system and interface files</h3></a>

<p>
<dl>
<p>
<dt>Duplicates in a `renaming' list:
<dd>Are not reported.
<p>
<dt>Duplicates in an `import' declaration:
<dd>These are reported as errors, which some might argue they shouldn't
be.  We reckon it's a feature, not a bug.
<p>
<dt>Export of `renamed' class methods:
<dd>Willnae work.  That is: you import a class, renaming one or more
methods; then export that class -- the renaming of the methods <i>will not</i> propagate.
<p>
(Otherwise, `renaming' -- disgusting though it may be -- should work.)
<p>
<dt>Fixities/precedences following `renamed' entities that are exported:
<dd>No chance.
<p>
<dt><tt>import Foo ()</tt> vs <tt>import Foo</tt>:
<dd>GHC cannot tell the difference (!).
<p>
Given that the only module on which you might want to do the former is
<tt>import Prelude ()</tt>, there are probably much bigger gremlins that
would jump out and bite you if the import <i>did</i> work.  Besides
which, you can achieve the same result with
<tt>-fno-implicit-prelude</tt>.<a name="-fno-implicit-prelude option"></a>
<p>
<dt>Some selective import/export checking not done:
<dd>On selective import and export of type-constructors/classes in
which the data-constructors/methods are named explicitly:
it'll work; it's just that every conceivable paranoia
check won't be done.
<p>
<dt>Some Prelude entities cannot be hidden:
<dd>For example, this doesn't work:

<a name="-fno-implicit-prelude option"></a>
<pre>
import Prelude hiding (readParen)
</pre><p>
That's because there are a few should-be-hideable Prelude entities
which need to appear by magic for derived instances.  They are
<tt>(&amp;&amp;)</tt>, <tt>(.)</tt>, <tt>lex</tt>, <tt>map</tt>, <tt>not</tt>, <tt>readParen</tt>,
<tt>showParen</tt>, and <tt>showString</tt>.  SIGH.
<p>
<dt><tt>M..</tt> exports vs multiply-imported entities:
<dd>If an entity <tt>foo</tt> is imported from several interfaces, as in...

<pre>
import A1 (foo); import A2 (foo); import A3 (foo)
</pre><p>
... and you then do a "dot dot" export of <tt>A1</tt> (for example), it
will be <i>pure luck</i> if <tt>foo</tt> gets exported.  This is very sad.
<p>
Workaround: export <tt>foo</tt> explicitly.
<p>
<dt><tt>M..</tt> with Prelude interfaces:
<dd>Doing <tt>Prelude&lt;something&gt;..</tt> in an export list; don't even think
it.
<p>
<dt>Export of Prelude types/classes must be explicit:
<dd>If you want to export a data type, type synonym or class from a
Prelude module (its name starts with `Prelude'), then it must be
listed explicitly in the export list.  If you say:
<p>

<pre>
module PreludeMeGently ( PreludeMeGently.. , other_stuff ) where ..
</pre><p>

then the classes/types in <tt>PreludeMeGently</tt> will <i>not</i> be
exported; just add them to the export list.  (This shortcoming is only
likely to affect people writing their own Prelude modules.)
<p>
<dt>Can't export primitives types (e.g., <tt>Int#</tt>):
<dd>Don't even try...
<p>
<dt>Naming errors with <tt>-O</tt> but not without:
<dd>Documentation by example -- Consider a module with these imports:
<p>

<pre>
... various imports ...
import Prettyterm       -- desired import

import Pretty           -- sadly-needed import
</pre><p>

The <tt>import Pretty</tt> is required because it defines a type
<tt>Pretty.Doc</tt> which is mentioned in <tt>import Prettyterm</tt>.
(Extremely sad, but them's the rules.)
<p>
But without <tt>-O</tt>, GHC uses its <tt>-fuse-get-mentioned-vars</tt> hack
(for speed), trying to avoid looking at parts of interfaces that have
no relevance to this module.  As it happens, the thing in
<tt>Prettyterm</tt> that mentions <tt>Pretty.Doc</tt> is not used here, so
this module will go through without <tt>import Pretty</tt>.  Nice, but
wrong.
</dl>
<p>

<a name="infelicities-numbers"><h3>Numbers, basic types, and built-in classes</h3></a>

<p>
<dl>
<p>
<dt>Very large/small fractional constants:
<dd>(i.e., with a decimal point somewhere) GHC does not check that these
are out of range (e.g., for a <a href="#Float"><tt>Float</tt></a>), and bad things will inevitably
follow.  To be corrected.
<p>
This problem does <i>not</i> exist for integral constants.
<p>
For very large/small fractional constants near the limits of your
floating-point precision, things may go wrong.  (It's better than it
used to be.)  Please report any such bugs.
<p>
<dt>Unchecked arithmetic:
<dd>Arguably <i>not</i> an infelicity, but... Bear in mind that operations
on <tt>Int</tt>, <tt>Float</tt>, and <tt>Double</tt> numbers are <i>unchecked</i>
for overflow, underflow, and other sad occurrences.
<p>
Use <tt>Integer</tt>, <tt>Rational</tt>, etc., numeric types if this stuff keeps you
awake at night.
<p>
<dt>Multiply-defined array elements -- not checked:
<dd>This code fragment <i>should</i> elicit a fatal error, but it does not:

<pre>
main = print (array (1,1) [ 1:=2, 1:=3 ])
</pre><p>

<p>
<dt>Support for <a href="#Binary"><tt>Binary</tt></a> whatnot:
<dd>We don't.
</dl>
<p>

<a name="infelicities-IO"><h3>Dialogue I/O</h3></a>

<p>
Dialogue-style I/O -- still the default for GHC -- is on its way out
(see the stuff about "monadic I/O for Haskell 1.3"), so we probably
won't fix these shortcomings.
<p>
<dl>
<p>
<dt>Support for <a href="#Dialogue"><tt>Dialogue</tt></a> I/O:
<dd>We do not yet support all <a href="#Requests"><tt>Requests</tt></a>, notably:
<a href="#ReadBinFile"><tt>ReadBinFile</tt></a>,
<a href="#WriteBinFile"><tt>WriteBinFile</tt></a>,
<a href="#AppendBinFile"><tt>AppendBinFile</tt></a>,
<a href="#StatusFile"><tt>StatusFile</tt></a>,
<a href="#ReadBinChan"><tt>ReadBinChan</tt></a>,
<a href="#AppendBinChan"><tt>AppendBinChan</tt></a>,
<a href="#StatusChan"><tt>StatusChan</tt></a>,
<a href="#SetEnv"><tt>SetEnv</tt></a>.  Also, we do not support the optional I/O <a href="#Requests"><tt>Requests</tt></a>.
<p>
<dt><a href="#AppendChan"><tt>AppendChan</tt></a> and <a href="#ReadChan"><tt>ReadChan</tt></a> requests:
<dd>The former only works for <tt>stdout</tt> and <tt>stderr</tt>; the
latter only for <tt>stdin</tt>.
<p>
<dt><a href="#Echo"><tt>Echo</tt></a> request:
<dd>We don't do anything at all.
</dl>
<p>

<a name="infelicities-Prelude"><h3>In Prelude support</h3></a>

<p>
<dl>
<p>
<dt>Arbitrary-sized tuples:
<dd>Plain old tuples of arbitrary size <i>do</i> work.
Note that lots
of overloading can give rise to large tuples "under the hood" of
your program.
<p>
HOWEVER: standard instances for tuples (<a href="#Eq"><tt>Eq</tt></a>, <a href="#Ord"><tt>Ord</tt></a>, <a href="#Ix"><tt>Ix</tt></a>, and
<a href="#Binary"><tt>Binary</tt></a>) are available <i>only</i> up to 5-tuples; except <a href="#Binary"><tt>Binary</tt></a>,
which we don't do at all.
<p>
These limitations are easily subvertible, so please ask if you get
stuck on them.
</dl>
<p>

<a name="vs-Haskell-1.3"><h2>Haskell 1.3 DRAFT vs. Glasgow Haskell 0.26</h2></a>
<a name="GHC vs the DRAFT Haskell 1.3 language"></a>
<p>
<a name="Haskell 1.3 language DRAFT vs GHC"></a>
<p>
There is work afoot on "Haskell 1.3," a substantial revision of
the Haskell 1.2 language.
<p>
Haskell 1.3 is NOT a standard; it is NOT even a DRAFT standard.  As of
June 1995, there exists a 1.3 PROPOSAL, which will CERTAINLY change.
Therefore, the "1.3 things" we "support" may change ARBITRARILY
much, and we won't even be mildly apologetic about breaking programs
that use "1.3" facilities.
<p>
That said, there are two categories of "1.3" things that we commend
to you.
<ul>
<li>Things virtually certain to end up in any 1.3 standard.  An example is
the <tt>Maybe</tt> type.
<li>Wobblier things which are so much better than their 1.2 equivalents
that you will want to use them.  We mean: monadic I/O.
<p>
The basic I/O functions are "unlikely" to change and so are
reasonably safe to adopt.  (But see WARNING above...)
</ul>
<p>
To use our 1.3 code, you should compile <i>and link</i> using a
<tt>-fhaskell-1.3</tt><a name="-fhaskell-1.3 option"></a>
 flag.
<p>

<a name="GHC vs the DRAFT Haskell 1.3 language"></a>
<a name="Haskell 1.3 language DRAFT vs GHC"></a>
<a name="-fhaskell-1.3 option"></a>
<a name="duffer-1-3"><h3>Duffer's guide for converting 1.2 I/O to 1.3 I/O</h3></a>
<a name="I/O -- converting 1.2 to 1.3"></a>
<p>
<a name="Dialogue I/O--converting to 1.3"></a>
<p>
<a name="1.2 I/O -- converting to 1.3"></a>
<p>
Here is our "crib sheet" for converting 1.2 I/O to 1.3.  In most cases,
it's really easy.
<ul>
<li>Change <tt>readChan stdin</tt> to <tt>hGetContents stdin</tt>.
<li>Change <tt>appendChan stdout</tt> to <tt>putStr</tt>, which is equivalent to
<tt>hPutStr stdout</tt>.
Change <tt>appendChan stderr</tt> to <tt>hPutStr stderr</tt>.
<li>You need to <tt>import LibSystem</tt> if you used <a href="#getArgs"><tt>getArgs</tt></a>, <a href="#getEnv"><tt>getEnv</tt></a>,
or <a href="#getProgName"><tt>getProgName</tt></a>.
<li>Assuming continuation-style <a href="#Dialogue"><tt>Dialogue</tt></a> code, change <tt>... exit done $</tt>
to <tt>... &gt;&gt;</tt>.  Change <tt>... exit $ \ foo -&gt;</tt> to <tt>... &gt;&gt;= \ foo -&gt;</tt>.
<li>If you had any functions named <tt>(&gt;&gt;)</tt>, <tt>(&gt;&gt;=)</tt>, or <tt>return</tt>,
change them to something else.
</ul>
<p>

<a name="I/O---converting 1.2 to 1.3"></a>
<a name="Dialogue I/O--converting to 1.3"></a>
<a name="1.2 I/O---converting to 1.3"></a>
<a name="nonio-1-3"><h3>Non-I/O things from the 1.3-DRAFT proposal</h3></a>

<p>
Besides the I/O stuff, you also get these things when you use the
<tt>-fhaskell-1.3</tt><a name="-fhaskell-1.3 option"></a>
 flag.
<p>
Once again: ANY of thing might CHANGE COMPLETELY before we have "1.3
for real."
<p>

<a name="-fhaskell-1.3 option"></a>
<pre>
data Either a b = Left a | Right b deriving (Text, Eq, Ord)

data Maybe a = Nothing | Just a deriving (Eq, Ord, Text)

thenMaybe :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b
thenMaybe Nothing _ = Nothing
thenMaybe (Just x) f = f x

curry   :: ((a,b) -&gt; c) -&gt; a -&gt; b -&gt; c
curry f x y = f (x,y)

uncurry :: (a -&gt; b -&gt; c) -&gt; (a,b) -&gt; c
uncurry f (x,y) = f x y
</pre><p>
<a name="Maybe type (Haskell 1.3)"></a>
<p>
<a name="Either type (Haskell 1.3)"></a>
<p>
<a name="curry function (Haskell 1.3)"></a>
<p>
<a name="uncurry function (Haskell 1.3)"></a>
<p>

<a name="Maybe type (Haskell 1.3)"></a>
<a name="Either type (Haskell 1.3)"></a>
<a name="curry function (Haskell 1.3)"></a>
<a name="uncurry function (Haskell 1.3)"></a>
<a name="io-1-3"><h3>Vs 1.3 monadic I/O</h3></a>
<a name="GHC vs the DRAFT 1.3 I/O proposal"></a>
<p>
<a name="DRAFT 1.3 I/O proposal vs GHC"></a>
<p>
The most notable improvement in Haskell 1.3 is its I/O, with a shift to
"monadic-style" I/O.
<p>
We still offer direct access to the so-called <tt>PrimIO</tt> monad, via
the <tt>PreludeGlaST</tt> interface.  This is NON-STANDARD, an extension.
This interface is described in Section <a href="#io-1-3-prim-interface">io-1-3-prim-interface</a>.
<p>
The old <tt>PreludePrimIO</tt> interface is DEAD.
<p>
The even-older <tt>PreludeGlaIO</tt> interface is DEADER.
<p>

<a name="GHC vs the DRAFT 1.3 I/O proposal"></a>
<a name="DRAFT 1.3 I/O proposal vs GHC"></a>
<a name="io-1-3-shortcomings"><h4>Known shortcomings in monadic I/O</h4></a>

<p>
Before you begin with "1.3-style" monadic I/O, you might as well
know the known shortcomings of our implementation, as at 0.26.
<p>
The error type is called <tt>IOError13</tt>, rather than <tt>IOError</tt>
<a name="IOError13 vs IOError"></a>
<p>
(which is still the 1.2 type).  (Prelude types cannot be renamed,
so...)  You probably shouldn't be messing with <tt>IOError</tt> much,
anyway.
<p>
Some of the 1.3 I/O code, notably the Extremely Cool <tt>LibPosix</tt>
stuff, is relatively untested.  Go for it, but be wary...
<a name="LibPosix bugs"></a>
<p>
<a name="bugs, LibPosix"></a>
<p>

<a name="IOError13 vs IOError"></a>
<a name="LibPosix bugs"></a>
<a name="bugs, LibPosix"></a>
<a name="io-1-3-main-interface"><h4>1.3-style monadic I/O</h4></a>

<p>
To use our 1.3 I/O, you should compile <i>and link</i> using a
<tt>-fhaskell-1.3</tt><a name="-fhaskell-1.3 option"></a>
 flag.
<p>
You should consult the PROPOSED 1.3-I/O standard.  GHC 0.26 implements
the "December 1994" draft, which we distribute in
<tt>ghc/docs/io-1.3/</tt>.
<p>
Alternatively, you could grab the "June 1995" draft, from
<tt>pub/haskell/report/</tt>, on <tt>ftp.dcs.glasgow.ac.uk</tt>.  The main
December--June change that you need to know about is: many of the I/O
functions have been removed from <tt>Prelude*</tt> interfaces (no import
required) and put into <tt>Lib*</tt> interfaces (import required).
<p>
GHC 0.26 still provides the I/O functions via <tt>Prelude.hi</tt> (no
import required).  Ignore the "June draft" pleadings for
<tt>import LibIO</tt>, and you'll be fine.
<p>
<i>There is no guarantee that the final 1.3 proposal will look
anything like the current DRAFT.</i>  It ain't a standard until the fat
committee sings.
<p>
For interaction with our non-standard <tt>PrimIO</tt>, including
<tt>_ccall_</tt>s.  we also provide:

<a name="-fhaskell-1.3 option"></a>
<pre>
-- impedance matching stuff
ioToPrimIO      :: IO a -&gt; PrimIO a
</pre><p>

<p>

<a name="io-1-3-prim-interface"><h4>Access to the <tt>PrimIO</tt> monad</h4></a>
<a name="PrimIO monad (Glasgow extension)"></a>
<p>
<a name="I/O, primitive (Glasgow extension)"></a>
<p>
In what we have implemented, <tt>PrimIO</tt> is the
handle-the-errors-yourself monad (NB: used for C-calls and such);
whereas <tt>IO</tt> is the 1.3-ish we-handle-errors-for-you monad.
<p>
Should you may need to play with the <tt>PrimIO</tt> monad directly, you
can import <tt>PreludeGlaST</tt>.
<p>
NB: You used to get this stuff from the <tt>PreludePrimIO</tt> interface,
which is now deceased.  As of 0.26, you get all things
state-transforming from the <tt>PreludeGlaST</tt> interface.
<p>
The usual monadic stuff for <tt>PrimIO</tt>:

<a name="PrimIO monad (Glasgow extension)"></a>
<a name="I/O, primitive (Glasgow extension)"></a>
<pre>
returnPrimIO    :: a -&gt; PrimIO a
thenPrimIO      :: PrimIO a -&gt; (a -&gt; PrimIO b) -&gt; PrimIO b
seqPrimIO       :: PrimIO a -&gt; PrimIO b -&gt; PrimIO b
fixPrimIO       :: (a -&gt; PrimIO a) -&gt; PrimIO a
foldrPrimIO     :: (a -&gt; b -&gt; PrimIO b) -&gt; PrimIO b -&gt; [a] -&gt; PrimIO b
listPrimIO      :: [PrimIO a] -&gt; PrimIO [a]
mapPrimIO       :: (a -&gt; PrimIO b) -&gt; [a] -&gt; PrimIO [b]
mapAndUnzipPrimIO :: (a -&gt; PrimIO (b,c)) -&gt; [a] -&gt; PrimIO ([b],[c])
forkPrimIO      :: PrimIO a -&gt; PrimIO a

unsafePerformPrimIO     :: PrimIO a -&gt; a
unsafeInterleavePrimIO  :: PrimIO a -&gt; PrimIO a
  -- and they are not called "unsafe" for nothing!
</pre><p>

And some other stuff:

<pre>
data _FILE  -- corresponds to a "FILE *" in C
            -- in classes Eq, _CCallable, and _CReturnable

fclose  :: _FILE -&gt; PrimIO Int
fdopen  :: Int -&gt; String -&gt; PrimIO _FILE
fflush  :: _FILE -&gt; PrimIO Int
fopen   :: String -&gt; String -&gt; PrimIO _FILE
fread   :: Int -&gt; Int -&gt; _FILE -&gt; PrimIO (Int, _ByteArray Int)
freopen :: String -&gt; String -&gt; _FILE -&gt; PrimIO _FILE
fwrite  :: _ByteArray Int -&gt; Int -&gt; Int -&gt; _FILE -&gt; PrimIO Int

-- please AVOID using these (They will probably die)
appendChanPrimIO :: String -&gt; String -&gt; PrimIO ()
appendFilePrimIO :: String -&gt; String -&gt; PrimIO ()
getArgsPrimIO    :: PrimIO [String]
readChanPrimIO   :: String -&gt; PrimIO String
</pre><p>

<p>

<a name="own-mainPrimIO"><h4>Using your own <a href="#mainPrimIO"><tt>mainPrimIO</tt></a></h4></a>
<a name="mainPrimIO, rolling your own"></a>
<p>
Normally, the GHC runtime system begins things by called an internal
function <a href="#mainPrimIO :: PrimIO ()"><tt>mainPrimIO :: PrimIO ()</tt></a> which, in turn, fires up
<a href="#dialogueToIO :: Dialogue -> IO ()"><tt>dialogueToIO :: Dialogue -> IO ()</tt></a>, linking in <i>your</i> <a href="#Main.main"><tt>Main.main</tt></a>
to provide the <a href="#Dialogue"><tt>Dialogue</tt></a>.
<p>
(If you give a <tt>-fhaskell-1.3</tt> flag, then a <i>different</i>
<a href="#mainPrimIO"><tt>mainPrimIO</tt></a> will be linked in -- that's why it is important to link
with <tt>-fhaskell-1.3</tt>...)
<p>
To subvert the above process, you need only provide
a <a href="#mainPrimIO :: PrimIO ()"><tt>mainPrimIO :: PrimIO ()</tt></a> of your own
(in a module named <tt>Main</tt>).  Do <i>not</i> use a <tt>-fhaskell-1.3</tt> flag!
<p>
Here's a little example, stolen from Alastair Reid:

<a name="mainPrimIO, rolling your own"></a>
<pre>
module Main ( mainPrimIO ) where

import PreludeGlaST

mainPrimIO :: PrimIO ()
mainPrimIO = 
         sleep 5                                `seqPrimIO`
         _ccall_ printf "%d\n" (14::Int)

sleep :: Int -&gt; PrimIO ()
sleep t = _ccall_ sleep t
</pre><p>




<p>

<a name="utils"><h2>Other Haskell utility programs</h2></a>
<a name="utilities, Haskell"></a>
<p>
This section describes other program(s) which we distribute, that help
with the Great Haskell Programming Task.
<p>

<a name="utilities, Haskell"></a>
<a name="mkdependHS"><h3>Makefile dependencies in Haskell: using <tt>mkdependHS</tt></h3></a>
<a name="mkdependHS"></a>
<p>
<a name="Makefile dependencies"></a>
<p>
<a name="dependencies in Makefiles"></a>
<p>
It is reasonably straightforward to set up a <tt>Makefile</tt> to use with
GHC, assuming you name your source files the same as your modules.
Thus:

<a name="mkdependHS"></a>
<a name="Makefile dependencies"></a>
<a name="dependencies in Makefiles"></a>
<pre>
HC      = ghc
HCFLAGS = -fhaskell-1.3 -cpp -hi-diffs $(EXTRA_HC_OPTS)

SRCS = Main.lhs Foo.lhs Bar.lhs
OBJS = Main.o   Foo.o   Bar.o

.SUFFIXES : .o .hi .lhs
.o.hi:
        @:
.lhs.o:
        $(RM) $@
        $(HC) -c $&lt; $(HCFLAGS)

cool_pgm : $(OBJS)
        $(RM) $@
        $(HC) -o $@ $(HCFLAGS) $(OBJS)
</pre><p>

Note the cheesy <tt>.o.hi</tt> rule: It records the dependency of the
interface (<tt>.hi</tt>) file on the source.  The rule says a <tt>.hi</tt>
file can be made from a <tt>.o</tt> file by doing... nothing.  Which is
true.
<p>
(Sophisticated <tt>make</tt> variants may achieve some of the above more
elegantly.  What we've shown should work with any <tt>make</tt>.)
<p>
The only thing lacking in the above <tt>Makefile</tt> is interface-file
dependencies.  If <tt>Foo.lhs</tt> imports module <tt>Bar</tt> and the
<tt>Bar</tt> interface changes, then <tt>Foo.lhs</tt> needs to be recompiled.
<p>
Putting dependencies of the form <tt>Foo.o : Bar.hi</tt> into your
<tt>Makefile</tt> by hand is rather error-prone.  Don't worry -- never
fear, <tt>mkdependHS</tt> is here! (and is distributed as part of GHC)
Add the following to your <tt>Makefile</tt>:

<pre>
depend :
        mkdependHS -- $(HCFLAGS) -- $(SRCS)
</pre><p>

Now, before you start compiling, and any time you change the
<tt>imports</tt> in your program, do <tt>make depend</tt> before you do
<tt>make cool_pgm</tt>.  <tt>mkdependHS</tt> will append the needed
dependencies to your <tt>Makefile</tt>.
<p>
A few caveats about this simple scheme: (a) You may need to compile
some modules explicitly to create their interfaces in the first place
(e.g., <tt>make Bar.o</tt> to create <tt>Bar.hi</tt>).  (b) You may have to
type <tt>make</tt> more than once for the dependencies to have full
effect.  However, a <tt>make</tt> run that does nothing <i>does</i> mean
"everything's up-to-date."  (c) This scheme will work with
mutually-recursive modules but, again, it may take multiple
iterations to "settle."
<p>
To see <tt>mkdependHS</tt>'s command-line flags, give it a duff flag,
e.g., <tt>mkdependHS -help</tt>.
<p>

<a name="hstags"><h3>Emacs `TAGS' for Haskell: <tt>hstags</tt></h3></a>
<a name="hstags"></a>
<p>
<a name="TAGS for Haskell"></a>
<p>
`Tags' is a facility for indexing the definitions of
programming-language things in a multi-file program, and then using
that index to jump around among these definitions.
<p>
Rather than scratch your head, saying "Now where did we define
`foo'?", you just do (in Emacs) <tt>M-. foo RET</tt>, and You're There!
Some people go wild over this stuff...
<p>
GHC comes with a program <tt>hstags</tt>, which build Emacs-able TAGS
files.  The invocation syntax is:

<a name="hstags"></a>
<a name="TAGS for Haskell"></a>
<pre>
hstags [GHC-options] file [files...]
</pre><p>

The best thing is just to feed it your GHC command-line flags.
A good Makefile entry might be:

<pre>
tags:
        $(RM) TAGS
        hstags $(GHC_FLAGS) *.lhs
</pre><p>

The only flags of its own are: <tt>-v</tt> to be verbose; <tt>-a</tt> to
**APPEND** to the TAGS file, rather than write to it.
<p>
Shortcomings: (1) Instance declarations don't get into the TAGS file
(but the definitions inside them do); as instances aren't named, this
is probably just as well.  (2) Data-constructor definitions don't get
in.  Go for the corresponding type constructor instead.
<p>
(Actually, GHC also comes with <tt>etags</tt> [for C], and <tt>perltags</tt>
[for You Know What].  And -- I cannot tell a lie -- there is Denis
Howe's <tt>fptags</tt> [for Haskell, etc.] in the <tt>ghc/CONTRIB</tt>
section...)
<p>

<a name="happy"><h3>"Yacc for Haskell": <tt>happy</tt></h3></a>
<a name="happy"></a>
<p>
<a name="Yacc for Haskell"></a>
<p>
<a name="parser generator for Haskell"></a>
<p>
Andy Gill and Simon Marlow have written a parser-generator for
Haskell, called <tt>happy</tt>.<a name="happy parser generator"></a>
 <tt>Happy</tt>
is to Haskell what <tt>Yacc</tt> is to C.
<p>
You can get <tt>happy</tt> by FTP from <tt>ftp.dcs.glasgow.ac.uk</tt> in
<tt>pub/haskell/happy</tt>, the file <tt>happy-0.8.tar.gz</tt>.
<p>
<tt>Happy</tt> is at its shining best when compiled by GHC.
<p>

<a name="happy"></a>
<a name="Yacc for Haskell"></a>
<a name="parser generator for Haskell"></a>
<a name="happy parser generator"></a>
<a name="pphs"><h3>Pretty-printing Haskell: <tt>pphs</tt></h3></a>
<a name="pphs"></a>
<p>
<a name="pretty-printing Haskell code"></a>
<p>
Andrew Preece has written
<tt>pphs</tt>,<a name="pphs"></a>
<a name="pretty-printing Haskell"></a>
<p>
a utility to pretty-print Haskell code in LaTeX documents.
Keywords in bolds, variables in italics -- that sort of thing.  It is
good at lining up program clauses and equals signs, things that are
very tiresome to do by hand.
<p>
The code is distributed with GHC in <tt>ghc/CONTRIB/pphs</tt>.

<a name="pphs"></a>
<a name="pretty-printing Haskell code"></a>
<a name="pphs"></a>
<a name="pretty-printing Haskell"></a>




<p>

<a name="ticky-ticky"><h2>Using "ticky-ticky" profiling (for implementors)</h2></a>
<a name="ticky-ticky profiling (implementors)"></a>
<p>
(<B>ToDo</B>: document properly.)
<p>
It is possible to compile Glasgow Haskell programs so that they will
count lots and lots of interesting things, e.g., number of updates,
number of data constructors entered, etc., etc.  We call this
"ticky-ticky" profiling,<a name="ticky-ticky profiling"></a>
<p>
<a name="profiling, ticky-ticky"></a>
 because that's the sound a Sun4 makes
when it is running up all those counters (<i>slowly</i>).
<p>
Ticky-ticky profiling is mainly intended for implementors; it is quite
separate from the main "cost-centre" profiling system, intended for
all users everywhere.
<p>
To be able to use ticky-ticky profiling, you will need to have built
appropriate libraries and things when you made the system.  See
"Customising what libraries to build," in the installation guide.
<p>
To get your compiled program to spit out the ticky-ticky numbers, use
a <tt>-r</tt> RTS option<a name="-r RTS option"></a>
.

<a name="ticky-ticky profiling (implementors)"></a>
<a name="ticky-ticky profiling"></a>
<a name="profiling, ticky-ticky"></a>
<a name="-r RTS option"></a>




<p>

<a name="compiler-tutorial"><h2>Tutorial material about this compilation system</h2></a>

This guide assumes quite a bit of knowledge about UNIX compilers and
their conventional use.  This section has a little extra information
for those who are new at this racket.
<p>

<a name="batch-system-parts"><h3>The (batch) compilation system components</h3></a>

<p>
The Glorious Haskell Compilation System, as with most UNIX (batch)
compilation systems, has several interacting parts:
<ul>
<li>A <i>driver</i><a name="driver program"></a>
 <tt>ghc</tt><a name="ghc"></a>
 -- which you
usually think of as "the compiler" -- is a program that merely
invokes/glues-together the other pieces of the system (listed below),
passing the right options to each, slurping in the right libraries,
etc.
<p>
<li>A <i>literate pre-processor</i>
<a name="literate pre-processor"></a>
<p>
<a name="pre-processor, literate"></a>
<p>
<tt>unlit</tt><a name="unlit"></a>
 that extracts Haskell
code from a literate script; used if you believe in that sort of
thing.
<p>
<li>The <i>Haskellised C pre-processor</i>
<a name="Haskellised C pre-processor"></a>
<p>
<a name="C pre-processor, Haskellised"></a>
<p>
<a name="pre-processor, Haskellised C"></a>
<p>
<tt>hscpp</tt>,<a name="hscpp"></a>
 only needed by people requiring conditional
compilation, probably for large systems.  The "Haskellised" part
just means that <tt>#line</tt> directives in the output have been
converted into proper Haskell <tt>\{-# LINE ... -\}</tt> pragmas.
<p>
You must give an explicit <tt>-cpp</tt> option 
<a name="-cpp option"></a>
 for the C pre-processor to be invoked.
<p>
<li>The <i>Haskell compiler</i>
<a name="Haskell compiler"></a>
<p>
<a name="compiler, Haskell"></a>
<p>
<tt>hsc</tt>,<a name="hsc"></a>
<p>
which -- in normal use -- takes its input from the C pre-processor
and produces assembly-language output (sometimes: ANSI C output).
<p>
<li>The <i>ANSI C Haskell high-level assembler :-)</i>
<a name="ANSI C compiler"></a>
<p>
<a name="high-level assembler"></a>
<p>
<a name="assembler, high-level"></a>
<p>
compiles <tt>hsc</tt>'s C output into assembly language for a particular
target architecture.  (It doesn't have to be an ANSI C compiler, but
that's preferred; to go fastest, you need GNU C, version 2.x.)
<p>
<li>The <i>assembler</i><a name="assembler"></a>
 -- a standard UNIX one, probably
<tt>as</tt><a name="as"></a>
.
<p>
<li>The <i>linker</i><a name="linker"></a>
 -- a standard UNIX one, probably
<tt>ld</tt>.<a name="ld"></a>
<p>
<li>A <i>runtime system</i>,<a name="runtime system"></a>
 including (most notably)
a storage manager; the linker links in the code for this.
<p>
<li>The <i>Haskell standard prelude</i><a name="standard prelude"></a>
, a
large library of standard functions, is linked in as well.
<p>
<li>Parts of other <i>installed libraries</i> that you have at your site
may be linked in also.
</ul>
<p>

<a name="driver program"></a>
<a name="ghc"></a>
<a name="literate pre-processor"></a>
<a name="pre-processor, literate"></a>
<a name="unlit"></a>
<a name="Haskellised C pre-processor"></a>
<a name="C pre-processor, Haskellised"></a>
<a name="pre-processor, Haskellised C"></a>
<a name="hscpp"></a>
<a name="-cpp option"></a>
<a name="Haskell compiler"></a>
<a name="compiler, Haskell"></a>
<a name="hsc"></a>
<a name="ANSI C compiler"></a>
<a name="high-level assembler"></a>
<a name="assembler, high-level"></a>
<a name="assembler"></a>
<a name="as"></a>
<a name="linker"></a>
<a name="ld"></a>
<a name="runtime system"></a>
<a name="standard prelude"></a>
<a name="compile-what-really-happens"><h3>What really happens when I "compile" a Haskell program?</h3></a>

<p>
You invoke the Glasgow Haskell compilation system through the
driver program <tt>ghc</tt>.<a name="ghc"></a>
 For example, if you had typed a
literate "Hello, world!" program into <tt>hello.lhs</tt>, and you then
invoked:

<a name="ghc"></a>
<pre>
ghc hello.lhs
</pre><p>

the following would happen:
<ul>
<li>The file <tt>hello.lhs</tt> is run through the literate-program
code extractor <tt>unlit</tt><a name="unlit"></a>
, feeding its output to
<p>
<li>The Haskell compiler proper <tt>hsc</tt><a name="hsc"></a>
, which produces
input for
<p>
<li>The assembler (or that ubiquitous "high-level assembler," a C
compiler), which produces an object file and passes it to
<p>
<li>The linker, which links your code with the appropriate libraries
(including the standard prelude), producing an executable program in
the default output file named <tt>a.out</tt>.
</ul>
<p>
You have considerable control over the compilation process.  You feed
command-line arguments (call them "options," for short) to the
driver, <tt>ghc</tt>; the "types" of the input files (as encoded in
their names' suffixes) also matter.
<p>
Here's hoping this is enough background so that you can read the rest
of this guide!
<p>

<a name="unlit"></a>
<a name="hsc"></a>



<p>

<address>Generated by The AQUA Team  Department of Computing Science  University of Glasgow  Glasgow, Scotland  G12 8QQ    Email: glasgow-haskell-{bugs,users}-request@dcs.glasgow.ac.uk  using <tt>lit2html</tt></address></body></html>
