{-# GHC_PRAGMA INTERFACE VERSION 6 #-}
interface Word where
infixl 7 `bitAnd`
infixl 8 `bitLsh`
infixl 5 `bitOr`
infixl 8 `bitRsh`
infixl 6 `bitXor`
class Bits a where
	bitAnd :: a -> a -> a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 122 _N_ _S_ "U(SAAAAAAAA)" {_A_ 1 _U_ 122 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> u0 -> u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> u2; _NO_DEFLT_ } _N_
		{-defm-} _A_ 3 _U_ 022 _N_ _S_ _!_ _N_ _N_ #-}
	bitOr :: a -> a -> a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 122 _N_ _S_ "U(ASAAAAAAA)" {_A_ 1 _U_ 122 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> u0 -> u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> u3; _NO_DEFLT_ } _N_
		{-defm-} _A_ 3 _U_ 022 _N_ _S_ _!_ _N_ _N_ #-}
	bitXor :: a -> a -> a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 122 _N_ _S_ "U(AASAAAAAA)" {_A_ 1 _U_ 122 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> u0 -> u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> u4; _NO_DEFLT_ } _N_
		{-defm-} _A_ 3 _U_ 022 _N_ _S_ _!_ _N_ _N_ #-}
	bitCompl :: a -> a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 12 _N_ _S_ "U(AAASAAAAA)" {_A_ 1 _U_ 12 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> u5; _NO_DEFLT_ } _N_
		{-defm-} _A_ 2 _U_ 02 _N_ _S_ _!_ _N_ _N_ #-}
	bitRsh :: a -> Int -> a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 122 _N_ _S_ "U(AAAASAAAA)" {_A_ 1 _U_ 122 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> Int -> u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> u6; _NO_DEFLT_ } _N_
		{-defm-} _A_ 3 _U_ 022 _N_ _S_ _!_ _N_ _N_ #-}
	bitLsh :: a -> Int -> a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 122 _N_ _S_ "U(AAAAASAAA)" {_A_ 1 _U_ 122 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> Int -> u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> u7; _NO_DEFLT_ } _N_
		{-defm-} _A_ 3 _U_ 022 _N_ _S_ _!_ _N_ _N_ #-}
	bitSwap :: a -> a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 12 _N_ _S_ "U(AAAAAASAA)" {_A_ 1 _U_ 12 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> u8; _NO_DEFLT_ } _N_
		{-defm-} _A_ 2 _U_ 02 _N_ _S_ _!_ _N_ _N_ #-}
	bit0 :: a
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 1 _N_ _S_ "U(AAAAAAASA)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> u9; _NO_DEFLT_ } _N_
		{-defm-} _A_ 1 _U_ 0 _N_ _S_ _!_ _N_ _N_ #-}
	bitSize :: a -> Int
	 {-# GHC_PRAGMA {-meth-} _A_ 1 _U_ 12 _N_ _S_ "U(AAAAAAAAS)" {_A_ 1 _U_ 12 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0 -> Int) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: (u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0 -> u0, u0 -> u0, u0 -> Int -> u0, u0 -> Int -> u0, u0 -> u0, u0, u0 -> Int)) -> case u1 of { _ALG_ _TUP_9 (u2 :: u0 -> u0 -> u0) (u3 :: u0 -> u0 -> u0) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0) (u6 :: u0 -> Int -> u0) (u7 :: u0 -> Int -> u0) (u8 :: u0 -> u0) (u9 :: u0) (ua :: u0 -> Int) -> ua; _NO_DEFLT_ } _N_
		{-defm-} _A_ 2 _U_ 02 _N_ _S_ _!_ _N_ _N_ #-}
data Byte 	{-# GHC_PRAGMA Byte Word# #-}
data Short 	{-# GHC_PRAGMA Short Word# #-}
data Word 	{-# GHC_PRAGMA Word Word# #-}
byteToInt :: Byte -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Word#) -> case _#_ word2Int# [] [u0] of { _PRIM_ (u1 :: Int#) -> _!_ I# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Byte) -> case u0 of { _ALG_ _ORIG_ Word Byte (u1 :: Word#) -> case _#_ word2Int# [] [u1] of { _PRIM_ (u2 :: Int#) -> _!_ I# [] [u2] }; _NO_DEFLT_ } _N_ #-}
bytesToString :: [Byte] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
shortToInt :: Short -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Word#) -> case _#_ word2Int# [] [u0] of { _PRIM_ (u1 :: Int#) -> _!_ I# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Short) -> case u0 of { _ALG_ _ORIG_ Word Short (u1 :: Word#) -> case _#_ word2Int# [] [u1] of { _PRIM_ (u2 :: Int#) -> _!_ I# [] [u2] }; _NO_DEFLT_ } _N_ #-}
wordToBytes :: Word -> [Byte]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
wordToInt :: Word -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Word#) -> case _#_ word2Int# [] [u0] of { _PRIM_ (u1 :: Int#) -> _!_ I# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Word) -> case u0 of { _ALG_ _ORIG_ Word Word (u1 :: Word#) -> case _#_ word2Int# [] [u1] of { _PRIM_ (u2 :: Int#) -> _!_ I# [] [u2] }; _NO_DEFLT_ } _N_ #-}
wordToShorts :: Word -> [Short]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
instance Eq Byte
	{-# GHC_PRAGMA _M_ Word {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Byte -> Byte -> Bool), (Byte -> Byte -> Bool)] [_CONSTM_ Eq (==) (Byte), _CONSTM_ Eq (/=) (Byte)] _N_
	 (==) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Word#) (u1 :: Word#) -> _#_ eqWord# [] [u0, u1] _N_} _F_ _IF_ARGS_ 0 2 CC 3 \ (u0 :: Byte) (u1 :: Byte) -> case u0 of { _ALG_ _ORIG_ Word Byte (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word Byte (u3 :: Word#) -> _#_ eqWord# [] [u2, u3]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 (/=) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 5 \ (u0 :: Word#) (u1 :: Word#) -> case _#_ eqWord# [] [u0, u1] of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ } _N_} _F_ _IF_ARGS_ 0 2 CC 7 \ (u0 :: Byte) (u1 :: Byte) -> case u0 of { _ALG_ _ORIG_ Word Byte (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word Byte (u3 :: Word#) -> case _#_ eqWord# [] [u2, u3] of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ } #-}
instance Eq Short
	{-# GHC_PRAGMA _M_ Word {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Short -> Short -> Bool), (Short -> Short -> Bool)] [_CONSTM_ Eq (==) (Short), _CONSTM_ Eq (/=) (Short)] _N_
	 (==) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Word#) (u1 :: Word#) -> _#_ eqWord# [] [u0, u1] _N_} _F_ _IF_ARGS_ 0 2 CC 3 \ (u0 :: Short) (u1 :: Short) -> case u0 of { _ALG_ _ORIG_ Word Short (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word Short (u3 :: Word#) -> _#_ eqWord# [] [u2, u3]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 (/=) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 5 \ (u0 :: Word#) (u1 :: Word#) -> case _#_ eqWord# [] [u0, u1] of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ } _N_} _F_ _IF_ARGS_ 0 2 CC 7 \ (u0 :: Short) (u1 :: Short) -> case u0 of { _ALG_ _ORIG_ Word Short (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word Short (u3 :: Word#) -> case _#_ eqWord# [] [u2, u3] of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ } #-}
instance Eq Word
	{-# GHC_PRAGMA _M_ Word {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Word -> Word -> Bool), (Word -> Word -> Bool)] [_CONSTM_ Eq (==) (Word), _CONSTM_ Eq (/=) (Word)] _N_
	 (==) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Word#) (u1 :: Word#) -> _#_ eqWord# [] [u0, u1] _N_} _F_ _IF_ARGS_ 0 2 CC 3 \ (u0 :: Word) (u1 :: Word) -> case u0 of { _ALG_ _ORIG_ Word Word (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word Word (u3 :: Word#) -> _#_ eqWord# [] [u2, u3]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 (/=) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 5 \ (u0 :: Word#) (u1 :: Word#) -> case _#_ eqWord# [] [u0, u1] of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ } _N_} _F_ _IF_ARGS_ 0 2 CC 7 \ (u0 :: Word) (u1 :: Word) -> case u0 of { _ALG_ _ORIG_ Word Word (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word Word (u3 :: Word#) -> case _#_ eqWord# [] [u2, u3] of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ } #-}
instance Num Byte
	{-# GHC_PRAGMA _M_ Word {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 11 _!_ _TUP_10 [{{Eq Byte}}, {{Text Byte}}, (Byte -> Byte -> Byte), (Byte -> Byte -> Byte), (Byte -> Byte -> Byte), (Byte -> Byte), (Byte -> Byte), (Byte -> Byte), (Integer -> Byte), (Int -> Byte)] [_DFUN_ Eq (Byte), _DFUN_ Text (Byte), _CONSTM_ Num (+) (Byte), _CONSTM_ Num (-) (Byte), _CONSTM_ Num (*) (Byte), _CONSTM_ Num negate (Byte), _CONSTM_ Num abs (Byte), _CONSTM_ Num signum (Byte), _CONSTM_ Num fromInteger (Byte), _CONSTM_ Num fromInt (Byte)] _N_
	 (+) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 (-) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 (*) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 negate = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ },
	 abs = { _A_ 1 _U_ 2 _N_ _S_ _!_ _N_ _N_ },
	 signum = { _A_ 1 _U_ 2 _N_ _S_ _!_ _N_ _N_ },
	 fromInteger = { _A_ 1 _U_ 1 _N_ _S_ "U(PPP)" {_A_ 3 _U_ 222 _N_ _N_ _F_ _IF_ARGS_ 0 3 XXX 6 \ (u0 :: Int#) (u1 :: Int#) (u2 :: ByteArray#) -> case _#_ integer2Int# [] [u0, u1, u2] of { _PRIM_ (u3 :: Int#) -> case _#_ int2Word# [] [u3] of { _PRIM_ (u4 :: Word#) -> case _#_ int2Word# [] [255#] of { _PRIM_ (u5 :: Word#) -> case _#_ and# [] [u4, u5] of { _PRIM_ (u6 :: Word#) -> _!_ _ORIG_ Word Byte [] [u6] } } } } _N_} _F_ _ALWAYS_ \ (u0 :: Integer) -> case u0 of { _ALG_ J# (u1 :: Int#) (u2 :: Int#) (u3 :: ByteArray#) -> case _#_ integer2Int# [] [u1, u2, u3] of { _PRIM_ (u4 :: Int#) -> case _#_ int2Word# [] [u4] of { _PRIM_ (u5 :: Word#) -> case _#_ int2Word# [] [255#] of { _PRIM_ (u6 :: Word#) -> case _#_ and# [] [u5, u6] of { _PRIM_ (u7 :: Word#) -> _!_ _ORIG_ Word Byte [] [u7] } } } }; _NO_DEFLT_ } _N_ },
	 fromInt = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
instance Num Short
	{-# GHC_PRAGMA _M_ Word {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 11 _!_ _TUP_10 [{{Eq Short}}, {{Text Short}}, (Short -> Short -> Short), (Short -> Short -> Short), (Short -> Short -> Short), (Short -> Short), (Short -> Short), (Short -> Short), (Integer -> Short), (Int -> Short)] [_DFUN_ Eq (Short), _DFUN_ Text (Short), _CONSTM_ Num (+) (Short), _CONSTM_ Num (-) (Short), _CONSTM_ Num (*) (Short), _CONSTM_ Num negate (Short), _CONSTM_ Num abs (Short), _CONSTM_ Num signum (Short), _CONSTM_ Num fromInteger (Short), _CONSTM_ Num fromInt (Short)] _N_
	 (+) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 (-) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 (*) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 negate = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ },
	 abs = { _A_ 1 _U_ 2 _N_ _S_ _!_ _N_ _N_ },
	 signum = { _A_ 1 _U_ 2 _N_ _S_ _!_ _N_ _N_ },
	 fromInteger = { _A_ 1 _U_ 1 _N_ _S_ "U(PPP)" {_A_ 3 _U_ 222 _N_ _N_ _F_ _IF_ARGS_ 0 3 XXX 6 \ (u0 :: Int#) (u1 :: Int#) (u2 :: ByteArray#) -> case _#_ integer2Int# [] [u0, u1, u2] of { _PRIM_ (u3 :: Int#) -> case _#_ int2Word# [] [u3] of { _PRIM_ (u4 :: Word#) -> case _#_ int2Word# [] [65535#] of { _PRIM_ (u5 :: Word#) -> case _#_ and# [] [u4, u5] of { _PRIM_ (u6 :: Word#) -> _!_ _ORIG_ Word Short [] [u6] } } } } _N_} _F_ _ALWAYS_ \ (u0 :: Integer) -> case u0 of { _ALG_ J# (u1 :: Int#) (u2 :: Int#) (u3 :: ByteArray#) -> case _#_ integer2Int# [] [u1, u2, u3] of { _PRIM_ (u4 :: Int#) -> case _#_ int2Word# [] [u4] of { _PRIM_ (u5 :: Word#) -> case _#_ int2Word# [] [65535#] of { _PRIM_ (u6 :: Word#) -> case _#_ and# [] [u5, u6] of { _PRIM_ (u7 :: Word#) -> _!_ _ORIG_ Word Short [] [u7] } } } }; _NO_DEFLT_ } _N_ },
	 fromInt = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
instance Num Word
	{-# GHC_PRAGMA _M_ Word {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 11 _!_ _TUP_10 [{{Eq Word}}, {{Text Word}}, (Word -> Word -> Word), (Word -> Word -> Word), (Word -> Word -> Word), (Word -> Word), (Word -> Word), (Word -> Word), (Integer -> Word), (Int -> Word)] [_DFUN_ Eq (Word), _DFUN_ Text (Word), _CONSTM_ Num (+) (Word), _CONSTM_ Num (-) (Word), _CONSTM_ Num (*) (Word), _CONSTM_ Num negate (Word), _CONSTM_ Num abs (Word), _CONSTM_ Num signum (Word), _CONSTM_ Num fromInteger (Word), _CONSTM_ Num fromInt (Word)] _N_
	 (+) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 (-) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 (*) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 negate = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ },
	 abs = { _A_ 1 _U_ 2 _N_ _S_ _!_ _N_ _N_ },
	 signum = { _A_ 1 _U_ 2 _N_ _S_ _!_ _N_ _N_ },
	 fromInteger = { _A_ 1 _U_ 1 _N_ _S_ "U(PPP)" {_A_ 3 _U_ 222 _N_ _N_ _F_ _IF_ARGS_ 0 3 XXX 4 \ (u0 :: Int#) (u1 :: Int#) (u2 :: ByteArray#) -> case _#_ integer2Int# [] [u0, u1, u2] of { _PRIM_ (u3 :: Int#) -> case _#_ int2Word# [] [u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word Word [] [u4] } } _N_} _F_ _IF_ARGS_ 0 1 C 5 \ (u0 :: Integer) -> case u0 of { _ALG_ J# (u1 :: Int#) (u2 :: Int#) (u3 :: ByteArray#) -> case _#_ integer2Int# [] [u1, u2, u3] of { _PRIM_ (u4 :: Int#) -> case _#_ int2Word# [] [u4] of { _PRIM_ (u5 :: Word#) -> _!_ _ORIG_ Word Word [] [u5] } }; _NO_DEFLT_ } _N_ },
	 fromInt = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Int#) -> case _#_ int2Word# [] [u0] of { _PRIM_ (u1 :: Word#) -> _!_ _ORIG_ Word Word [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Int) -> case u0 of { _ALG_ I# (u1 :: Int#) -> case _#_ int2Word# [] [u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word Word [] [u2] }; _NO_DEFLT_ } _N_ } #-}
instance Ord Byte
	{-# GHC_PRAGMA _M_ Word {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 9 _!_ _TUP_8 [{{Eq Byte}}, (Byte -> Byte -> Bool), (Byte -> Byte -> Bool), (Byte -> Byte -> Bool), (Byte -> Byte -> Bool), (Byte -> Byte -> Byte), (Byte -> Byte -> Byte), (Byte -> Byte -> _CMP_TAG)] [_DFUN_ Eq (Byte), _CONSTM_ Ord (<) (Byte), _CONSTM_ Ord (<=) (Byte), _CONSTM_ Ord (>=) (Byte), _CONSTM_ Ord (>) (Byte), _CONSTM_ Ord max (Byte), _CONSTM_ Ord min (Byte), _CONSTM_ Ord _tagCmp (Byte)] _N_
	 (<) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 (<=) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 (>=) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 (>) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 max = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 min = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 _tagCmp = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
instance Ord Short
	{-# GHC_PRAGMA _M_ Word {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 9 _!_ _TUP_8 [{{Eq Short}}, (Short -> Short -> Bool), (Short -> Short -> Bool), (Short -> Short -> Bool), (Short -> Short -> Bool), (Short -> Short -> Short), (Short -> Short -> Short), (Short -> Short -> _CMP_TAG)] [_DFUN_ Eq (Short), _CONSTM_ Ord (<) (Short), _CONSTM_ Ord (<=) (Short), _CONSTM_ Ord (>=) (Short), _CONSTM_ Ord (>) (Short), _CONSTM_ Ord max (Short), _CONSTM_ Ord min (Short), _CONSTM_ Ord _tagCmp (Short)] _N_
	 (<) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 (<=) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 (>=) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 (>) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 max = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 min = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 _tagCmp = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
instance Ord Word
	{-# GHC_PRAGMA _M_ Word {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 9 _!_ _TUP_8 [{{Eq Word}}, (Word -> Word -> Bool), (Word -> Word -> Bool), (Word -> Word -> Bool), (Word -> Word -> Bool), (Word -> Word -> Word), (Word -> Word -> Word), (Word -> Word -> _CMP_TAG)] [_DFUN_ Eq (Word), _CONSTM_ Ord (<) (Word), _CONSTM_ Ord (<=) (Word), _CONSTM_ Ord (>=) (Word), _CONSTM_ Ord (>) (Word), _CONSTM_ Ord max (Word), _CONSTM_ Ord min (Word), _CONSTM_ Ord _tagCmp (Word)] _N_
	 (<) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 (<=) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 (>=) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 (>) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 max = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 min = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 _tagCmp = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
instance Text Byte
	{-# GHC_PRAGMA _M_ Word {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Byte, [Char])]), (Int -> Byte -> [Char] -> [Char]), ([Char] -> [([Byte], [Char])]), ([Byte] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Byte), _CONSTM_ Text showsPrec (Byte), _CONSTM_ Text readList (Byte), _CONSTM_ Text showList (Byte)] _N_
	 readsPrec = { _A_ 2 _U_ 22 _N_ _S_ _!_ _N_ _N_ },
	 showsPrec = { _A_ 2 _U_ 012 _N_ _S_ "AU(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 readList = { _A_ 1 _U_ 2 _N_ _S_ _!_ _N_ _N_ },
	 showList = { _A_ 2 _U_ 22 _N_ _S_ _!_ _N_ _N_ } #-}
instance Text Short
	{-# GHC_PRAGMA _M_ Word {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Short, [Char])]), (Int -> Short -> [Char] -> [Char]), ([Char] -> [([Short], [Char])]), ([Short] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Short), _CONSTM_ Text showsPrec (Short), _CONSTM_ Text readList (Short), _CONSTM_ Text showList (Short)] _N_
	 readsPrec = { _A_ 2 _U_ 22 _N_ _S_ _!_ _N_ _N_ },
	 showsPrec = { _A_ 2 _U_ 012 _N_ _S_ "AU(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 readList = { _A_ 1 _U_ 2 _N_ _S_ _!_ _N_ _N_ },
	 showList = { _A_ 2 _U_ 22 _N_ _S_ _!_ _N_ _N_ } #-}
instance Text Word
	{-# GHC_PRAGMA _M_ Word {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Word, [Char])]), (Int -> Word -> [Char] -> [Char]), ([Char] -> [([Word], [Char])]), ([Word] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Word), _CONSTM_ Text showsPrec (Word), _CONSTM_ Text readList (Word), _CONSTM_ Text showList (Word)] _N_
	 readsPrec = { _A_ 2 _U_ 22 _N_ _S_ _!_ _N_ _N_ },
	 showsPrec = { _A_ 2 _U_ 012 _N_ _S_ "AU(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 readList = { _A_ 1 _U_ 2 _N_ _S_ _!_ _N_ _N_ },
	 showList = { _A_ 2 _U_ 22 _N_ _S_ _!_ _N_ _N_ } #-}
instance Bits Byte
	{-# GHC_PRAGMA _M_ Word {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 10 _!_ _TUP_9 [(Byte -> Byte -> Byte), (Byte -> Byte -> Byte), (Byte -> Byte -> Byte), (Byte -> Byte), (Byte -> Int -> Byte), (Byte -> Int -> Byte), (Byte -> Byte), Byte, (Byte -> Int)] [_CONSTM_ Bits bitAnd (Byte), _CONSTM_ Bits bitOr (Byte), _CONSTM_ Bits bitXor (Byte), _CONSTM_ Bits bitCompl (Byte), _CONSTM_ Bits bitRsh (Byte), _CONSTM_ Bits bitLsh (Byte), _CONSTM_ Bits bitSwap (Byte), _CONSTM_ Bits bit0 (Byte), _CONSTM_ Bits bitSize (Byte)] _N_
	 bitAnd = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Word#) (u1 :: Word#) -> case _#_ and# [] [u0, u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word Byte [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Byte) (u1 :: Byte) -> case u0 of { _ALG_ _ORIG_ Word Byte (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word Byte (u3 :: Word#) -> case _#_ and# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word Byte [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 bitOr = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Word#) (u1 :: Word#) -> case _#_ or# [] [u0, u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word Byte [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Byte) (u1 :: Byte) -> case u0 of { _ALG_ _ORIG_ Word Byte (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word Byte (u3 :: Word#) -> case _#_ or# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word Byte [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 bitXor = { _A_ 2 _U_ 11 _N_ _S_ _!_ _N_ _N_ },
	 bitCompl = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ },
	 bitRsh = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Word#) (u1 :: Int#) -> case _#_ shiftRL# [] [u0, u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word Byte [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Byte) (u1 :: Int) -> case u0 of { _ALG_ _ORIG_ Word Byte (u2 :: Word#) -> case u1 of { _ALG_ I# (u3 :: Int#) -> case _#_ shiftRL# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word Byte [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 bitLsh = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 5 \ (u0 :: Word#) (u1 :: Int#) -> case _#_ shiftL# [] [u0, u1] of { _PRIM_ (u2 :: Word#) -> case _#_ int2Word# [] [255#] of { _PRIM_ (u3 :: Word#) -> case _#_ and# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word Byte [] [u4] } } } _N_} _F_ _IF_ARGS_ 0 2 CC 7 \ (u0 :: Byte) (u1 :: Int) -> case u0 of { _ALG_ _ORIG_ Word Byte (u2 :: Word#) -> case u1 of { _ALG_ I# (u3 :: Int#) -> case _#_ shiftL# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> case _#_ int2Word# [] [255#] of { _PRIM_ (u5 :: Word#) -> case _#_ and# [] [u4, u5] of { _PRIM_ (u6 :: Word#) -> _!_ _ORIG_ Word Byte [] [u6] } } }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 bitSwap = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ },
	 bit0 = { _A_ 0 _N_ _N_ _N_ _N_ _N_ },
	 bitSize = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 0 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 2 \ (u0 :: Word#) -> _!_ I# [] [8#] _N_} _F_ _IF_ARGS_ 0 1 C 3 \ (u0 :: Byte) -> case u0 of { _ALG_ _ORIG_ Word Byte (u1 :: Word#) -> _!_ I# [] [8#]; _NO_DEFLT_ } _N_ } #-}
instance Bits Short
	{-# GHC_PRAGMA _M_ Word {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 10 _!_ _TUP_9 [(Short -> Short -> Short), (Short -> Short -> Short), (Short -> Short -> Short), (Short -> Short), (Short -> Int -> Short), (Short -> Int -> Short), (Short -> Short), Short, (Short -> Int)] [_CONSTM_ Bits bitAnd (Short), _CONSTM_ Bits bitOr (Short), _CONSTM_ Bits bitXor (Short), _CONSTM_ Bits bitCompl (Short), _CONSTM_ Bits bitRsh (Short), _CONSTM_ Bits bitLsh (Short), _CONSTM_ Bits bitSwap (Short), _CONSTM_ Bits bit0 (Short), _CONSTM_ Bits bitSize (Short)] _N_
	 bitAnd = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Word#) (u1 :: Word#) -> case _#_ and# [] [u0, u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word Short [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Short) (u1 :: Short) -> case u0 of { _ALG_ _ORIG_ Word Short (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word Short (u3 :: Word#) -> case _#_ and# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word Short [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 bitOr = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Word#) (u1 :: Word#) -> case _#_ or# [] [u0, u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word Short [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Short) (u1 :: Short) -> case u0 of { _ALG_ _ORIG_ Word Short (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word Short (u3 :: Word#) -> case _#_ or# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word Short [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 bitXor = { _A_ 2 _U_ 11 _N_ _S_ _!_ _N_ _N_ },
	 bitCompl = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ },
	 bitRsh = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Word#) (u1 :: Int#) -> case _#_ shiftRL# [] [u0, u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word Short [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Short) (u1 :: Int) -> case u0 of { _ALG_ _ORIG_ Word Short (u2 :: Word#) -> case u1 of { _ALG_ I# (u3 :: Int#) -> case _#_ shiftRL# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word Short [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 bitLsh = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 5 \ (u0 :: Word#) (u1 :: Int#) -> case _#_ shiftL# [] [u0, u1] of { _PRIM_ (u2 :: Word#) -> case _#_ int2Word# [] [65535#] of { _PRIM_ (u3 :: Word#) -> case _#_ and# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word Short [] [u4] } } } _N_} _F_ _IF_ARGS_ 0 2 CC 7 \ (u0 :: Short) (u1 :: Int) -> case u0 of { _ALG_ _ORIG_ Word Short (u2 :: Word#) -> case u1 of { _ALG_ I# (u3 :: Int#) -> case _#_ shiftL# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> case _#_ int2Word# [] [65535#] of { _PRIM_ (u5 :: Word#) -> case _#_ and# [] [u4, u5] of { _PRIM_ (u6 :: Word#) -> _!_ _ORIG_ Word Short [] [u6] } } }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 bitSwap = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ },
	 bit0 = { _A_ 0 _N_ _N_ _N_ _N_ _N_ },
	 bitSize = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 0 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 2 \ (u0 :: Word#) -> _!_ I# [] [16#] _N_} _F_ _IF_ARGS_ 0 1 C 3 \ (u0 :: Short) -> case u0 of { _ALG_ _ORIG_ Word Short (u1 :: Word#) -> _!_ I# [] [16#]; _NO_DEFLT_ } _N_ } #-}
instance Bits Word
	{-# GHC_PRAGMA _M_ Word {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 10 _!_ _TUP_9 [(Word -> Word -> Word), (Word -> Word -> Word), (Word -> Word -> Word), (Word -> Word), (Word -> Int -> Word), (Word -> Int -> Word), (Word -> Word), Word, (Word -> Int)] [_CONSTM_ Bits bitAnd (Word), _CONSTM_ Bits bitOr (Word), _CONSTM_ Bits bitXor (Word), _CONSTM_ Bits bitCompl (Word), _CONSTM_ Bits bitRsh (Word), _CONSTM_ Bits bitLsh (Word), _CONSTM_ Bits bitSwap (Word), _CONSTM_ Bits bit0 (Word), _CONSTM_ Bits bitSize (Word)] _N_
	 bitAnd = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Word#) (u1 :: Word#) -> case _#_ and# [] [u0, u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word Word [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Word) (u1 :: Word) -> case u0 of { _ALG_ _ORIG_ Word Word (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word Word (u3 :: Word#) -> case _#_ and# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word Word [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 bitOr = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Word#) (u1 :: Word#) -> case _#_ or# [] [u0, u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word Word [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Word) (u1 :: Word) -> case u0 of { _ALG_ _ORIG_ Word Word (u2 :: Word#) -> case u1 of { _ALG_ _ORIG_ Word Word (u3 :: Word#) -> case _#_ or# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word Word [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 bitXor = { _A_ 2 _U_ 11 _N_ _S_ _!_ _N_ _N_ },
	 bitCompl = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Word#) -> case _#_ not# [] [u0] of { _PRIM_ (u1 :: Word#) -> _!_ _ORIG_ Word Word [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Word) -> case u0 of { _ALG_ _ORIG_ Word Word (u1 :: Word#) -> case _#_ not# [] [u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word Word [] [u2] }; _NO_DEFLT_ } _N_ },
	 bitRsh = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Word#) (u1 :: Int#) -> case _#_ shiftRL# [] [u0, u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word Word [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Word) (u1 :: Int) -> case u0 of { _ALG_ _ORIG_ Word Word (u2 :: Word#) -> case u1 of { _ALG_ I# (u3 :: Int#) -> case _#_ shiftRL# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word Word [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 bitLsh = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Word#) (u1 :: Int#) -> case _#_ shiftL# [] [u0, u1] of { _PRIM_ (u2 :: Word#) -> _!_ _ORIG_ Word Word [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Word) (u1 :: Int) -> case u0 of { _ALG_ _ORIG_ Word Word (u2 :: Word#) -> case u1 of { _ALG_ I# (u3 :: Int#) -> case _#_ shiftL# [] [u2, u3] of { _PRIM_ (u4 :: Word#) -> _!_ _ORIG_ Word Word [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 bitSwap = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ },
	 bit0 = { _A_ 0 _N_ _N_ _N_ _N_ _N_ },
	 bitSize = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 0 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 2 \ (u0 :: Word#) -> _!_ I# [] [32#] _N_} _F_ _IF_ARGS_ 0 1 C 3 \ (u0 :: Word) -> case u0 of { _ALG_ _ORIG_ Word Word (u1 :: Word#) -> _!_ I# [] [32#]; _NO_DEFLT_ } _N_ } #-}

