{-# GHC_PRAGMA INTERFACE VERSION 6 #-}
interface PreludeCore where
import PreludeBuiltin(Float(..))
instance Enum Float
	{-# GHC_PRAGMA _M_ PreludeCore {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 6 _!_ _TUP_5 [{{Ord Float}}, (Float -> [Float]), (Float -> Float -> [Float]), (Float -> Float -> [Float]), (Float -> Float -> Float -> [Float])] [_DFUN_ Ord (Float), _CONSTM_ Enum enumFrom (Float), _CONSTM_ Enum enumFromThen (Float), _CONSTM_ Enum enumFromTo (Float), _CONSTM_ Enum enumFromThenTo (Float)] _N_
	 enumFrom = { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ },
	 enumFromThen = { _A_ 2 _U_ 21 _N_ _N_ _N_ _N_ },
	 enumFromTo = { _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ },
	 enumFromThenTo = { _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ } #-}
instance Eq Float
	{-# GHC_PRAGMA _M_ PreludeCore {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _TUP_2 [(Float -> Float -> Bool), (Float -> Float -> Bool)] [_CONSTM_ Eq (==) (Float), _CONSTM_ Eq (/=) (Float)] _N_
	 (==) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Float#) (u1 :: Float#) -> _#_ eqFloat# [] [u0, u1] _N_} _F_ _IF_ARGS_ 0 2 CC 3 \ (u0 :: Float) (u1 :: Float) -> case u0 of { _ALG_ F# (u2 :: Float#) -> case u1 of { _ALG_ F# (u3 :: Float#) -> _#_ eqFloat# [] [u2, u3]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 (/=) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Float#) (u1 :: Float#) -> _#_ neFloat# [] [u0, u1] _N_} _F_ _IF_ARGS_ 0 2 CC 3 \ (u0 :: Float) (u1 :: Float) -> case u0 of { _ALG_ F# (u2 :: Float#) -> case u1 of { _ALG_ F# (u3 :: Float#) -> _#_ neFloat# [] [u2, u3]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ } #-}
instance Floating Float
	{-# GHC_PRAGMA _M_ PreludeCore {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 20 _!_ _TUP_19 [{{Fractional Float}}, Float, (Float -> Float), (Float -> Float), (Float -> Float), (Float -> Float -> Float), (Float -> Float -> Float), (Float -> Float), (Float -> Float), (Float -> Float), (Float -> Float), (Float -> Float), (Float -> Float), (Float -> Float), (Float -> Float), (Float -> Float), (Float -> Float), (Float -> Float), (Float -> Float)] [_DFUN_ Fractional (Float), _CONSTM_ Floating pi (Float), _CONSTM_ Floating exp (Float), _CONSTM_ Floating log (Float), _CONSTM_ Floating sqrt (Float), _CONSTM_ Floating (**) (Float), _CONSTM_ Floating logBase (Float), _CONSTM_ Floating sin (Float), _CONSTM_ Floating cos (Float), _CONSTM_ Floating tan (Float), _CONSTM_ Floating asin (Float), _CONSTM_ Floating acos (Float), _CONSTM_ Floating atan (Float), _CONSTM_ Floating sinh (Float), _CONSTM_ Floating cosh (Float), _CONSTM_ Floating tanh (Float), _CONSTM_ Floating asinh (Float), _CONSTM_ Floating acosh (Float), _CONSTM_ Floating atanh (Float)] _N_
	 pi = { _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _!_ F# [] [3.1415926535897931#] _N_ },
	 exp = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Float#) -> case _#_ expFloat# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> case _#_ expFloat# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ },
	 log = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Float#) -> case _#_ logFloat# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> case _#_ logFloat# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ },
	 sqrt = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Float#) -> case _#_ sqrtFloat# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> case _#_ sqrtFloat# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ },
	 (**) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Float#) (u1 :: Float#) -> case _#_ powerFloat# [] [u0, u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Float) (u1 :: Float) -> case u0 of { _ALG_ F# (u2 :: Float#) -> case u1 of { _ALG_ F# (u3 :: Float#) -> case _#_ powerFloat# [] [u2, u3] of { _PRIM_ (u4 :: Float#) -> _!_ F# [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 logBase = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 5 \ (u0 :: Float#) (u1 :: Float#) -> case _#_ logFloat# [] [u1] of { _PRIM_ (u2 :: Float#) -> case _#_ logFloat# [] [u0] of { _PRIM_ (u3 :: Float#) -> case _#_ divideFloat# [] [u2, u3] of { _PRIM_ (u4 :: Float#) -> _!_ F# [] [u4] } } } _N_} _F_ _IF_ARGS_ 0 2 CC 7 \ (u0 :: Float) (u1 :: Float) -> case u1 of { _ALG_ F# (u2 :: Float#) -> case _#_ logFloat# [] [u2] of { _PRIM_ (u3 :: Float#) -> case u0 of { _ALG_ F# (u4 :: Float#) -> case _#_ logFloat# [] [u4] of { _PRIM_ (u5 :: Float#) -> case _#_ divideFloat# [] [u3, u5] of { _PRIM_ (u6 :: Float#) -> _!_ F# [] [u6] } }; _NO_DEFLT_ } }; _NO_DEFLT_ } _N_ },
	 sin = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Float#) -> case _#_ sinFloat# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> case _#_ sinFloat# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ },
	 cos = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Float#) -> case _#_ cosFloat# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> case _#_ cosFloat# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ },
	 tan = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Float#) -> case _#_ tanFloat# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> case _#_ tanFloat# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ },
	 asin = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Float#) -> case _#_ asinFloat# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> case _#_ asinFloat# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ },
	 acos = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Float#) -> case _#_ acosFloat# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> case _#_ acosFloat# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ },
	 atan = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Float#) -> case _#_ atanFloat# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> case _#_ atanFloat# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ },
	 sinh = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Float#) -> case _#_ sinhFloat# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> case _#_ sinhFloat# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ },
	 cosh = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Float#) -> case _#_ coshFloat# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> case _#_ coshFloat# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ },
	 tanh = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Float#) -> case _#_ tanhFloat# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> case _#_ tanhFloat# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ },
	 asinh = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ },
	 acosh = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ },
	 atanh = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
instance Fractional Float
	{-# GHC_PRAGMA _M_ PreludeCore {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [{{Num Float}}, (Float -> Float -> Float), (Float -> Float), (Ratio Integer -> Float)] [_DFUN_ Num (Float), _CONSTM_ Fractional (/) (Float), _CONSTM_ Fractional recip (Float), _CONSTM_ Fractional fromRational (Float)] _N_
	 (/) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Float#) (u1 :: Float#) -> case _#_ divideFloat# [] [u0, u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Float) (u1 :: Float) -> case u0 of { _ALG_ F# (u2 :: Float#) -> case u1 of { _ALG_ F# (u3 :: Float#) -> case _#_ divideFloat# [] [u2, u3] of { _PRIM_ (u4 :: Float#) -> _!_ F# [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 recip = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Float#) -> case _#_ divideFloat# [] [1.0000000000000000#, u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> case _#_ divideFloat# [] [1.0000000000000000#, u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ },
	 fromRational = { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ } #-}
instance Num Float
	{-# GHC_PRAGMA _M_ PreludeCore {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 11 _!_ _TUP_10 [{{Eq Float}}, {{Text Float}}, (Float -> Float -> Float), (Float -> Float -> Float), (Float -> Float -> Float), (Float -> Float), (Float -> Float), (Float -> Float), (Integer -> Float), (Int -> Float)] [_DFUN_ Eq (Float), _DFUN_ Text (Float), _CONSTM_ Num (+) (Float), _CONSTM_ Num (-) (Float), _CONSTM_ Num (*) (Float), _CONSTM_ Num negate (Float), _CONSTM_ Num abs (Float), _CONSTM_ Num signum (Float), _CONSTM_ Num fromInteger (Float), _CONSTM_ Num fromInt (Float)] _N_
	 (+) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Float#) (u1 :: Float#) -> case _#_ plusFloat# [] [u0, u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Float) (u1 :: Float) -> case u0 of { _ALG_ F# (u2 :: Float#) -> case u1 of { _ALG_ F# (u3 :: Float#) -> case _#_ plusFloat# [] [u2, u3] of { _PRIM_ (u4 :: Float#) -> _!_ F# [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 (-) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Float#) (u1 :: Float#) -> case _#_ minusFloat# [] [u0, u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Float) (u1 :: Float) -> case u0 of { _ALG_ F# (u2 :: Float#) -> case u1 of { _ALG_ F# (u3 :: Float#) -> case _#_ minusFloat# [] [u2, u3] of { _PRIM_ (u4 :: Float#) -> _!_ F# [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 (*) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Float#) (u1 :: Float#) -> case _#_ timesFloat# [] [u0, u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Float) (u1 :: Float) -> case u0 of { _ALG_ F# (u2 :: Float#) -> case u1 of { _ALG_ F# (u3 :: Float#) -> case _#_ timesFloat# [] [u2, u3] of { _PRIM_ (u4 :: Float#) -> _!_ F# [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 negate = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Float#) -> case _#_ negateFloat# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> case _#_ negateFloat# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ },
	 abs = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ },
	 signum = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ },
	 fromInteger = { _A_ 1 _U_ 1 _N_ _S_ "U(PPP)" {_A_ 3 _U_ 222 _N_ _N_ _F_ _IF_ARGS_ 0 3 XXX 3 \ (u0 :: Int#) (u1 :: Int#) (u2 :: ByteArray#) -> case _#_ encodeFloat# [] [u0, u1, u2, 0#] of { _PRIM_ (u3 :: Float#) -> _!_ F# [] [u3] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Integer) -> case u0 of { _ALG_ J# (u1 :: Int#) (u2 :: Int#) (u3 :: ByteArray#) -> case _#_ encodeFloat# [] [u1, u2, u3, 0#] of { _PRIM_ (u4 :: Float#) -> _!_ F# [] [u4] }; _NO_DEFLT_ } _N_ },
	 fromInt = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Int#) -> case _#_ int2Float# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Int) -> case u0 of { _ALG_ I# (u1 :: Int#) -> case _#_ int2Float# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ } #-}
instance Ord Float
	{-# GHC_PRAGMA _M_ PreludeCore {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 9 _!_ _TUP_8 [{{Eq Float}}, (Float -> Float -> Bool), (Float -> Float -> Bool), (Float -> Float -> Bool), (Float -> Float -> Bool), (Float -> Float -> Float), (Float -> Float -> Float), (Float -> Float -> _CMP_TAG)] [_DFUN_ Eq (Float), _CONSTM_ Ord (<) (Float), _CONSTM_ Ord (<=) (Float), _CONSTM_ Ord (>=) (Float), _CONSTM_ Ord (>) (Float), _CONSTM_ Ord max (Float), _CONSTM_ Ord min (Float), _CONSTM_ Ord _tagCmp (Float)] _N_
	 (<) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Float#) (u1 :: Float#) -> _#_ ltFloat# [] [u0, u1] _N_} _F_ _IF_ARGS_ 0 2 CC 3 \ (u0 :: Float) (u1 :: Float) -> case u0 of { _ALG_ F# (u2 :: Float#) -> case u1 of { _ALG_ F# (u3 :: Float#) -> _#_ ltFloat# [] [u2, u3]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 (<=) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Float#) (u1 :: Float#) -> _#_ leFloat# [] [u0, u1] _N_} _F_ _IF_ARGS_ 0 2 CC 3 \ (u0 :: Float) (u1 :: Float) -> case u0 of { _ALG_ F# (u2 :: Float#) -> case u1 of { _ALG_ F# (u3 :: Float#) -> _#_ leFloat# [] [u2, u3]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 (>=) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Float#) (u1 :: Float#) -> _#_ geFloat# [] [u0, u1] _N_} _F_ _IF_ARGS_ 0 2 CC 3 \ (u0 :: Float) (u1 :: Float) -> case u0 of { _ALG_ F# (u2 :: Float#) -> case u1 of { _ALG_ F# (u3 :: Float#) -> _#_ geFloat# [] [u2, u3]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 (>) = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 1 \ (u0 :: Float#) (u1 :: Float#) -> _#_ gtFloat# [] [u0, u1] _N_} _F_ _IF_ARGS_ 0 2 CC 3 \ (u0 :: Float) (u1 :: Float) -> case u0 of { _ALG_ F# (u2 :: Float#) -> case u1 of { _ALG_ F# (u3 :: Float#) -> _#_ gtFloat# [] [u2, u3]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 max = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 min = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 _tagCmp = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
instance Real Float
	{-# GHC_PRAGMA _M_ PreludeCore {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 4 _!_ _TUP_3 [{{Num Float}}, {{Enum Float}}, (Float -> Ratio Integer)] [_DFUN_ Num (Float), _DFUN_ Enum (Float), _CONSTM_ Real toRational (Float)] _N_
	 toRational = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
instance RealFloat Float
	{-# GHC_PRAGMA _M_ PreludeCore {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 11 _!_ _TUP_10 [{{RealFrac Float}}, {{Floating Float}}, (Float -> Integer), (Float -> Int), (Float -> (Int, Int)), (Float -> (Integer, Int)), (Integer -> Int -> Float), (Float -> Int), (Float -> Float), (Int -> Float -> Float)] [_DFUN_ RealFrac (Float), _DFUN_ Floating (Float), _CONSTM_ RealFloat floatRadix (Float), _CONSTM_ RealFloat floatDigits (Float), _CONSTM_ RealFloat floatRange (Float), _CONSTM_ RealFloat decodeFloat (Float), _CONSTM_ RealFloat encodeFloat (Float), _CONSTM_ RealFloat exponent (Float), _CONSTM_ RealFloat significand (Float), _CONSTM_ RealFloat scaleFloat (Float)] _N_
	 floatRadix = { _A_ 1 _U_ 0 _N_ _S_ "A" {_A_ 0 _N_ _N_ _N_ _N_ _N_} _N_ _N_ },
	 floatDigits = { _A_ 1 _U_ 0 _N_ _S_ "A" {_A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _!_ I# [] [24#] _N_} _F_ _IF_ARGS_ 0 1 X 2 \ (u0 :: Float) -> _!_ I# [] [24#] _N_ },
	 floatRange = { _A_ 1 _U_ 0 _N_ _S_ "A" {_A_ 0 _N_ _N_ _N_ _N_ _N_} _N_ _N_ },
	 decodeFloat = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ },
	 encodeFloat = { _A_ 2 _U_ 11 _N_ _S_ "U(PPP)U(P)" {_A_ 4 _U_ 2222 _N_ _N_ _F_ _IF_ARGS_ 0 4 XXXX 3 \ (u0 :: Int#) (u1 :: Int#) (u2 :: ByteArray#) (u3 :: Int#) -> case _#_ encodeFloat# [] [u0, u1, u2, u3] of { _PRIM_ (u4 :: Float#) -> _!_ F# [] [u4] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Integer) (u1 :: Int) -> case u0 of { _ALG_ J# (u2 :: Int#) (u3 :: Int#) (u4 :: ByteArray#) -> case u1 of { _ALG_ I# (u5 :: Int#) -> case _#_ encodeFloat# [] [u2, u3, u4, u5] of { _PRIM_ (u6 :: Float#) -> _!_ F# [] [u6] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ },
	 exponent = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ },
	 significand = { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ },
	 scaleFloat = { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
instance RealFrac Float
	{-# GHC_PRAGMA _M_ PreludeCore {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 8 _!_ _TUP_7 [{{Real Float}}, {{Fractional Float}}, _forall_ a$z1 =>{{Integral a$z1}} -> (Float -> (a$z1, Float)), _forall_ a$z1 =>{{Integral a$z1}} -> (Float -> a$z1), _forall_ a$z1 =>{{Integral a$z1}} -> (Float -> a$z1), _forall_ a$z1 =>{{Integral a$z1}} -> (Float -> a$z1), _forall_ a$z1 =>{{Integral a$z1}} -> (Float -> a$z1)] [_DFUN_ Real (Float), _DFUN_ Fractional (Float), _CONSTM_ RealFrac properFraction (Float), _CONSTM_ RealFrac truncate (Float), _CONSTM_ RealFrac round (Float), _CONSTM_ RealFrac ceiling (Float), _CONSTM_ RealFrac floor (Float)] _N_
	 properFraction = { _A_ 1 _U_ 11 _N_ _N_ _N_ _SPECIALISE_ [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ } },
	 truncate = { _A_ 1 _U_ 11 _N_ _N_ _N_ _SPECIALISE_ [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 4 \ (u0 :: Float#) -> case _APP_  _WRKR_ _SPEC_ _CONSTM_ RealFrac properFraction (Float) [ (Int) ] [ u0 ] of { _ALG_ _TUP_2 (u1 :: Int) (u2 :: Float) -> u1; _NO_DEFLT_ } _N_} _F_ _IF_ARGS_ 0 1 X 4 \ (u0 :: Float) -> case _APP_  _SPEC_ _CONSTM_ RealFrac properFraction (Float) [ (Int) ] [ u0 ] of { _ALG_ _TUP_2 (u1 :: Int) (u2 :: Float) -> u1; _NO_DEFLT_ } _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 4 \ (u0 :: Float#) -> case _APP_  _WRKR_ _SPEC_ _CONSTM_ RealFrac properFraction (Float) [ (Integer) ] [ u0 ] of { _ALG_ _TUP_2 (u1 :: Integer) (u2 :: Float) -> u1; _NO_DEFLT_ } _N_} _F_ _IF_ARGS_ 0 1 X 4 \ (u0 :: Float) -> case _APP_  _SPEC_ _CONSTM_ RealFrac properFraction (Float) [ (Integer) ] [ u0 ] of { _ALG_ _TUP_2 (u1 :: Integer) (u2 :: Float) -> u1; _NO_DEFLT_ } _N_ } },
	 round = { _A_ 1 _U_ 21 _N_ _N_ _N_ _SPECIALISE_ [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ } },
	 ceiling = { _A_ 1 _U_ 21 _N_ _N_ _N_ _SPECIALISE_ [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ } },
	 floor = { _A_ 1 _U_ 21 _N_ _N_ _N_ _SPECIALISE_ [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ } } #-}
instance Text Float
	{-# GHC_PRAGMA _M_ PreludeCore {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Float, [Char])]), (Int -> Float -> [Char] -> [Char]), ([Char] -> [([Float], [Char])]), ([Float] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Float), _CONSTM_ Text showsPrec (Float), _CONSTM_ Text readList (Float), _CONSTM_ Text showList (Float)] _N_
	 readsPrec = { _A_ 2 _U_ 02 _N_ _S_ "AL" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ },
	 showsPrec = { _A_ 1 _U_ 222 _N_ _N_ _N_ _N_ },
	 readList = { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ },
	 showList = { _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ } #-}
instance _CCallable Float
	{-# GHC_PRAGMA _M_ PreludeCore {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _!_ _TUP_0 [] [] _N_ #-}
instance _CReturnable Float
	{-# GHC_PRAGMA _M_ PreludeCore {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _!_ _TUP_0 [] [] _N_ #-}

