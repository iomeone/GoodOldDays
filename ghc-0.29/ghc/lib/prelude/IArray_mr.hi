{-# GHC_PRAGMA INTERFACE VERSION 6 #-}
interface PreludeArray where
import PreludeBuiltin(Double(..), Int(..), List(..), Tuple2, _State(..))
import PreludeCore(Eq(..), Ix(..), Ord(..), Text(..))
import PreludeGlaST(_MutableArray, _freezeArray, _newArray)
data Array a b 	{-# GHC_PRAGMA _Array (a, a) (Array# b) #-}
data Assoc a b 	{-# GHC_PRAGMA (:=) a b #-}
(!) :: Ix a => Array a b -> a -> b
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "U(AASA)U(LP)L" {_A_ 4 _U_ 1222 _N_ _N_ _F_ _IF_ARGS_ 2 4 XXXX 7 _/\_ u0 u1 -> \ (u2 :: (u0, u0) -> u0 -> Int) (u3 :: (u0, u0)) (u4 :: Array# u1) (u5 :: u0) -> case _APP_  u2 [ u3, u5 ] of { _ALG_ I# (u6 :: Int#) -> case _#_ indexArray# [u1] [u4, u6] of { _ALG_ _Lift (u7 :: u1) -> u7; _NO_DEFLT_ }; _NO_DEFLT_ } _N_} _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: {{Ix u0}}) (u3 :: Array u0 u1) (u4 :: u0) -> case u2 of { _ALG_ _TUP_4 (u5 :: {{Ord u0}}) (u6 :: (u0, u0) -> [u0]) (u7 :: (u0, u0) -> u0 -> Int) (u8 :: (u0, u0) -> u0 -> Bool) -> case u3 of { _ALG_ _Array (u9 :: (u0, u0)) (ua :: Array# u1) -> case _APP_  u7 [ u9, u4 ] of { _ALG_ I# (ub :: Int#) -> case _#_ indexArray# [u1] [ua, ub] of { _ALG_ _Lift (uc :: u1) -> uc; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(U(U(P)U(P))P)U(P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(U(SS)P)U(U(P)U(P))" {_A_ 5 _U_ 11222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
(//) :: Ix a => Array a b -> [Assoc a b] -> Array a b
	{-# GHC_PRAGMA _A_ 3 _U_ 222 _N_ _S_ "U(LSLL)LS" _N_ _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ } #-}
_arrEleBottom :: a
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _S_ _!_ _N_ _N_ #-}
_freezeArray :: Ix b => _MutableArray a b c -> _State a -> (Array b c, _State a)
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _S_ "U(ASLA)U(U(LL)P)U(P)" {_A_ 5 _U_ 11222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ _N_, Int, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(U(U(P)U(P))P)U(P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ _N_, (Int, Int), _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(U(SS)P)U(P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
_newArray :: Ix b => (b, b) -> c -> _State a -> (_MutableArray a b c, _State a)
	{-# GHC_PRAGMA _A_ 4 _U_ 1221 _N_ _S_ "U(ASLA)U(LL)LU(P)" {_A_ 5 _U_ 11222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ _N_, Int, _N_ ] 1 { _A_ 3 _U_ 121 _N_ _S_ "U(U(P)U(P))LU(P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ _N_, (Int, Int), _N_ ] 1 { _A_ 3 _U_ 121 _N_ _S_ "U(SS)LU(P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
accum :: Ix b => (c -> a -> c) -> Array b c -> [Assoc b a] -> Array b c
	{-# GHC_PRAGMA _A_ 1 _U_ 1222 _N_ _S_ "U(ASLA)" {_A_ 5 _U_ 22222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ _N_, Int, _N_ ] 1 { _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ }, [ _N_, (Int, Int), _N_ ] 1 { _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ } #-}
accumArray :: Ix b => (c -> a -> c) -> c -> (b, b) -> [Assoc b a] -> Array b c
	{-# GHC_PRAGMA _A_ 5 _U_ 22222 _N_ _S_ "U(ASLA)LLLL" _N_ _SPECIALISE_ [ _N_, Int, _N_ ] 1 { _A_ 4 _U_ 2222 _N_ _N_ _N_ _N_ }, [ _N_, (Int, Int), _N_ ] 1 { _A_ 4 _U_ 2222 _N_ _N_ _N_ _N_ } #-}
amap :: Ix b => (a -> c) -> Array b a -> Array b c
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(ASLA)" {_A_ 4 _U_ 2221 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ _N_, Int, _N_ ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LU(U(U(P)U(P))P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ _N_, (Int, Int), _N_ ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LU(U(SS)P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
array :: Ix a => (a, a) -> [Assoc a b] -> Array a b
	{-# GHC_PRAGMA _A_ 3 _U_ 222 _N_ _S_ "SSS" _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: {{Ix u0}}) (u3 :: (u0, u0)) (u4 :: [Assoc u0 u1]) -> let {(u9 :: (u0, u0) -> u0 -> Int) = case u2 of { _ALG_ _TUP_4 (u5 :: {{Ord u0}}) (u6 :: (u0, u0) -> [u0]) (u7 :: (u0, u0) -> u0 -> Int) (u8 :: (u0, u0) -> u0 -> Bool) -> u7; _NO_DEFLT_ }} in case u3 of { _ALG_ _TUP_2 (ua :: u0) (ub :: u0) -> let {(ux :: _forall_ a$z1 =>_State a$z1 -> (Array u0 u1, _State a$z1)) = _/\_ u12 -> \ (ud :: _State u12) -> let {(ue :: u1) = _TYAPP_  _ORIG_ PreludeArray _arrEleBottom { u1 }} in case u2 of { _ALG_ _TUP_4 (uf :: {{Ord u0}}) (ug :: (u0, u0) -> [u0]) (uh :: (u0, u0) -> u0 -> Int) (ui :: (u0, u0) -> u0 -> Bool) -> case ud of { _ALG_ S# (uj :: State# u12) -> case _APP_  _TYAPP_  _TYAPP_  _TYAPP_  _WRKR_ _ORIG_ PreludeGlaST _newArray { u12 } { u0 } { u1 } [ ug, uh, u3, ue, uj ] of { _ALG_ _TUP_2 (uk :: _MutableArray u12 u0 u1) (ul :: _State u12) -> case uk of { _ALG_ _MutableArray (um :: (u0, u0)) (un :: MutableArray# u12 u1) -> let {(uv :: _State u12 -> Assoc u0 u1 -> _State u12) = \ (uo :: _State u12) (up :: Assoc u0 u1) -> case uo of { _ALG_ S# (uq :: State# u12) -> case up of { _ALG_ (:=) (ur :: u0) (us :: u1) -> case _APP_  u9 [ u3, ur ] of { _ALG_ I# (ut :: Int#) -> case _#_ writeArray# [u12, u1] [un, ut, us, uq] of { _PRIM_ (uu :: State# u12) -> _!_ S# [u12] [uu] }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }} in case _APP_  _TYAPP_  _TYAPP_  foldl { (_State u12) } { (Assoc u0 u1) } [ uv, ul, u4 ] of { _ALG_ S# (uw :: State# u12) -> _APP_  _TYAPP_  _TYAPP_  _TYAPP_  _WRKR_ _ORIG_ PreludeGlaST _freezeArray { u12 } { u0 } { u1 } [ ug, uh, um, un, uw ]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  _TYAPP_  _runST { (Array u0 u1) } [ ux ]; _NO_DEFLT_ } _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 12 _N_ _S_ "SS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: (Int, Int)) (u2 :: [Assoc Int u0]) -> case u1 of { _ALG_ _TUP_2 (u3 :: Int) (u4 :: Int) -> let {(ut :: _forall_ a$z1 =>_State a$z1 -> (Array Int u0, _State a$z1)) = _/\_ u5 -> \ (u6 :: _State u5) -> let {(u7 :: u0) = _TYAPP_  _ORIG_ PreludeArray _arrEleBottom { u0 }} in case u3 of { _ALG_ I# (u8 :: Int#) -> case u4 of { _ALG_ I# (u9 :: Int#) -> case u6 of { _ALG_ S# (ua :: State# u5) -> case _APP_  _TYAPP_  _TYAPP_  _WRKR_ _SPEC_ _ORIG_ PreludeGlaST _newArray [ _N_, (Int), _N_ ] { u5 } { u0 } [ u8, u9, u7, ua ] of { _ALG_ _TUP_2 (ub :: _MutableArray u5 Int u0) (uc :: _State u5) -> case ub of { _ALG_ _MutableArray (ud :: (Int, Int)) (ue :: MutableArray# u5 u0) -> let {(un :: _State u5 -> Assoc Int u0 -> _State u5) = \ (uf :: _State u5) (ug :: Assoc Int u0) -> case uf of { _ALG_ S# (uh :: State# u5) -> case ug of { _ALG_ (:=) (ui :: Int) (uj :: u0) -> case ui of { _ALG_ I# (uk :: Int#) -> case _#_ leInt# [] [u8, uk] of { _ALG_ True  -> case _#_ leInt# [] [uk, u9] of { _ALG_ True  -> case _#_ minusInt# [] [uk, u8] of { _PRIM_ (ul :: Int#) -> case _#_ writeArray# [u5, u0] [ue, ul, uj, uh] of { _PRIM_ (um :: State# u5) -> _!_ S# [u5] [um] } }; False  -> _APP_  _TYAPP_  _ORIG_ PreludeCore _rangeComplaint_Ix_Int { (_State u5) } [ uk, u8, u9 ]; _NO_DEFLT_ }; False  -> _APP_  _TYAPP_  _ORIG_ PreludeCore _rangeComplaint_Ix_Int { (_State u5) } [ uk, u8, u9 ]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }} in case _APP_  _TYAPP_  _TYAPP_  foldl { (_State u5) } { (Assoc Int u0) } [ un, uc, u2 ] of { _ALG_ S# (uo :: State# u5) -> case ud of { _ALG_ _TUP_2 (up :: Int) (uq :: Int) -> case up of { _ALG_ I# (ur :: Int#) -> case uq of { _ALG_ I# (us :: Int#) -> _APP_  _TYAPP_  _TYAPP_  _WRKR_ _SPEC_ _ORIG_ PreludeGlaST _freezeArray [ _N_, (Int), _N_ ] { u5 } { u0 } [ ur, us, ue, uo ]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  _TYAPP_  _runST { (Array Int u0) } [ ut ]; _NO_DEFLT_ } _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 2 _U_ 12 _N_ _S_ "SS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: ((Int, Int), (Int, Int))) (u2 :: [Assoc (Int, Int) u0]) -> case u1 of { _ALG_ _TUP_2 (u3 :: (Int, Int)) (u4 :: (Int, Int)) -> let {(uF :: _forall_ a$z1 =>_State a$z1 -> (Array (Int, Int) u0, _State a$z1)) = _/\_ u5 -> \ (u6 :: _State u5) -> let {(u7 :: u0) = _TYAPP_  _ORIG_ PreludeArray _arrEleBottom { u0 }} in case u6 of { _ALG_ S# (u8 :: State# u5) -> case _APP_  _TYAPP_  _TYAPP_  _WRKR_ _SPEC_ _ORIG_ PreludeGlaST _newArray [ _N_, ((Int, Int)), _N_ ] { u5 } { u0 } [ u3, u4, u7, u8 ] of { _ALG_ _TUP_2 (u9 :: _MutableArray u5 (Int, Int) u0) (ua :: _State u5) -> case u9 of { _ALG_ _MutableArray (ub :: ((Int, Int), (Int, Int))) (uc :: MutableArray# u5 u0) -> let {(uB :: _State u5 -> Assoc (Int, Int) u0 -> _State u5) = \ (ud :: _State u5) (ue :: Assoc (Int, Int) u0) -> case ud of { _ALG_ S# (uf :: State# u5) -> case ue of { _ALG_ (:=) (ug :: (Int, Int)) (uh :: u0) -> case u3 of { _ALG_ _TUP_2 (ui :: Int) (uj :: Int) -> case u4 of { _ALG_ _TUP_2 (uk :: Int) (ul :: Int) -> case ug of { _ALG_ _TUP_2 (um :: Int) (un :: Int) -> case ui of { _ALG_ I# (uo :: Int#) -> case uk of { _ALG_ I# (up :: Int#) -> case um of { _ALG_ I# (uq :: Int#) -> case _#_ leInt# [] [uo, uq] of { _ALG_ True  -> case _#_ leInt# [] [uq, up] of { _ALG_ True  -> case _#_ minusInt# [] [uq, uo] of { _PRIM_ (ur :: Int#) -> case uj of { _ALG_ I# (us :: Int#) -> case ul of { _ALG_ I# (ut :: Int#) -> case _#_ leInt# [] [us, ut] of { _ALG_ True  -> case _#_ leInt# [] [ut, ut] of { _ALG_ True  -> case _#_ minusInt# [] [ut, us] of { _PRIM_ (uu :: Int#) -> case _#_ plusInt# [] [uu, 1#] of { _PRIM_ (uv :: Int#) -> case _#_ timesInt# [] [ur, uv] of { _PRIM_ (uw :: Int#) -> case un of { _ALG_ I# (ux :: Int#) -> case _#_ leInt# [] [us, ux] of { _ALG_ True  -> case _#_ leInt# [] [ux, ut] of { _ALG_ True  -> case _#_ minusInt# [] [ux, us] of { _PRIM_ (uy :: Int#) -> case _#_ plusInt# [] [uw, uy] of { _PRIM_ (uz :: Int#) -> case _#_ writeArray# [u5, u0] [uc, uz, uh, uf] of { _PRIM_ (uA :: State# u5) -> _!_ S# [u5] [uA] } } }; False  -> _APP_  _TYAPP_  _ORIG_ PreludeCore _rangeComplaint_Ix_Int { (_State u5) } [ ux, us, ut ]; _NO_DEFLT_ }; False  -> _APP_  _TYAPP_  _ORIG_ PreludeCore _rangeComplaint_Ix_Int { (_State u5) } [ ux, us, ut ]; _NO_DEFLT_ }; _NO_DEFLT_ } } } }; False  -> _APP_  _TYAPP_  _ORIG_ PreludeCore _rangeComplaint_Ix_Int { (_State u5) } [ ut, us, ut ]; _NO_DEFLT_ }; False  -> _APP_  _TYAPP_  _ORIG_ PreludeCore _rangeComplaint_Ix_Int { (_State u5) } [ ut, us, ut ]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } }; False  -> _APP_  _TYAPP_  _ORIG_ PreludeCore _rangeComplaint_Ix_Int { (_State u5) } [ uq, uo, up ]; _NO_DEFLT_ }; False  -> _APP_  _TYAPP_  _ORIG_ PreludeCore _rangeComplaint_Ix_Int { (_State u5) } [ uq, uo, up ]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }} in case _APP_  _TYAPP_  _TYAPP_  foldl { (_State u5) } { (Assoc (Int, Int) u0) } [ uB, ua, u2 ] of { _ALG_ S# (uC :: State# u5) -> case ub of { _ALG_ _TUP_2 (uD :: (Int, Int)) (uE :: (Int, Int)) -> _APP_  _TYAPP_  _TYAPP_  _WRKR_ _SPEC_ _ORIG_ PreludeGlaST _freezeArray [ _N_, ((Int, Int)), _N_ ] { u5 } { u0 } [ uD, uE, uc, uC ]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  _TYAPP_  _runST { (Array (Int, Int) u0) } [ uF ]; _NO_DEFLT_ } _N_ } #-}
assocs :: Ix a => Array a b -> [Assoc a b]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: {{Ix u0}}) -> let {(u4 :: _forall_ a$z1 =>Array u0 a$z1 -> [u0]) = _/\_ u3 -> _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeArray indices { u3 } { u0 } [ u2 ]} in let {(u6 :: _forall_ a$z1 =>Array u0 a$z1 -> u0 -> a$z1) = _/\_ u5 -> _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeArray (!) { u0 } { u5 } [ u2 ]} in \ (u7 :: Array u0 u1) -> let {(uh :: _forall_ a$z1 =>(Assoc u0 u1 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u8 -> \ (u9 :: Assoc u0 u1 -> u8 -> u8) (ua :: u8) -> let {(uf :: u0 -> u8 -> u8) = \ (ub :: u0) (uc :: u8) -> let {(ud :: u1) = _APP_  _TYAPP_  u6 { u1 } [ u7, ub ]} in let {(ue :: Assoc u0 u1) = _!_ (:=) [u0, u1] [ub, ud]} in _APP_  u9 [ ue, uc ]} in let {(ug :: [u0]) = _APP_  _TYAPP_  u4 { u1 } [ u7 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u8 } [ uf, ua, ug ]} in _APP_  _TYAPP_  _build { (Assoc u0 u1) } [ uh ] _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 1 _U_ 2 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: Array Int u0) -> let {(ub :: _forall_ a$z1 =>(Assoc Int u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u2 -> \ (u3 :: Assoc Int u0 -> u2 -> u2) (u4 :: u2) -> let {(u9 :: Int -> u2 -> u2) = \ (u5 :: Int) (u6 :: u2) -> let {(u7 :: u0) = _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeArray (!) [ (Int), _N_ ] { u0 } [ u1, u5 ]} in let {(u8 :: Assoc Int u0) = _!_ (:=) [Int, u0] [u5, u7]} in _APP_  u3 [ u8, u6 ]} in let {(ua :: [Int]) = _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeArray indices [ _N_, (Int) ] { u0 } [ u1 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { Int } { u2 } [ u9, u4, ua ]} in _APP_  _TYAPP_  _build { (Assoc Int u0) } [ ub ] _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 1 _U_ 2 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: Array (Int, Int) u0) -> let {(ub :: _forall_ a$z1 =>(Assoc (Int, Int) u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u2 -> \ (u3 :: Assoc (Int, Int) u0 -> u2 -> u2) (u4 :: u2) -> let {(u9 :: (Int, Int) -> u2 -> u2) = \ (u5 :: (Int, Int)) (u6 :: u2) -> let {(u7 :: u0) = _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeArray (!) [ ((Int, Int)), _N_ ] { u0 } [ u1, u5 ]} in let {(u8 :: Assoc (Int, Int) u0) = _!_ (:=) [(Int, Int), u0] [u5, u7]} in _APP_  u3 [ u8, u6 ]} in let {(ua :: [(Int, Int)]) = _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeArray indices [ _N_, ((Int, Int)) ] { u0 } [ u1 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { (Int, Int) } { u2 } [ u9, u4, ua ]} in _APP_  _TYAPP_  _build { (Assoc (Int, Int) u0) } [ ub ] _N_ } #-}
bounds :: Array b a -> (b, b)
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(U(LL)P)" {_A_ 3 _U_ 220 _N_ _N_ _F_ _IF_ARGS_ 2 3 XXX 3 _/\_ u0 u1 -> \ (u2 :: u1) (u3 :: u1) (u4 :: Array# u0) -> _!_ _TUP_2 [u1, u1] [u2, u3] _N_} _F_ _IF_ARGS_ 2 1 C 2 _/\_ u0 u1 -> \ (u2 :: Array u1 u0) -> case u2 of { _ALG_ _Array (u3 :: (u1, u1)) (u4 :: Array# u0) -> u3; _NO_DEFLT_ } _N_ #-}
elems :: Ix a => Array a b -> [b]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: {{Ix u0}}) -> let {(u4 :: _forall_ a$z1 =>Array u0 a$z1 -> [u0]) = _/\_ u3 -> _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeArray indices { u3 } { u0 } [ u2 ]} in let {(u6 :: _forall_ a$z1 =>Array u0 a$z1 -> u0 -> a$z1) = _/\_ u5 -> _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeArray (!) { u0 } { u5 } [ u2 ]} in \ (u7 :: Array u0 u1) -> let {(ug :: _forall_ a$z1 =>(u1 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u8 -> \ (u9 :: u1 -> u8 -> u8) (ua :: u8) -> let {(ue :: u0 -> u8 -> u8) = \ (ub :: u0) (uc :: u8) -> let {(ud :: u1) = _APP_  _TYAPP_  u6 { u1 } [ u7, ub ]} in _APP_  u9 [ ud, uc ]} in let {(uf :: [u0]) = _APP_  _TYAPP_  u4 { u1 } [ u7 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u8 } [ ue, ua, uf ]} in _APP_  _TYAPP_  _build { u1 } [ ug ] _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 1 _U_ 2 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: Array Int u0) -> let {(ua :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u2 -> \ (u3 :: u0 -> u2 -> u2) (u4 :: u2) -> let {(u8 :: Int -> u2 -> u2) = \ (u5 :: Int) (u6 :: u2) -> let {(u7 :: u0) = _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeArray (!) [ (Int), _N_ ] { u0 } [ u1, u5 ]} in _APP_  u3 [ u7, u6 ]} in let {(u9 :: [Int]) = _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeArray indices [ _N_, (Int) ] { u0 } [ u1 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { Int } { u2 } [ u8, u4, u9 ]} in _APP_  _TYAPP_  _build { u0 } [ ua ] _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 1 _U_ 2 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: Array (Int, Int) u0) -> let {(ua :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u2 -> \ (u3 :: u0 -> u2 -> u2) (u4 :: u2) -> let {(u8 :: (Int, Int) -> u2 -> u2) = \ (u5 :: (Int, Int)) (u6 :: u2) -> let {(u7 :: u0) = _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeArray (!) [ ((Int, Int)), _N_ ] { u0 } [ u1, u5 ]} in _APP_  u3 [ u7, u6 ]} in let {(u9 :: [(Int, Int)]) = _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeArray indices [ _N_, ((Int, Int)) ] { u0 } [ u1 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { (Int, Int) } { u2 } [ u8, u4, u9 ]} in _APP_  _TYAPP_  _build { u0 } [ ua ] _N_ } #-}
indices :: Ix b => Array b a -> [b]
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "SL" _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: {{Ix u1}}) (u3 :: Array u1 u0) -> let {(u4 :: (u1, u1)) = _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeArray bounds { u0 } { u1 } [ u3 ]} in case u2 of { _ALG_ _TUP_4 (u5 :: {{Ord u1}}) (u6 :: (u1, u1) -> [u1]) (u7 :: (u1, u1) -> u1 -> Int) (u8 :: (u1, u1) -> u1 -> Bool) -> _APP_  u6 [ u4 ]; _NO_DEFLT_ } _SPECIALISE_ [ _N_, Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: Array Int u0) -> case _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeArray bounds { u0 } { Int } [ u1 ] of { _ALG_ _TUP_2 (u2 :: Int) (u3 :: Int) -> case u2 of { _ALG_ I# (u4 :: Int#) -> _LETREC_ {(u5 :: Int# -> [Int]) = \ (u6 :: Int#) -> case u3 of { _ALG_ I# (u7 :: Int#) -> case _#_ leInt# [] [u6, u7] of { _ALG_ True  -> let {(u9 :: [Int]) = case _#_ plusInt# [] [u6, 1#] of { _PRIM_ (u8 :: Int#) -> _APP_  u5 [ u8 ] }} in let {(ua :: Int) = _!_ I# [] [u6]} in _!_ (:) [Int] [ua, u9]; False  -> _!_ _NIL_ [Int] []; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  u5 [ u4 ]; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ }, [ _N_, (Int, Int) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: Array (Int, Int) u0) -> case _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeArray bounds { u0 } { (Int, Int) } [ u1 ] of { _ALG_ _TUP_2 (u2 :: (Int, Int)) (u3 :: (Int, Int)) -> case u2 of { _ALG_ _TUP_2 (u4 :: Int) (u5 :: Int) -> case u3 of { _ALG_ _TUP_2 (u6 :: Int) (u7 :: Int) -> let {(uy :: _forall_ a$z1 =>((Int, Int) -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u8 -> \ (u9 :: (Int, Int) -> u8 -> u8) (ua :: u8) -> let {(up :: Int -> u8 -> u8) = \ (ub :: Int) (uc :: u8) -> let {(ug :: Int -> u8 -> u8) = \ (ud :: Int) (ue :: u8) -> let {(uf :: (Int, Int)) = _!_ _TUP_2 [Int, Int] [ub, ud]} in _APP_  u9 [ uf, ue ]} in let {(uo :: [Int]) = case u5 of { _ALG_ I# (uh :: Int#) -> _LETREC_ {(ui :: Int# -> [Int]) = \ (uj :: Int#) -> case u7 of { _ALG_ I# (uk :: Int#) -> case _#_ leInt# [] [uj, uk] of { _ALG_ True  -> let {(um :: [Int]) = case _#_ plusInt# [] [uj, 1#] of { _PRIM_ (ul :: Int#) -> _APP_  ui [ ul ] }} in let {(un :: Int) = _!_ I# [] [uj]} in _!_ (:) [Int] [un, um]; False  -> _!_ _NIL_ [Int] []; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  ui [ uh ]; _NO_DEFLT_ }} in _APP_  _TYAPP_  _TYAPP_  foldr { Int } { u8 } [ ug, uc, uo ]} in let {(ux :: [Int]) = case u4 of { _ALG_ I# (uq :: Int#) -> _LETREC_ {(ur :: Int# -> [Int]) = \ (us :: Int#) -> case u6 of { _ALG_ I# (ut :: Int#) -> case _#_ leInt# [] [us, ut] of { _ALG_ True  -> let {(uv :: [Int]) = case _#_ plusInt# [] [us, 1#] of { _PRIM_ (uu :: Int#) -> _APP_  ur [ uu ] }} in let {(uw :: Int) = _!_ I# [] [us]} in _!_ (:) [Int] [uw, uv]; False  -> _!_ _NIL_ [Int] []; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  ur [ uq ]; _NO_DEFLT_ }} in _APP_  _TYAPP_  _TYAPP_  foldr { Int } { u8 } [ up, ua, ux ]} in _APP_  _TYAPP_  _build { (Int, Int) } [ uy ]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ } #-}
ixmap :: (Ix b, Ix a) => (b, b) -> (b -> a) -> Array a c -> Array b c
	{-# GHC_PRAGMA _A_ 2 _U_ 12222 _N_ _S_ "U(ASLA)L" {_A_ 6 _U_ 222222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
listArray :: Ix a => (a, a) -> [b] -> Array a b
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "U(ASLA)U(LL)L" {_A_ 5 _U_ 22222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(U(P)U(P))L" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(SS)L" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
instance (Ix a, Eq b) => Eq (Array a b)
	{-# GHC_PRAGMA _M_ PreludeArray {-dfun-} _A_ 2 _U_ 21 _N_ _N_ _N_ _N_ #-}
instance (Eq a, Eq b) => Eq (Assoc a b)
	{-# GHC_PRAGMA _M_ PreludeArray {-dfun-} _A_ 2 _U_ 11 _N_ _N_ _N_ _N_ #-}
instance (Ix a, Ix b) => Ix (Assoc a b)
	{-# GHC_PRAGMA _M_ PreludeArray {-dfun-} _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ #-}
instance (Ix a, Ord b) => Ord (Array a b)
	{-# GHC_PRAGMA _M_ PreludeArray {-dfun-} _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ #-}
instance (Ord a, Ord b) => Ord (Assoc a b)
	{-# GHC_PRAGMA _M_ PreludeArray {-dfun-} _A_ 3 _U_ 112 _N_ _N_ _N_ _N_ #-}
instance Text (Array (Int, Int) Double)
	{-# GHC_PRAGMA _M_ PreludeArray {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Array (Int, Int) Double, [Char])]), (Int -> Array (Int, Int) Double -> [Char] -> [Char]), ([Char] -> [([Array (Int, Int) Double], [Char])]), ([Array (Int, Int) Double] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Array (Int, Int) Double), _CONSTM_ Text showsPrec (Array (Int, Int) Double), _CONSTM_ Text readList (Array (Int, Int) Double), _CONSTM_ Text showList (Array (Int, Int) Double)] _N_
	 readsPrec = { _A_ 1 _U_ 12 _N_ _S_ "U(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 showsPrec = { _A_ 2 _U_ 122 _N_ _N_ _N_ _N_ },
	 readList = { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ },
	 showList = { _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ } #-}
instance (Ix a, Text a, Text b) => Text (Array a b)
	{-# GHC_PRAGMA _M_ PreludeArray {-dfun-} _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ #-}
instance Text (Array Int Double)
	{-# GHC_PRAGMA _M_ PreludeArray {-dfun-} _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 5 _!_ _TUP_4 [(Int -> [Char] -> [(Array Int Double, [Char])]), (Int -> Array Int Double -> [Char] -> [Char]), ([Char] -> [([Array Int Double], [Char])]), ([Array Int Double] -> [Char] -> [Char])] [_CONSTM_ Text readsPrec (Array Int Double), _CONSTM_ Text showsPrec (Array Int Double), _CONSTM_ Text readList (Array Int Double), _CONSTM_ Text showList (Array Int Double)] _N_
	 readsPrec = { _A_ 1 _U_ 12 _N_ _S_ "U(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ },
	 showsPrec = { _A_ 2 _U_ 122 _N_ _N_ _N_ _N_ },
	 readList = { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ },
	 showList = { _A_ 0 _U_ 12 _N_ _N_ _N_ _N_ } #-}
instance (Text a, Text b) => Text (Assoc a b)
	{-# GHC_PRAGMA _M_ PreludeArray {-dfun-} _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}

