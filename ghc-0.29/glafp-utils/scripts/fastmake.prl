#! /usr/local/bin/perl
#
($Pgm = $0) =~ s/.*\/([^\/]+)$/\1/;
$Usage = "\n" . <<EOUSAGE;
Usage:
    $Pgm [-? or -help] [-k] [-n] [-v] [-t] dir/module-target(s)

This script runs `make' to build the requested target, WITHOUT
including the dependencies generated by `mkdependHS' (i.e., all those
derived from import declarations).

With a -t flag, it also sets the modification time of the resulting
.hi file (one target only, please) to some EARLY date, so that changes
to that interface will not trigger much useless recompilation.

Typical uses, for module "Bar" in directory "foo":

(1) You've changed "Bar" and you want to recompile it; you know that
    other module interfaces are stable, so you'd rather do without all
    of `make''s prognostications:

    $Pgm foo/Bar.s

(2) You've ADDED a new function to "Bar"; you want to recompile that
    module, BUT NOT TRIGGER LOTS OF FURTHER COMPILATION because of the
    "changed" interface file:

    $Pgm -t foo/Bar.s

USE AT YOUR OWN RISK: you can make a big mess with this script!
EOUSAGE

$Makefile = 'Makefile';
if ( $ENV{'TMPDIR'} ) { # where to make tmp file names
    $Tmpfile = $ENV{'TMPDIR'} . "/Makefile$$";
} else {
    $Tmpfile  = "$(TMPDIR)/Makefile$$";
    $ENV{'TMPDIR'} = '$(TMPDIR)'; # set the env var as well
}
$SleazyTouch = '/usr/5bin/touch';
$DoTouch = 0;
$Verbose = 0;
$MakeFlags = '';

sub rm_temp_file {
    print STDERR "rm $Tmpfile\n" if $Verbose;
    unlink $Tmpfile;
    exit(1);
}
$SIG{'INT'}  = 'rm_temp_file';
$SIG{'QUIT'} = 'rm_temp_file';

$Target = '';
$DirMod = '';	# the dir/module-file to make

# process ARGV
while ($_ = $ARGV[0]) {
    shift(@ARGV);
    if (/^-\?$/ || /^-help$/) {
	print $Usage;
	exit 1;
    } elsif (/^-v$/) {
	$Verbose = 1;
    } elsif (/^-t$/) {
	$Do_touch = 1;
    } elsif (/^-k$/) {
	$MakeFlags .= ' -k';
    } elsif (/^-n$/) {
	$MakeFlags .= ' -n';
    } elsif (/^-d$/) {
	$MakeFlags .= ' -d';
    } elsif (/^-/) {
	print STDERR "$Pgm: unknown option: $_\n\n$Usage";
	exit 1;
    } elsif (/^([A-Z_]+)=(.+)/) {
	$MakeFlags .= " $1=\"$2\"";

    } elsif ($Do_touch) { # the module file
	$Target = $_;
	if ( /([^\/]+\/[^\/\.]+)\.[a-z]+/ ) {
	    $DirMod = $1;
	} else {
	    print STDERR "$Pgm: argument not of the form: directory/Module.suffix: $_\n\n$Usage";
	    exit 1;
	}
    } else {	# accumulate as "Target"...
	$Target .= " $_";
    }
}

if ($Do_touch && $Target =~ / /) {
    print STDERR "$Pgm: too many arguments\n\n$Usage";
    exit 1;
}

open(INF, "<$Makefile") || die "Can't open $Makefile for input\n";

open(OUTF,">$Tmpfile") || die "Can't open $Tmpfile for output\n";
select(OUTF);

$_ = <INF>;

# copy through until ...
while ( $_ && ! /^# DO NOT DELETE: Beginning of Haskell dependencies/ ) {
    print $_;
    $_ = <INF>;
}

# now copy through 'til the end, omitting the %.{o,s,hc} : %.hi dependencies
while ( $_ ) {
    print $_ if ! /^\S+ : \S+\.hi$/;
    $_ = <INF>;
}

close(INF);
close(OUTF);

$Make = 'make JMAKE=jmake LIT2PGM=lit2pgm LIT2LATEX=lit2latex LIT2TEXI=lit2texi MKDEPENDLIT=mkdependlit MAKEINFO=makeinfo POSTMAKEINFO=postmakeinfo';

print STDERR "$Make $MakeFlags -f $Tmpfile $Target; rm $Tmpfile\n" if $Verbose;

system( "$Make $MakeFlags -f $Tmpfile $Target; rm $Tmpfile" );

if ($Do_touch) {
    print STDERR "$SleazyTouch -m 01010101 $DirMod\.hi\n" if $Verbose;
    system( "$SleazyTouch -m 01010101 $DirMod\.hi" );
}
